<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VCTR: vctr::OwnedVector&lt; OwnedElementType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="sonible_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">VCTR
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classvctr_1_1OwnedVector.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classvctr_1_1OwnedVector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">vctr::OwnedVector&lt; OwnedElementType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A handy shortcut for <a class="el" href="classvctr_1_1Vector.html">Vector&lt;std::unique_ptr&lt;OwnedElementType&gt;&gt;</a>.  
 <a href="classvctr_1_1OwnedVector.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for vctr::OwnedVector&lt; OwnedElementType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvctr_1_1OwnedVector.png" usemap="#vctr::OwnedVector_3C_20OwnedElementType_20_3E_map" alt=""/>
  <map id="vctr::OwnedVector_3C_20OwnedElementType_20_3E_map" name="vctr::OwnedVector_3C_20OwnedElementType_20_3E_map">
<area href="classvctr_1_1Vector.html" alt="vctr::Vector&lt; std::unique_ptr&lt; OwnedElementType &gt; &gt;" shape="rect" coords="339,112,1008,136"/>
<area href="classvctr_1_1VctrBase.html" title="The base class to all one dimensional containers and views in the VCTR project." alt="vctr::VctrBase&lt; ElementType, StorageType, extent, StorageInfoType &gt;" shape="rect" coords="339,56,1008,80"/>
<area href="structvctr_1_1Config.html" alt="vctr::Config" shape="rect" coords="0,0,669,24"/>
<area href="structvctr_1_1StorageInfo.html" title="A helper class to describe some properties regarding the storage class wrapped in a VctrBase instance..." alt="vctr::StorageInfo&lt; StorageType &gt;" shape="rect" coords="679,0,1348,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac9adeaf832b0f74a45b3fcc5f1bcacb5"><td class="memItemLeft" align="right" valign="top"><a id="ac9adeaf832b0f74a45b3fcc5f1bcacb5" name="ac9adeaf832b0f74a45b3fcc5f1bcacb5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = typename Vctr::value_type</td></tr>
<tr class="separator:ac9adeaf832b0f74a45b3fcc5f1bcacb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3a621bc317ad88c65fe40555df42e0ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1OwnedVector.html#a3a621bc317ad88c65fe40555df42e0ca">OwnedVector</a> (std::initializer_list&lt; OwnedElementType * &gt; elementsToOwn)</td></tr>
<tr class="memdesc:a3a621bc317ad88c65fe40555df42e0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classvctr_1_1OwnedVector.html" title="A handy shortcut for Vector&lt;std::unique_ptr&lt;OwnedElementType&gt;&gt;.">OwnedVector</a> from an initializer list of raw pointers that will be owned by the <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>.  <br /></td></tr>
<tr class="separator:a3a621bc317ad88c65fe40555df42e0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bf557594c6041c55649eb92901e274"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a81bf557594c6041c55649eb92901e274"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1OwnedVector.html#a81bf557594c6041c55649eb92901e274">OwnedVector</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a81bf557594c6041c55649eb92901e274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards every other constructor call to the base class constructor.  <br /></td></tr>
<tr class="separator:a81bf557594c6041c55649eb92901e274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af232e22612aa17d3fc8eaeee4fec245a"><td class="memItemLeft" align="right" valign="top">constexpr StdVectorType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#af232e22612aa17d3fc8eaeee4fec245a">getUnderlyingVector</a> ()</td></tr>
<tr class="memdesc:af232e22612aa17d3fc8eaeee4fec245a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying storage.  <br /></td></tr>
<tr class="separator:af232e22612aa17d3fc8eaeee4fec245a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac046b6e082cc01f8523e113cf1c8998f"><td class="memItemLeft" align="right" valign="top">constexpr const StdVectorType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#ac046b6e082cc01f8523e113cf1c8998f">getUnderlyingVector</a> () const</td></tr>
<tr class="memdesc:ac046b6e082cc01f8523e113cf1c8998f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying storage.  <br /></td></tr>
<tr class="separator:ac046b6e082cc01f8523e113cf1c8998f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a96f4ea593adeef523923771615c4c"><td class="memItemLeft" align="right" valign="top">constexpr StdVectorType &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#af7a96f4ea593adeef523923771615c4c">moveUnderlyingVector</a> () &amp;&amp;</td></tr>
<tr class="memdesc:af7a96f4ea593adeef523923771615c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the underlying storage out of this wrapper class.  <br /></td></tr>
<tr class="separator:af7a96f4ea593adeef523923771615c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a20e8c2566d1a37fbf5573263ef0cd"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a48a20e8c2566d1a37fbf5573263ef0cd">operator StdVectorType &amp;</a> ()</td></tr>
<tr class="memdesc:a48a20e8c2566d1a37fbf5573263ef0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator shortcut to getUnderlyingVector.  <br /></td></tr>
<tr class="separator:a48a20e8c2566d1a37fbf5573263ef0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefc323d674a4ed311f76affd72d0df6"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#acefc323d674a4ed311f76affd72d0df6">operator const StdVectorType &amp;</a> () const</td></tr>
<tr class="memdesc:acefc323d674a4ed311f76affd72d0df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator shortcut to getUnderlyingVector.  <br /></td></tr>
<tr class="separator:acefc323d674a4ed311f76affd72d0df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c02120533daf85c9f05d32bb042533"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a76c02120533daf85c9f05d32bb042533">operator std::vector&lt; ElementType, OtherAllocator &gt;</a> () const</td></tr>
<tr class="memdesc:a76c02120533daf85c9f05d32bb042533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator that allows us to assign this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a> to a std::vector with different allocator type.  <br /></td></tr>
<tr class="separator:a76c02120533daf85c9f05d32bb042533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4207603e009e34c913e8d2ac8dc5998"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#ad4207603e009e34c913e8d2ac8dc5998">resize</a> (size_t i)</td></tr>
<tr class="memdesc:ad4207603e009e34c913e8d2ac8dc5998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the size of this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>, potentially allocating memory.  <br /></td></tr>
<tr class="separator:ad4207603e009e34c913e8d2ac8dc5998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae864434d9d6595ecbdd38a3c9efeeb08"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#ae864434d9d6595ecbdd38a3c9efeeb08">reserve</a> (size_t i)</td></tr>
<tr class="memdesc:ae864434d9d6595ecbdd38a3c9efeeb08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-allocates memory for the given number of elements.  <br /></td></tr>
<tr class="separator:ae864434d9d6595ecbdd38a3c9efeeb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33309cf31d84a89abd7cccb88ab13b2"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#af33309cf31d84a89abd7cccb88ab13b2">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:af33309cf31d84a89abd7cccb88ab13b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the allocated memory to the actual number of elements.  <br /></td></tr>
<tr class="separator:af33309cf31d84a89abd7cccb88ab13b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4ef71d511b27c5cd679b593a27d802"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a5f4ef71d511b27c5cd679b593a27d802">init</a> (size_t newSize, const value_type &amp;value)</td></tr>
<tr class="memdesc:a5f4ef71d511b27c5cd679b593a27d802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this vector to newSize and fills it with the given value.  <br /></td></tr>
<tr class="separator:a5f4ef71d511b27c5cd679b593a27d802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cc75e1d308167e8a0f471f905432ad"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a06cc75e1d308167e8a0f471f905432ad">init</a> (size_t newSize, Fn &amp;&amp;initializerFunction)</td></tr>
<tr class="memdesc:a06cc75e1d308167e8a0f471f905432ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this vector to newSize and fills it via the given initializerFunction.  <br /></td></tr>
<tr class="separator:a06cc75e1d308167e8a0f471f905432ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86b97eadfbd8d9001b242badb20dbbd"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#ae86b97eadfbd8d9001b242badb20dbbd">clear</a> () noexcept</td></tr>
<tr class="memdesc:ae86b97eadfbd8d9001b242badb20dbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all elements from the <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>.  <br /></td></tr>
<tr class="separator:ae86b97eadfbd8d9001b242badb20dbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4956e9f906df5c7296a39bf059d54a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>&lt; ElementType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#aac4956e9f906df5c7296a39bf059d54a">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:aac4956e9f906df5c7296a39bf059d54a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>.  <br /></td></tr>
<tr class="separator:aac4956e9f906df5c7296a39bf059d54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44807f8a6e6c21fe0e662fd0488f9dc"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#aa44807f8a6e6c21fe0e662fd0488f9dc">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:aa44807f8a6e6c21fe0e662fd0488f9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements the <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a> can currently hold without re-allocation.  <br /></td></tr>
<tr class="separator:aa44807f8a6e6c21fe0e662fd0488f9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549badde5c63e189373f2546bc30f964"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a549badde5c63e189373f2546bc30f964">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a549badde5c63e189373f2546bc30f964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold.  <br /></td></tr>
<tr class="separator:a549badde5c63e189373f2546bc30f964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0a51b21ebed67e1f7b94ccdefa2e1d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a5c0a51b21ebed67e1f7b94ccdefa2e1d">erase</a> (ConstIterator elementToErase)</td></tr>
<tr class="memdesc:a5c0a51b21ebed67e1f7b94ccdefa2e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the element referenced by elementToErase and returns the iterator to the element behind it.  <br /></td></tr>
<tr class="separator:a5c0a51b21ebed67e1f7b94ccdefa2e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6169a146004714cc4057f5eefa32292f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a6169a146004714cc4057f5eefa32292f">erase</a> (size_t idx)</td></tr>
<tr class="memdesc:a6169a146004714cc4057f5eefa32292f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the element at index idx and returns the iterator to the element behind it.  <br /></td></tr>
<tr class="separator:a6169a146004714cc4057f5eefa32292f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc62a7501f19f0cfa810eea535158c96"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#afc62a7501f19f0cfa810eea535158c96">erase</a> (ConstIterator first, ConstIterator last)</td></tr>
<tr class="memdesc:afc62a7501f19f0cfa810eea535158c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the range of elements referenced by it and returns the iterator to the element behind it.  <br /></td></tr>
<tr class="separator:afc62a7501f19f0cfa810eea535158c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f332eed0002936fc2218866ecaba2f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#aa4f332eed0002936fc2218866ecaba2f">erase</a> (size_t startIdx, size_t numElements)</td></tr>
<tr class="memdesc:aa4f332eed0002936fc2218866ecaba2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases numElements elements starting from index startIdx and returns the iterator to the element behind it.  <br /></td></tr>
<tr class="separator:aa4f332eed0002936fc2218866ecaba2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c52ecd0cfeceb21eaf37f8b6f36d01"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#ab4c52ecd0cfeceb21eaf37f8b6f36d01">eraseFirstOccurrenceOf</a> (const T &amp;value)</td></tr>
<tr class="memdesc:ab4c52ecd0cfeceb21eaf37f8b6f36d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the first occurrence of value from this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a> and adjusts its size.  <br /></td></tr>
<tr class="separator:ab4c52ecd0cfeceb21eaf37f8b6f36d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c843ed894a40acde5dbe4a46813dad"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a73c843ed894a40acde5dbe4a46813dad">eraseFirstOccurrenceIf</a> (Fn &amp;&amp;predicate)</td></tr>
<tr class="memdesc:a73c843ed894a40acde5dbe4a46813dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the first occurrence for which predicate is true from this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a> and adjusts its size.  <br /></td></tr>
<tr class="separator:a73c843ed894a40acde5dbe4a46813dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfff322866872974a2d7249720e5ae0"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#aebfff322866872974a2d7249720e5ae0">eraseAllOccurrencesOf</a> (const T &amp;value)</td></tr>
<tr class="memdesc:aebfff322866872974a2d7249720e5ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all occurrences of value from this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a> and adjusts its size.  <br /></td></tr>
<tr class="separator:aebfff322866872974a2d7249720e5ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487ed47ceaac55bd0e633673bf8b6a27"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a487ed47ceaac55bd0e633673bf8b6a27">eraseAllOccurrencesIf</a> (Fn &amp;&amp;predicate)</td></tr>
<tr class="memdesc:a487ed47ceaac55bd0e633673bf8b6a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements inside this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a> for which predicate is true and adjusts its size.  <br /></td></tr>
<tr class="separator:a487ed47ceaac55bd0e633673bf8b6a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb17ac821b61441fa7fe5627a020abd"><td class="memItemLeft" align="right" valign="top">constexpr ElementType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#aabb17ac821b61441fa7fe5627a020abd">push_back</a> (ElementType &amp;&amp;newElement)</td></tr>
<tr class="memdesc:aabb17ac821b61441fa7fe5627a020abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element to the end of the <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>.  <br /></td></tr>
<tr class="separator:aabb17ac821b61441fa7fe5627a020abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac934d9b8ecf1bf26c9b56c27227bcd67"><td class="memItemLeft" align="right" valign="top">constexpr ElementType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#ac934d9b8ecf1bf26c9b56c27227bcd67">push_back</a> (const ElementType &amp;newElement)</td></tr>
<tr class="memdesc:ac934d9b8ecf1bf26c9b56c27227bcd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element to the end of the <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>.  <br /></td></tr>
<tr class="separator:ac934d9b8ecf1bf26c9b56c27227bcd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8932b2885c55f96e4f00e4d9def65e09"><td class="memItemLeft" align="right" valign="top">constexpr ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a8932b2885c55f96e4f00e4d9def65e09">pop_back</a> ()</td></tr>
<tr class="memdesc:a8932b2885c55f96e4f00e4d9def65e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element in the vector, effectively reducing the container size by one.  <br /></td></tr>
<tr class="separator:a8932b2885c55f96e4f00e4d9def65e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62beb44c672def537e7179b3bd5de1ea"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a62beb44c672def537e7179b3bd5de1ea">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a62beb44c672def537e7179b3bd5de1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element in-place at the end of the <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>.  <br /></td></tr>
<tr class="separator:a62beb44c672def537e7179b3bd5de1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efdb84965206c223c69acb183ce74bd"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a9efdb84965206c223c69acb183ce74bd">swap</a> (<a class="el" href="classvctr_1_1Vector.html">Vector</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a9efdb84965206c223c69acb183ce74bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the underlying memory with the other <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>.  <br /></td></tr>
<tr class="separator:a9efdb84965206c223c69acb183ce74bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5629a26f7927e6c113be6636e379165a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a5629a26f7927e6c113be6636e379165a">append</a> (VctrToAppend &amp;&amp;vctrToAppend, bool moveValuesFromSrc=false)</td></tr>
<tr class="memdesc:a5629a26f7927e6c113be6636e379165a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a>, <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> or <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a> to the end of this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>, optionally by moving elements from the source.  <br /></td></tr>
<tr class="separator:a5629a26f7927e6c113be6636e379165a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab397edff06dbf1582240f63f97720b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a4ab397edff06dbf1582240f63f97720b">insert</a> (ConstIterator pos, const ElementType &amp;value)</td></tr>
<tr class="memdesc:a4ab397edff06dbf1582240f63f97720b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value before the element referenced by pos and returns an iterator to the inserted value.  <br /></td></tr>
<tr class="separator:a4ab397edff06dbf1582240f63f97720b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0deef69f8b0773766929cd1c37193876"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a0deef69f8b0773766929cd1c37193876">insert</a> (size_t idx, const ElementType &amp;value)</td></tr>
<tr class="memdesc:a0deef69f8b0773766929cd1c37193876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value at index idx and returns an iterator to the inserted value.  <br /></td></tr>
<tr class="separator:a0deef69f8b0773766929cd1c37193876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325003ee01e17102300452a30c1116b9"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a325003ee01e17102300452a30c1116b9">insert</a> (ConstIterator pos, ElementType &amp;&amp;value)</td></tr>
<tr class="memdesc:a325003ee01e17102300452a30c1116b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value before the element referenced by pos and returns an iterator to the inserted value.  <br /></td></tr>
<tr class="separator:a325003ee01e17102300452a30c1116b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef67c35c3ac6de7489b063a6e643b1d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a9ef67c35c3ac6de7489b063a6e643b1d">insert</a> (size_t idx, ElementType &amp;&amp;value)</td></tr>
<tr class="memdesc:a9ef67c35c3ac6de7489b063a6e643b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value at index idx and returns an iterator to the inserted value.  <br /></td></tr>
<tr class="separator:a9ef67c35c3ac6de7489b063a6e643b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e76533439e1ec1bca764e5c0ce0953"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a05e76533439e1ec1bca764e5c0ce0953">insert</a> (ConstIterator pos, size_t numCopies, const ElementType &amp;value)</td></tr>
<tr class="memdesc:a05e76533439e1ec1bca764e5c0ce0953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts numCopies copies of value before the element referenced by pos and returns an iterator to the inserted values.  <br /></td></tr>
<tr class="separator:a05e76533439e1ec1bca764e5c0ce0953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667116b07d036368a6ad7e52770e95f6"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a667116b07d036368a6ad7e52770e95f6">insert</a> (size_t idx, size_t numCopies, const ElementType &amp;value)</td></tr>
<tr class="memdesc:a667116b07d036368a6ad7e52770e95f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts numCopies copies of value at index idx and returns an iterator to the inserted values.  <br /></td></tr>
<tr class="separator:a667116b07d036368a6ad7e52770e95f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9502e1e348cc5d136856d6d37811e2c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#ad9502e1e348cc5d136856d6d37811e2c">insert</a> (ConstIterator pos, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:ad9502e1e348cc5d136856d6d37811e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a range of values before the element referenced by pos and returns an iterator to the inserted values.  <br /></td></tr>
<tr class="separator:ad9502e1e348cc5d136856d6d37811e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6063deda9064e94fd866eb97e9277c15"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a6063deda9064e94fd866eb97e9277c15">insert</a> (size_t idx, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a6063deda9064e94fd866eb97e9277c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a range of values at index idx and returns an iterator to the inserted values.  <br /></td></tr>
<tr class="separator:a6063deda9064e94fd866eb97e9277c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9b496a98a7cb851e433190342140f3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a2f9b496a98a7cb851e433190342140f3">insert</a> (ConstIterator pos, std::initializer_list&lt; ElementType &gt; initList)</td></tr>
<tr class="memdesc:a2f9b496a98a7cb851e433190342140f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a list of values before the element referenced by pos and returns an iterator to the first inserted value.  <br /></td></tr>
<tr class="separator:a2f9b496a98a7cb851e433190342140f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7d385bccf2634d09ab21c9e2ff234b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a4e7d385bccf2634d09ab21c9e2ff234b">insert</a> (size_t idx, std::initializer_list&lt; ElementType &gt; initList)</td></tr>
<tr class="memdesc:a4e7d385bccf2634d09ab21c9e2ff234b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a list of values at index idx and returns an iterator to the first inserted value.  <br /></td></tr>
<tr class="separator:a4e7d385bccf2634d09ab21c9e2ff234b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7944fb6f9a3ad4d91cf742f3e624fb"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#a7f7944fb6f9a3ad4d91cf742f3e624fb">insert</a> (ConstIterator pos, VctrToInsert &amp;&amp;vctrToInsert, bool moveValuesFromSrc=false)</td></tr>
<tr class="memdesc:a7f7944fb6f9a3ad4d91cf742f3e624fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a VCTR container before the element referenced by pos and returns an iterator to the first inserted value.  <br /></td></tr>
<tr class="separator:a7f7944fb6f9a3ad4d91cf742f3e624fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2087b728f19b6ceea4bcc41d432c2f5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html#ae2087b728f19b6ceea4bcc41d432c2f5">insert</a> (size_t idx, VctrToInsert &amp;&amp;vctrToInsert, bool moveValuesFromSrc=false)</td></tr>
<tr class="memdesc:ae2087b728f19b6ceea4bcc41d432c2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a VCTR container at index idx and returns an iterator to the first inserted value.  <br /></td></tr>
<tr class="separator:ae2087b728f19b6ceea4bcc41d432c2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec564aacdb2c8a90604e4fa142404ed"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a0ec564aacdb2c8a90604e4fa142404ed">size</a> () const noexcept</td></tr>
<tr class="memdesc:a0ec564aacdb2c8a90604e4fa142404ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements.  <br /></td></tr>
<tr class="separator:a0ec564aacdb2c8a90604e4fa142404ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb907e744177485ef9aaf219b0756b90"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#acb907e744177485ef9aaf219b0756b90">empty</a> () const noexcept</td></tr>
<tr class="memdesc:acb907e744177485ef9aaf219b0756b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the container is empty.  <br /></td></tr>
<tr class="separator:acb907e744177485ef9aaf219b0756b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681a9fa9e731497b3cdfc9752c091c9b"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a681a9fa9e731497b3cdfc9752c091c9b">sizeInBytes</a> () const noexcept</td></tr>
<tr class="memdesc:a681a9fa9e731497b3cdfc9752c091c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container size in bytes.  <br /></td></tr>
<tr class="separator:a681a9fa9e731497b3cdfc9752c091c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d10b2c53d0ab60ef0c2f9e97578f8b"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ab8d10b2c53d0ab60ef0c2f9e97578f8b">backIdx</a> () const noexcept</td></tr>
<tr class="memdesc:ab8d10b2c53d0ab60ef0c2f9e97578f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index referring to the last element in the vector.  <br /></td></tr>
<tr class="separator:ab8d10b2c53d0ab60ef0c2f9e97578f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa689a52afa0d76a308cf176083f731c6"><td class="memItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#aa689a52afa0d76a308cf176083f731c6">operator[]</a> (size_t i)</td></tr>
<tr class="memdesc:aa689a52afa0d76a308cf176083f731c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to element i.  <br /></td></tr>
<tr class="separator:aa689a52afa0d76a308cf176083f731c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d921dc0ff2a400920940dfee087ac8d"><td class="memItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a0d921dc0ff2a400920940dfee087ac8d">operator[]</a> (size_t i) const</td></tr>
<tr class="memdesc:a0d921dc0ff2a400920940dfee087ac8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to element i.  <br /></td></tr>
<tr class="separator:a0d921dc0ff2a400920940dfee087ac8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b345685b9741d1b59ffaaf3bfca3a6"><td class="memItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ac9b345685b9741d1b59ffaaf3bfca3a6">at</a> (size_t i)</td></tr>
<tr class="memdesc:ac9b345685b9741d1b59ffaaf3bfca3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to element i.  <br /></td></tr>
<tr class="separator:ac9b345685b9741d1b59ffaaf3bfca3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3c7eabe11604976881266c3f222fb6"><td class="memItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a8f3c7eabe11604976881266c3f222fb6">at</a> (size_t i) const</td></tr>
<tr class="memdesc:a8f3c7eabe11604976881266c3f222fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to element i.  <br /></td></tr>
<tr class="separator:a8f3c7eabe11604976881266c3f222fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b83cec6a9e6b0a5801d45331fefdf4"><td class="memItemLeft" align="right" valign="top">constexpr auto &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#aa0b83cec6a9e6b0a5801d45331fefdf4">front</a> ()</td></tr>
<tr class="memdesc:aa0b83cec6a9e6b0a5801d45331fefdf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element.  <br /></td></tr>
<tr class="separator:aa0b83cec6a9e6b0a5801d45331fefdf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5e8a34c7458574ddda43da9cfba433"><td class="memItemLeft" align="right" valign="top">constexpr auto &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a9a5e8a34c7458574ddda43da9cfba433">front</a> () const</td></tr>
<tr class="memdesc:a9a5e8a34c7458574ddda43da9cfba433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element.  <br /></td></tr>
<tr class="separator:a9a5e8a34c7458574ddda43da9cfba433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa966d96bbeefb5c773194c70a126cbe7"><td class="memItemLeft" align="right" valign="top">constexpr auto &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#aa966d96bbeefb5c773194c70a126cbe7">back</a> ()</td></tr>
<tr class="memdesc:aa966d96bbeefb5c773194c70a126cbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element.  <br /></td></tr>
<tr class="separator:aa966d96bbeefb5c773194c70a126cbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e55deac0cab66b4bad8d75bd420c4f"><td class="memItemLeft" align="right" valign="top">constexpr auto &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ae3e55deac0cab66b4bad8d75bd420c4f">back</a> () const</td></tr>
<tr class="memdesc:ae3e55deac0cab66b4bad8d75bd420c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element.  <br /></td></tr>
<tr class="separator:ae3e55deac0cab66b4bad8d75bd420c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776a0a4f16ecc3c25f5a1e2eac1d094b"><td class="memItemLeft" align="right" valign="top">VCTR_FORCEDINLINE constexpr auto *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a776a0a4f16ecc3c25f5a1e2eac1d094b">data</a> ()</td></tr>
<tr class="memdesc:a776a0a4f16ecc3c25f5a1e2eac1d094b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw pointer to the underlying storage.  <br /></td></tr>
<tr class="separator:a776a0a4f16ecc3c25f5a1e2eac1d094b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed4bae89175ad4f0da54a9d807d2d75"><td class="memItemLeft" align="right" valign="top">VCTR_FORCEDINLINE constexpr auto *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a2ed4bae89175ad4f0da54a9d807d2d75">data</a> () const</td></tr>
<tr class="memdesc:a2ed4bae89175ad4f0da54a9d807d2d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw pointer to the underlying storage.  <br /></td></tr>
<tr class="separator:a2ed4bae89175ad4f0da54a9d807d2d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d62467d4d84cd6e7fd185f73cf24033"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a4d62467d4d84cd6e7fd185f73cf24033">begin</a> ()</td></tr>
<tr class="memdesc:a4d62467d4d84cd6e7fd185f73cf24033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the begin of the storage.  <br /></td></tr>
<tr class="separator:a4d62467d4d84cd6e7fd185f73cf24033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72810409ab6153d55e6f9afb0743449"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ae72810409ab6153d55e6f9afb0743449">begin</a> () const</td></tr>
<tr class="memdesc:ae72810409ab6153d55e6f9afb0743449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the begin of the storage.  <br /></td></tr>
<tr class="separator:ae72810409ab6153d55e6f9afb0743449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82f4383edea8be887d6f1617cfa4edf"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf">end</a> ()</td></tr>
<tr class="memdesc:ae82f4383edea8be887d6f1617cfa4edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element behind the storage.  <br /></td></tr>
<tr class="separator:ae82f4383edea8be887d6f1617cfa4edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0117b7f6fc7cd51595146070fa0533"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a8d0117b7f6fc7cd51595146070fa0533">end</a> () const</td></tr>
<tr class="memdesc:a8d0117b7f6fc7cd51595146070fa0533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the first element behind the storage.  <br /></td></tr>
<tr class="separator:a8d0117b7f6fc7cd51595146070fa0533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af982e33f6fa36af4add9f0373bde98a8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#af982e33f6fa36af4add9f0373bde98a8">rbegin</a> ()</td></tr>
<tr class="memdesc:af982e33f6fa36af4add9f0373bde98a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the last element in the storage.  <br /></td></tr>
<tr class="separator:af982e33f6fa36af4add9f0373bde98a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dad4052f5d8720bdfb2414ac9b6b75"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#af5dad4052f5d8720bdfb2414ac9b6b75">rbegin</a> () const</td></tr>
<tr class="memdesc:af5dad4052f5d8720bdfb2414ac9b6b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the last element in the storage.  <br /></td></tr>
<tr class="separator:af5dad4052f5d8720bdfb2414ac9b6b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f6fd77a0b41775cbbdddc212a1eb38"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ac3f6fd77a0b41775cbbdddc212a1eb38">rend</a> ()</td></tr>
<tr class="memdesc:ac3f6fd77a0b41775cbbdddc212a1eb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element before the first element in the storage.  <br /></td></tr>
<tr class="separator:ac3f6fd77a0b41775cbbdddc212a1eb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa539547c92850b3e14f2067afd070c4b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#aa539547c92850b3e14f2067afd070c4b">rend</a> () const</td></tr>
<tr class="memdesc:aa539547c92850b3e14f2067afd070c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the element before the first element in the storage.  <br /></td></tr>
<tr class="separator:aa539547c92850b3e14f2067afd070c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d9c9c2d8cd0874aecc6f6ee17dfa66"><td class="memTemplParams" colspan="2">template&lt;size_t startIdx&gt; </td></tr>
<tr class="memitem:a29d9c9c2d8cd0874aecc6f6ee17dfa66"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a29d9c9c2d8cd0874aecc6f6ee17dfa66">subSpan</a> ()</td></tr>
<tr class="memdesc:a29d9c9c2d8cd0874aecc6f6ee17dfa66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> - startIdx.  <br /></td></tr>
<tr class="separator:a29d9c9c2d8cd0874aecc6f6ee17dfa66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1180d252ae45809e7150458345c93e"><td class="memTemplParams" colspan="2">template&lt;size_t startIdx&gt; </td></tr>
<tr class="memitem:a8a1180d252ae45809e7150458345c93e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a8a1180d252ae45809e7150458345c93e">subSpan</a> () const</td></tr>
<tr class="memdesc:a8a1180d252ae45809e7150458345c93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> - startIdx.  <br /></td></tr>
<tr class="separator:a8a1180d252ae45809e7150458345c93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e737d53237f32af2685faa02ae26d55"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a8e737d53237f32af2685faa02ae26d55">subSpan</a> (size_t startIdx)</td></tr>
<tr class="memdesc:a8e737d53237f32af2685faa02ae26d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> - startIdx.  <br /></td></tr>
<tr class="separator:a8e737d53237f32af2685faa02ae26d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc30017f36afa555e69770aadbb5fb2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a2bc30017f36afa555e69770aadbb5fb2">subSpan</a> (size_t startIdx) const</td></tr>
<tr class="memdesc:a2bc30017f36afa555e69770aadbb5fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> - startIdx.  <br /></td></tr>
<tr class="separator:a2bc30017f36afa555e69770aadbb5fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828d59afc6a87d40566840ffde8a6a50"><td class="memTemplParams" colspan="2">template&lt;size_t startIdx, size_t numElements&gt; </td></tr>
<tr class="memitem:a828d59afc6a87d40566840ffde8a6a50"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a828d59afc6a87d40566840ffde8a6a50">subSpan</a> ()</td></tr>
<tr class="memdesc:a828d59afc6a87d40566840ffde8a6a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of numElements.  <br /></td></tr>
<tr class="separator:a828d59afc6a87d40566840ffde8a6a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214960993f1d15ed248de6382ae16b0e"><td class="memTemplParams" colspan="2">template&lt;size_t startIdx, size_t numElements&gt; </td></tr>
<tr class="memitem:a214960993f1d15ed248de6382ae16b0e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a214960993f1d15ed248de6382ae16b0e">subSpan</a> () const</td></tr>
<tr class="memdesc:a214960993f1d15ed248de6382ae16b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of numElements.  <br /></td></tr>
<tr class="separator:a214960993f1d15ed248de6382ae16b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ccea594565f121e340eb85db5ff972f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a5ccea594565f121e340eb85db5ff972f">subSpan</a> (size_t startIdx, size_t numElements)</td></tr>
<tr class="memdesc:a5ccea594565f121e340eb85db5ff972f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of numElements.  <br /></td></tr>
<tr class="separator:a5ccea594565f121e340eb85db5ff972f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebddf025d6d6fb9bc5deb44b4c9ca3c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a4ebddf025d6d6fb9bc5deb44b4c9ca3c">subSpan</a> (size_t startIdx, size_t numElements) const</td></tr>
<tr class="memdesc:a4ebddf025d6d6fb9bc5deb44b4c9ca3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of numElements.  <br /></td></tr>
<tr class="separator:a4ebddf025d6d6fb9bc5deb44b4c9ca3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eed8c702aa74cf5e9fbab436b8a6f20"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a4eed8c702aa74cf5e9fbab436b8a6f20">assign</a> (std::initializer_list&lt; ElementType &gt; elements)</td></tr>
<tr class="memdesc:a4eed8c702aa74cf5e9fbab436b8a6f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns elements from the initializer list to this instance.  <br /></td></tr>
<tr class="separator:a4eed8c702aa74cf5e9fbab436b8a6f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8d59c063990c037ff50a7a9e6b3749"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a6a8d59c063990c037ff50a7a9e6b3749">copyFrom</a> (const ElementType *otherData, size_t otherSize)</td></tr>
<tr class="memdesc:a6a8d59c063990c037ff50a7a9e6b3749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the content from otherData to this instance.  <br /></td></tr>
<tr class="separator:a6a8d59c063990c037ff50a7a9e6b3749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a469facc53750163032618d7ec2751"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ad4a469facc53750163032618d7ec2751">fill</a> (const value_type &amp;value)</td></tr>
<tr class="memdesc:ad4a469facc53750163032618d7ec2751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the container with the given value.  <br /></td></tr>
<tr class="separator:ad4a469facc53750163032618d7ec2751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e42070dab5544e39faf3d372913c11"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a13e42070dab5544e39faf3d372913c11">fillLinspace</a> (ElementType start, ElementType stop, bool includeEnd=true)</td></tr>
<tr class="memdesc:a13e42070dab5544e39faf3d372913c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the vector with evenly spaced numbers between start and stop.  <br /></td></tr>
<tr class="separator:a13e42070dab5544e39faf3d372913c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f93b4ac09db43de3553fea3194b5fc"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; void(value_type &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:a85f93b4ac09db43de3553fea3194b5fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a85f93b4ac09db43de3553fea3194b5fc">forEach</a> (Fn &amp;&amp;fn)</td></tr>
<tr class="memdesc:a85f93b4ac09db43de3553fea3194b5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function on each element.  <br /></td></tr>
<tr class="separator:a85f93b4ac09db43de3553fea3194b5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187a80a3e5380b3b61e666ce3f6d5424"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; void(const value_type &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:a187a80a3e5380b3b61e666ce3f6d5424"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a187a80a3e5380b3b61e666ce3f6d5424">forEach</a> (Fn &amp;&amp;fn) const</td></tr>
<tr class="memdesc:a187a80a3e5380b3b61e666ce3f6d5424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function on each element.  <br /></td></tr>
<tr class="separator:a187a80a3e5380b3b61e666ce3f6d5424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f93b4ac09db43de3553fea3194b5fc"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; value_type(const value_type &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:a85f93b4ac09db43de3553fea3194b5fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a85f93b4ac09db43de3553fea3194b5fc">forEach</a> (Fn &amp;&amp;fn)</td></tr>
<tr class="memdesc:a85f93b4ac09db43de3553fea3194b5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function on each element.  <br /></td></tr>
<tr class="separator:a85f93b4ac09db43de3553fea3194b5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f93b4ac09db43de3553fea3194b5fc"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; void(value_type &amp;, size_t)&gt; Fn&gt; </td></tr>
<tr class="memitem:a85f93b4ac09db43de3553fea3194b5fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a85f93b4ac09db43de3553fea3194b5fc">forEach</a> (Fn &amp;&amp;fn)</td></tr>
<tr class="memdesc:a85f93b4ac09db43de3553fea3194b5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function on each element and passes the element index as second function argument.  <br /></td></tr>
<tr class="separator:a85f93b4ac09db43de3553fea3194b5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187a80a3e5380b3b61e666ce3f6d5424"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; void(const value_type &amp;, size_t)&gt; Fn&gt; </td></tr>
<tr class="memitem:a187a80a3e5380b3b61e666ce3f6d5424"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a187a80a3e5380b3b61e666ce3f6d5424">forEach</a> (Fn &amp;&amp;fn) const</td></tr>
<tr class="memdesc:a187a80a3e5380b3b61e666ce3f6d5424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function on each element and passes the element index as second function argument.  <br /></td></tr>
<tr class="separator:a187a80a3e5380b3b61e666ce3f6d5424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f93b4ac09db43de3553fea3194b5fc"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; value_type(const value_type &amp;, size_t)&gt; Fn&gt; </td></tr>
<tr class="memitem:a85f93b4ac09db43de3553fea3194b5fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a85f93b4ac09db43de3553fea3194b5fc">forEach</a> (Fn &amp;&amp;fn)</td></tr>
<tr class="memdesc:a85f93b4ac09db43de3553fea3194b5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function on each element and passes the element index as second function argument.  <br /></td></tr>
<tr class="separator:a85f93b4ac09db43de3553fea3194b5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d70bbcdff2fd01c0f555d92467063a"><td class="memTemplParams" colspan="2">template&lt;class... Args, is::functionWithSignatureOrImplicitlyConvertible&lt; void(value_type &amp;, Args &amp;&amp;...)&gt; Fn&gt; </td></tr>
<tr class="memitem:a62d70bbcdff2fd01c0f555d92467063a"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a62d70bbcdff2fd01c0f555d92467063a">forEach</a> (Fn &amp;&amp;fn, Args &amp;&amp;... fnArgs)</td></tr>
<tr class="memdesc:a62d70bbcdff2fd01c0f555d92467063a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function on each element and forwards fnArgs to the function after the value.  <br /></td></tr>
<tr class="separator:a62d70bbcdff2fd01c0f555d92467063a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a72bd1e6f648eaa2c9780bc560c664"><td class="memTemplParams" colspan="2">template&lt;class... Args, is::functionWithSignatureOrImplicitlyConvertible&lt; void(const value_type &amp;, Args &amp;&amp;...)&gt; Fn&gt; </td></tr>
<tr class="memitem:ac3a72bd1e6f648eaa2c9780bc560c664"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ac3a72bd1e6f648eaa2c9780bc560c664">forEach</a> (Fn &amp;&amp;fn, Args &amp;&amp;... fnArgs) const</td></tr>
<tr class="memdesc:ac3a72bd1e6f648eaa2c9780bc560c664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function on each element and forwards fnArgs to the function after the value.  <br /></td></tr>
<tr class="separator:ac3a72bd1e6f648eaa2c9780bc560c664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d70bbcdff2fd01c0f555d92467063a"><td class="memTemplParams" colspan="2">template&lt;class... Args, is::functionWithSignatureOrImplicitlyConvertible&lt; value_type(const value_type &amp;, Args &amp;&amp;...)&gt; Fn&gt; </td></tr>
<tr class="memitem:a62d70bbcdff2fd01c0f555d92467063a"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a62d70bbcdff2fd01c0f555d92467063a">forEach</a> (Fn &amp;&amp;fn, Args &amp;&amp;... fnArgs)</td></tr>
<tr class="memdesc:a62d70bbcdff2fd01c0f555d92467063a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function on each element and forwards fnArgs to the function after the value.  <br /></td></tr>
<tr class="separator:a62d70bbcdff2fd01c0f555d92467063a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b32192ab7691ff8e24fe85937df8cfc"><td class="memTemplParams" colspan="2">template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </td></tr>
<tr class="memitem:a3b32192ab7691ff8e24fe85937df8cfc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a3b32192ab7691ff8e24fe85937df8cfc">find</a> (const T &amp;valueToLookFor)</td></tr>
<tr class="memdesc:a3b32192ab7691ff8e24fe85937df8cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element that equals valueToLookFor or <a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf" title="Returns an iterator to the first element behind the storage.">end()</a> if none was found.  <br /></td></tr>
<tr class="separator:a3b32192ab7691ff8e24fe85937df8cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457b883bdf44506a49faa497659aa0b4"><td class="memTemplParams" colspan="2">template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </td></tr>
<tr class="memitem:a457b883bdf44506a49faa497659aa0b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a457b883bdf44506a49faa497659aa0b4">find</a> (const T &amp;valueToLookFor) const</td></tr>
<tr class="memdesc:a457b883bdf44506a49faa497659aa0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the first element that equals valueToLookFor or <a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf" title="Returns an iterator to the first element behind the storage.">end()</a> if none was found.  <br /></td></tr>
<tr class="separator:a457b883bdf44506a49faa497659aa0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13389760f277db65b2d08cc058e58e25"><td class="memTemplParams" colspan="2">template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </td></tr>
<tr class="memitem:a13389760f277db65b2d08cc058e58e25"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a13389760f277db65b2d08cc058e58e25">findReverse</a> (const T &amp;valueToLookFor)</td></tr>
<tr class="memdesc:a13389760f277db65b2d08cc058e58e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the last element in this vector that equals valueToLookFor or <a class="el" href="classvctr_1_1VctrBase.html#ac3f6fd77a0b41775cbbdddc212a1eb38" title="Returns a reverse iterator to the element before the first element in the storage.">rend()</a> if none was found.  <br /></td></tr>
<tr class="separator:a13389760f277db65b2d08cc058e58e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684b197edd1baefcbb9db31bfd221faf"><td class="memTemplParams" colspan="2">template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </td></tr>
<tr class="memitem:a684b197edd1baefcbb9db31bfd221faf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a684b197edd1baefcbb9db31bfd221faf">findReverse</a> (const T &amp;valueToLookFor) const</td></tr>
<tr class="memdesc:a684b197edd1baefcbb9db31bfd221faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the last element in this vector that equals valueToLookFor or <a class="el" href="classvctr_1_1VctrBase.html#ac3f6fd77a0b41775cbbdddc212a1eb38" title="Returns a reverse iterator to the element before the first element in the storage.">rend()</a> if none was found.  <br /></td></tr>
<tr class="separator:a684b197edd1baefcbb9db31bfd221faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0a138a1344cc551cf44763435213e0"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:a8a0a138a1344cc551cf44763435213e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a8a0a138a1344cc551cf44763435213e0">findIf</a> (Fn &amp;&amp;predicate)</td></tr>
<tr class="memdesc:a8a0a138a1344cc551cf44763435213e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element in this vector for which predicate returns true or <a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf" title="Returns an iterator to the first element behind the storage.">end()</a> if none was found.  <br /></td></tr>
<tr class="separator:a8a0a138a1344cc551cf44763435213e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30f1790e9e54a5e29bc28118a6bd136"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:ac30f1790e9e54a5e29bc28118a6bd136"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ac30f1790e9e54a5e29bc28118a6bd136">findIf</a> (Fn &amp;&amp;predicate) const</td></tr>
<tr class="memdesc:ac30f1790e9e54a5e29bc28118a6bd136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the first element in this vector for which predicate returns true or <a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf" title="Returns an iterator to the first element behind the storage.">end()</a> if none was found.  <br /></td></tr>
<tr class="separator:ac30f1790e9e54a5e29bc28118a6bd136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c04176763bb439535383f415e9a1a41"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:a9c04176763bb439535383f415e9a1a41"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a9c04176763bb439535383f415e9a1a41">findIfReverse</a> (Fn &amp;&amp;predicate)</td></tr>
<tr class="memdesc:a9c04176763bb439535383f415e9a1a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the last element in this vector for which predicate returns true or <a class="el" href="classvctr_1_1VctrBase.html#ac3f6fd77a0b41775cbbdddc212a1eb38" title="Returns a reverse iterator to the element before the first element in the storage.">rend()</a> if none was found.  <br /></td></tr>
<tr class="separator:a9c04176763bb439535383f415e9a1a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b0c83ff87a33d32f08669e39ace236"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:a91b0c83ff87a33d32f08669e39ace236"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a91b0c83ff87a33d32f08669e39ace236">findIfReverse</a> (Fn &amp;&amp;predicate) const</td></tr>
<tr class="memdesc:a91b0c83ff87a33d32f08669e39ace236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the last element in this vector for which predicate returns true or <a class="el" href="classvctr_1_1VctrBase.html#ac3f6fd77a0b41775cbbdddc212a1eb38" title="Returns a reverse iterator to the element before the first element in the storage.">rend()</a> if none was found.  <br /></td></tr>
<tr class="separator:a91b0c83ff87a33d32f08669e39ace236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a8ac49770a19c6d3bef9a59ffacbdd"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a03a8ac49770a19c6d3bef9a59ffacbdd">count</a> (const ElementType &amp;valueToLookFor) const</td></tr>
<tr class="memdesc:a03a8ac49770a19c6d3bef9a59ffacbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that are equal to valueToLookFor.  <br /></td></tr>
<tr class="separator:a03a8ac49770a19c6d3bef9a59ffacbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3203acc6a3098a878819b1e02f00d1"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:a5a3203acc6a3098a878819b1e02f00d1"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a5a3203acc6a3098a878819b1e02f00d1">countIf</a> (Fn &amp;&amp;predicate) const</td></tr>
<tr class="memdesc:a5a3203acc6a3098a878819b1e02f00d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that satisfy predicate.  <br /></td></tr>
<tr class="separator:a5a3203acc6a3098a878819b1e02f00d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0aa01c4581292b0c61510403841e83"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:a4c0aa01c4581292b0c61510403841e83"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a4c0aa01c4581292b0c61510403841e83">all</a> (Fn &amp;&amp;predicate) const</td></tr>
<tr class="memdesc:a4c0aa01c4581292b0c61510403841e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements satisfy the predicate or if the container is empty.  <br /></td></tr>
<tr class="separator:a4c0aa01c4581292b0c61510403841e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e58cc0b4db47384b4bb9a6b6799ab2"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:ad9e58cc0b4db47384b4bb9a6b6799ab2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ad9e58cc0b4db47384b4bb9a6b6799ab2">any</a> (Fn &amp;&amp;predicate) const</td></tr>
<tr class="memdesc:ad9e58cc0b4db47384b4bb9a6b6799ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if one or more elements satisfy the predicate.  <br /></td></tr>
<tr class="separator:ad9e58cc0b4db47384b4bb9a6b6799ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf31bb72d409439360f387914d235757"><td class="memTemplParams" colspan="2">template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </td></tr>
<tr class="memitem:aaf31bb72d409439360f387914d235757"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#aaf31bb72d409439360f387914d235757">allElementsEqual</a> (const T &amp;value) const</td></tr>
<tr class="memdesc:aaf31bb72d409439360f387914d235757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements are equal to value or if the container is empty.  <br /></td></tr>
<tr class="separator:aaf31bb72d409439360f387914d235757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf5f3b3d0920f0ef7b2a9cc09d91f86"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a9cf5f3b3d0920f0ef7b2a9cc09d91f86">allElementsEqual</a> () const</td></tr>
<tr class="memdesc:a9cf5f3b3d0920f0ef7b2a9cc09d91f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements are equal to themselves.  <br /></td></tr>
<tr class="separator:a9cf5f3b3d0920f0ef7b2a9cc09d91f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca7364ca53cdea690f09329ccb89c36"><td class="memTemplParams" colspan="2">template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </td></tr>
<tr class="memitem:aeca7364ca53cdea690f09329ccb89c36"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#aeca7364ca53cdea690f09329ccb89c36">contains</a> (const T &amp;value) const</td></tr>
<tr class="memdesc:aeca7364ca53cdea690f09329ccb89c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if at least one element is equal to value.  <br /></td></tr>
<tr class="separator:aeca7364ca53cdea690f09329ccb89c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ae8625a2045e850b0a0162c1c7f3c3"><td class="memTemplParams" colspan="2">template&lt;is::contiguousIteratorWithValueTypeSameAs&lt; ElementType &gt; It&gt; </td></tr>
<tr class="memitem:a08ae8625a2045e850b0a0162c1c7f3c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a08ae8625a2045e850b0a0162c1c7f3c3">contains</a> (It it) const</td></tr>
<tr class="memdesc:a08ae8625a2045e850b0a0162c1c7f3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the iterator refers to an element inside this container or span.  <br /></td></tr>
<tr class="separator:a08ae8625a2045e850b0a0162c1c7f3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88aa485f2931bf79d075b06d132c6df7"><td class="memTemplParams" colspan="2">template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </td></tr>
<tr class="memitem:a88aa485f2931bf79d075b06d132c6df7"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::optional&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a88aa485f2931bf79d075b06d132c6df7">indexOf</a> (const T &amp;value) const</td></tr>
<tr class="memdesc:a88aa485f2931bf79d075b06d132c6df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first element that compares true to value or std::nullopt if none is found.  <br /></td></tr>
<tr class="separator:a88aa485f2931bf79d075b06d132c6df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7733e55415e624cf6a97fab0cef693"><td class="memTemplParams" colspan="2">template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </td></tr>
<tr class="memitem:a4d7733e55415e624cf6a97fab0cef693"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::optional&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a4d7733e55415e624cf6a97fab0cef693">indexOfReverse</a> (const T &amp;value) const</td></tr>
<tr class="memdesc:a4d7733e55415e624cf6a97fab0cef693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the last element that compares true to value or std::nullopt if none is found.  <br /></td></tr>
<tr class="separator:a4d7733e55415e624cf6a97fab0cef693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc631d848a921dbc4222a5890751067"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:aefc631d848a921dbc4222a5890751067"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::optional&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#aefc631d848a921dbc4222a5890751067">indexIf</a> (Fn &amp;&amp;predicate) const</td></tr>
<tr class="memdesc:aefc631d848a921dbc4222a5890751067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first element that satisfies the predicate or std::nullopt if none is found.  <br /></td></tr>
<tr class="separator:aefc631d848a921dbc4222a5890751067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13755f0b72bc98a60663e7e90be620cc"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:a13755f0b72bc98a60663e7e90be620cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::optional&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a13755f0b72bc98a60663e7e90be620cc">indexIfReverse</a> (Fn &amp;&amp;predicate) const</td></tr>
<tr class="memdesc:a13755f0b72bc98a60663e7e90be620cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the last element that satisfies the predicate or std::nullopt if none is found.  <br /></td></tr>
<tr class="separator:a13755f0b72bc98a60663e7e90be620cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080fe9d9e226860b48acde1178bb3209"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a080fe9d9e226860b48acde1178bb3209">findMaxElement</a> ()</td></tr>
<tr class="memdesc:a080fe9d9e226860b48acde1178bb3209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first greatest element.  <br /></td></tr>
<tr class="separator:a080fe9d9e226860b48acde1178bb3209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029ddc0c88fbc4aac667bca7f6125348"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a029ddc0c88fbc4aac667bca7f6125348">findMaxElement</a> () const</td></tr>
<tr class="memdesc:a029ddc0c88fbc4aac667bca7f6125348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first greatest element.  <br /></td></tr>
<tr class="separator:a029ddc0c88fbc4aac667bca7f6125348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2261b01e1400927039586ef3b4be869b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a2261b01e1400927039586ef3b4be869b">findMinElement</a> ()</td></tr>
<tr class="memdesc:a2261b01e1400927039586ef3b4be869b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first smallest element.  <br /></td></tr>
<tr class="separator:a2261b01e1400927039586ef3b4be869b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24e1fbd352ce351643a5d410179bb8d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ae24e1fbd352ce351643a5d410179bb8d">findMinElement</a> () const</td></tr>
<tr class="memdesc:ae24e1fbd352ce351643a5d410179bb8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first smallest element.  <br /></td></tr>
<tr class="separator:ae24e1fbd352ce351643a5d410179bb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8f6bb18b8c5fc752c3a3c2440bf589"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#abc8f6bb18b8c5fc752c3a3c2440bf589">indexOfMaxElement</a> () const</td></tr>
<tr class="memdesc:abc8f6bb18b8c5fc752c3a3c2440bf589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first greatest element (aka argMax).  <br /></td></tr>
<tr class="separator:abc8f6bb18b8c5fc752c3a3c2440bf589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575932e270e9eb0bb8bf3550cf47acf0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a575932e270e9eb0bb8bf3550cf47acf0">indexOfMinElement</a> () const</td></tr>
<tr class="memdesc:a575932e270e9eb0bb8bf3550cf47acf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first smallest element (aka argMin).  <br /></td></tr>
<tr class="separator:a575932e270e9eb0bb8bf3550cf47acf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf31ce8bd7c61d08b1d0a0128d4a94e"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#abaf31ce8bd7c61d08b1d0a0128d4a94e">firstValueGreaterThanOrEqualTo</a> (const value_type &amp;valueToLookFor) const</td></tr>
<tr class="memdesc:abaf31ce8bd7c61d08b1d0a0128d4a94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a std::optional holding a copy of the first element value which is greater or equal to valueToLookFor or std::nullopt if no such value is found.  <br /></td></tr>
<tr class="separator:abaf31ce8bd7c61d08b1d0a0128d4a94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8062350f8c34a092da9492372fb170"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a9f8062350f8c34a092da9492372fb170">firstValueGreaterThan</a> (const value_type &amp;valueToLookFor) const</td></tr>
<tr class="memdesc:a9f8062350f8c34a092da9492372fb170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a std::optional holding a copy of the first element value which is greater than valueToLookFor or std::nullopt if no such value is found.  <br /></td></tr>
<tr class="separator:a9f8062350f8c34a092da9492372fb170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c46dbf4c7e9584c2d4bc2e627aa3ee6"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a9c46dbf4c7e9584c2d4bc2e627aa3ee6">reverse</a> ()</td></tr>
<tr class="memdesc:a9c46dbf4c7e9584c2d4bc2e627aa3ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of all elements.  <br /></td></tr>
<tr class="separator:a9c46dbf4c7e9584c2d4bc2e627aa3ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c6ce671353756da7465f3def164f10"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a17c6ce671353756da7465f3def164f10">rotate</a> (size_t newFirstElementIdx)</td></tr>
<tr class="memdesc:a17c6ce671353756da7465f3def164f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates the elements so that the element with the index newFirstElementIdx becomes the first element and the element with the index newFirstElementIdx - 1 becomes the last element.  <br /></td></tr>
<tr class="separator:a17c6ce671353756da7465f3def164f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4204c2b21ab30ea9a78e1c30f76111b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#af4204c2b21ab30ea9a78e1c30f76111b">shiftLeft</a> (size_t n, bool clearFreeSpaceAfterShiftedRegion)</td></tr>
<tr class="memdesc:af4204c2b21ab30ea9a78e1c30f76111b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts all elements to the left by n.  <br /></td></tr>
<tr class="separator:af4204c2b21ab30ea9a78e1c30f76111b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b7cafbc190e73f31fbb191de2354e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a00b7cafbc190e73f31fbb191de2354e0">shiftRight</a> (size_t n, bool clearFreeSpaceBeforeShiftedRegion)</td></tr>
<tr class="memdesc:a00b7cafbc190e73f31fbb191de2354e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts all elements to the right by n.  <br /></td></tr>
<tr class="separator:a00b7cafbc190e73f31fbb191de2354e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ceab7317b693f9f763be9e74fc87d6"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a60ceab7317b693f9f763be9e74fc87d6">sort</a> ()</td></tr>
<tr class="memdesc:a60ceab7317b693f9f763be9e74fc87d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts all elements in an ascending order using operator &lt;=&gt;.  <br /></td></tr>
<tr class="separator:a60ceab7317b693f9f763be9e74fc87d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09242aefc7ce2ef77ed27b6a0551552b"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const value_type &amp;, const value_type &amp;)&gt; ComparatorFn&gt; </td></tr>
<tr class="memitem:a09242aefc7ce2ef77ed27b6a0551552b"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a09242aefc7ce2ef77ed27b6a0551552b">sort</a> (ComparatorFn &amp;&amp;compare)</td></tr>
<tr class="memdesc:a09242aefc7ce2ef77ed27b6a0551552b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts all elements in this vector according to the compare function.  <br /></td></tr>
<tr class="separator:a09242aefc7ce2ef77ed27b6a0551552b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71e907a8173889718559fef90a45aed"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ab71e907a8173889718559fef90a45aed">elementsAreSorted</a> () const</td></tr>
<tr class="memdesc:ab71e907a8173889718559fef90a45aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements are sorted.  <br /></td></tr>
<tr class="separator:ab71e907a8173889718559fef90a45aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd7d6eb3c0dbb9edca5ba132a77d4a5"><td class="memItemLeft" align="right" valign="top"><a id="afdd7d6eb3c0dbb9edca5ba132a77d4a5" name="afdd7d6eb3c0dbb9edca5ba132a77d4a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>prepareNeonEvaluation</b> () const</td></tr>
<tr class="separator:afdd7d6eb3c0dbb9edca5ba132a77d4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82baf69e22b816a5b14994c89889a138"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvctr_1_1NeonRegister.html">NeonRegister</a>&lt; std::remove_const_t&lt; ElementType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a82baf69e22b816a5b14994c89889a138">getNeon</a> (size_t i) const &amp;&amp;is</td></tr>
<tr class="memdesc:a82baf69e22b816a5b14994c89889a138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a certain expression in place on this vector, e.g.  <br /></td></tr>
<tr class="separator:a82baf69e22b816a5b14994c89889a138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fa683177debc6197094583a4b482d2"><td class="memItemLeft" align="right" valign="top"><a id="aa0fa683177debc6197094583a4b482d2" name="aa0fa683177debc6197094583a4b482d2"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>isNotAliased</b> (const void *) const</td></tr>
<tr class="separator:aa0fa683177debc6197094583a4b482d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdacaca21b643300b7f6cdc923204887"><td class="memItemLeft" align="right" valign="top"><a id="abdacaca21b643300b7f6cdc923204887" name="abdacaca21b643300b7f6cdc923204887"></a>
VCTR_FORCEDINLINE const ElementType *&#160;</td><td class="memItemRight" valign="bottom"><b>evalNextVectorOpInExpressionChain</b> (void *) const</td></tr>
<tr class="separator:abdacaca21b643300b7f6cdc923204887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dba12f45d035bd1a479ba0bc1a55437"><td class="memItemLeft" align="right" valign="top"><a id="a1dba12f45d035bd1a479ba0bc1a55437" name="a1dba12f45d035bd1a479ba0bc1a55437"></a>
constexpr const <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getStorageInfo</b> () const</td></tr>
<tr class="separator:a1dba12f45d035bd1a479ba0bc1a55437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9420adec66c33c58a40ecad62c94fdf"><td class="memTemplParams" colspan="2">template&lt;is::anyVctrOrExpression V&gt; </td></tr>
<tr class="memitem:af9420adec66c33c58a40ecad62c94fdf"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#af9420adec66c33c58a40ecad62c94fdf">operator*=</a> (const V &amp;v)</td></tr>
<tr class="memdesc:af9420adec66c33c58a40ecad62c94fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this by a vector or expression in place.  <br /></td></tr>
<tr class="separator:af9420adec66c33c58a40ecad62c94fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d393bcae1044593f341499d7e3ff784"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a7d393bcae1044593f341499d7e3ff784">operator*=</a> (value_type c)</td></tr>
<tr class="memdesc:a7d393bcae1044593f341499d7e3ff784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this by a constant in place.  <br /></td></tr>
<tr class="separator:a7d393bcae1044593f341499d7e3ff784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441226b45536b133601da22b47a9ccad"><td class="memTemplParams" colspan="2">template&lt;is::anyVctrOrExpression V&gt; </td></tr>
<tr class="memitem:a441226b45536b133601da22b47a9ccad"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a441226b45536b133601da22b47a9ccad">operator/=</a> (const V &amp;v)</td></tr>
<tr class="memdesc:a441226b45536b133601da22b47a9ccad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides this by a vector or expression in place.  <br /></td></tr>
<tr class="separator:a441226b45536b133601da22b47a9ccad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44993d0d98bdad4d42f7a8522d348574"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a44993d0d98bdad4d42f7a8522d348574">operator/=</a> (value_type c)</td></tr>
<tr class="memdesc:a44993d0d98bdad4d42f7a8522d348574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides this by a constant in place.  <br /></td></tr>
<tr class="separator:a44993d0d98bdad4d42f7a8522d348574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e6342e4327a648e9b7cf5a2ab46b3d"><td class="memTemplParams" colspan="2">template&lt;is::anyVctrOrExpression V&gt; </td></tr>
<tr class="memitem:a34e6342e4327a648e9b7cf5a2ab46b3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a34e6342e4327a648e9b7cf5a2ab46b3d">operator+=</a> (const V &amp;v)</td></tr>
<tr class="memdesc:a34e6342e4327a648e9b7cf5a2ab46b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a vector or expression to this in place.  <br /></td></tr>
<tr class="separator:a34e6342e4327a648e9b7cf5a2ab46b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a24a9704cd970e3f6430b2e1cd495c0"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a8a24a9704cd970e3f6430b2e1cd495c0">operator+=</a> (value_type c)</td></tr>
<tr class="memdesc:a8a24a9704cd970e3f6430b2e1cd495c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant to this in place.  <br /></td></tr>
<tr class="separator:a8a24a9704cd970e3f6430b2e1cd495c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f082ed08028aef23fddf52425fb254e"><td class="memTemplParams" colspan="2">template&lt;is::anyVctrOrExpression V&gt; </td></tr>
<tr class="memitem:a2f082ed08028aef23fddf52425fb254e"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a2f082ed08028aef23fddf52425fb254e">operator-=</a> (const V &amp;v)</td></tr>
<tr class="memdesc:a2f082ed08028aef23fddf52425fb254e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a vector or expression from this in place.  <br /></td></tr>
<tr class="separator:a2f082ed08028aef23fddf52425fb254e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4040fe16ec241401831c8f70781bf1"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a5d4040fe16ec241401831c8f70781bf1">operator-=</a> (value_type c)</td></tr>
<tr class="memdesc:a5d4040fe16ec241401831c8f70781bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a constant from this in place.  <br /></td></tr>
<tr class="separator:a5d4040fe16ec241401831c8f70781bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3809aad3dbd44783fb9d8b4dbbd97207"><td class="memItemLeft" align="right" valign="top">constexpr ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a3809aad3dbd44783fb9d8b4dbbd97207">min</a> () const</td></tr>
<tr class="memdesc:a3809aad3dbd44783fb9d8b4dbbd97207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimal value of all elements.  <br /></td></tr>
<tr class="separator:a3809aad3dbd44783fb9d8b4dbbd97207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e4d6969b97cb396af2d0a1f31b8b1d"><td class="memItemLeft" align="right" valign="top">constexpr ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ac2e4d6969b97cb396af2d0a1f31b8b1d">minAbs</a> () const</td></tr>
<tr class="memdesc:ac2e4d6969b97cb396af2d0a1f31b8b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimal absolute value of all elements.  <br /></td></tr>
<tr class="separator:ac2e4d6969b97cb396af2d0a1f31b8b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30ee026df44d26087f2b2e5242daabd"><td class="memItemLeft" align="right" valign="top">constexpr ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ac30ee026df44d26087f2b2e5242daabd">max</a> () const</td></tr>
<tr class="memdesc:ac30ee026df44d26087f2b2e5242daabd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum value of all elements.  <br /></td></tr>
<tr class="separator:ac30ee026df44d26087f2b2e5242daabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5928bed9ea669ad2500cdb1dd9346db7"><td class="memItemLeft" align="right" valign="top">constexpr ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a5928bed9ea669ad2500cdb1dd9346db7">maxAbs</a> () const</td></tr>
<tr class="memdesc:a5928bed9ea669ad2500cdb1dd9346db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum absolute value of all elements.  <br /></td></tr>
<tr class="separator:a5928bed9ea669ad2500cdb1dd9346db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82b22bb7cf07b3d7441240fd4be96e8"><td class="memItemLeft" align="right" valign="top">constexpr ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ad82b22bb7cf07b3d7441240fd4be96e8">mean</a> () const</td></tr>
<tr class="memdesc:ad82b22bb7cf07b3d7441240fd4be96e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mean value across all elements.  <br /></td></tr>
<tr class="separator:ad82b22bb7cf07b3d7441240fd4be96e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8380fd770f1c73e257bb644c9745af0"><td class="memItemLeft" align="right" valign="top">constexpr ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ae8380fd770f1c73e257bb644c9745af0">meanSquare</a> () const</td></tr>
<tr class="memdesc:ae8380fd770f1c73e257bb644c9745af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mean value across all squared elements.  <br /></td></tr>
<tr class="separator:ae8380fd770f1c73e257bb644c9745af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9ca4b0cc5d3894ff875bcc0a1fd431"><td class="memItemLeft" align="right" valign="top">constexpr ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a9b9ca4b0cc5d3894ff875bcc0a1fd431">rms</a> () const</td></tr>
<tr class="memdesc:a9b9ca4b0cc5d3894ff875bcc0a1fd431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the square root of the mean value across all squared elements.  <br /></td></tr>
<tr class="separator:a9b9ca4b0cc5d3894ff875bcc0a1fd431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5f3def86f5ab26a70456c779a91d9d"><td class="memItemLeft" align="right" valign="top">constexpr ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#add5f3def86f5ab26a70456c779a91d9d">sum</a> () const</td></tr>
<tr class="memdesc:add5f3def86f5ab26a70456c779a91d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements.  <br /></td></tr>
<tr class="separator:add5f3def86f5ab26a70456c779a91d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e8eb4d0bb4ef2a93441c79f680607c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#aa3e8eb4d0bb4ef2a93441c79f680607c">allElementsAreFinite</a> ()</td></tr>
<tr class="memdesc:aa3e8eb4d0bb4ef2a93441c79f680607c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements are finite.  <br /></td></tr>
<tr class="separator:aa3e8eb4d0bb4ef2a93441c79f680607c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ad88bbdf3ff0b9ae4aabbe5da92c54"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a73ad88bbdf3ff0b9ae4aabbe5da92c54">allElementsAreFinite</a> ()</td></tr>
<tr class="memdesc:a73ad88bbdf3ff0b9ae4aabbe5da92c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements are finite.  <br /></td></tr>
<tr class="separator:a73ad88bbdf3ff0b9ae4aabbe5da92c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78509572a38d4dc5ae95c7efaae0ec9d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a78509572a38d4dc5ae95c7efaae0ec9d">anyElementIsNaN</a> ()</td></tr>
<tr class="memdesc:a78509572a38d4dc5ae95c7efaae0ec9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any element is NaN.  <br /></td></tr>
<tr class="separator:a78509572a38d4dc5ae95c7efaae0ec9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b77066a3a1e469d00c316af2d94322"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a25b77066a3a1e469d00c316af2d94322">anyElementIsNaN</a> ()</td></tr>
<tr class="memdesc:a25b77066a3a1e469d00c316af2d94322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any real or imaginary part of an element is NaN.  <br /></td></tr>
<tr class="separator:a25b77066a3a1e469d00c316af2d94322"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0dbf4ef57c72393831bc95c2dbddd396"><td class="memItemLeft" align="right" valign="top">static consteval size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a0dbf4ef57c72393831bc95c2dbddd396">getExtent</a> (size_t amountToShrink=0)</td></tr>
<tr class="memdesc:a0dbf4ef57c72393831bc95c2dbddd396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the extent of this instance, optionally shrank by a certain amount.  <br /></td></tr>
<tr class="separator:a0dbf4ef57c72393831bc95c2dbddd396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83870ea4a869114785266ee2fab1598"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598">size</a> () noexcept</td></tr>
<tr class="memdesc:ae83870ea4a869114785266ee2fab1598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements.  <br /></td></tr>
<tr class="separator:ae83870ea4a869114785266ee2fab1598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4612236989c7950e0d69917a007f6b79"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a4612236989c7950e0d69917a007f6b79">sizeInBytes</a> () noexcept</td></tr>
<tr class="memdesc:a4612236989c7950e0d69917a007f6b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container size in bytes.  <br /></td></tr>
<tr class="separator:a4612236989c7950e0d69917a007f6b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8181b278900a8f16079dcde8750e21d5"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a8181b278900a8f16079dcde8750e21d5">backIdx</a> () noexcept</td></tr>
<tr class="memdesc:a8181b278900a8f16079dcde8750e21d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index referring to the last element in the vector.  <br /></td></tr>
<tr class="separator:a8181b278900a8f16079dcde8750e21d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class OwnedElementType&gt;<br />
class vctr::OwnedVector&lt; OwnedElementType &gt;</div><p>A handy shortcut for <a class="el" href="classvctr_1_1Vector.html">Vector&lt;std::unique_ptr&lt;OwnedElementType&gt;&gt;</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3a621bc317ad88c65fe40555df42e0ca" name="a3a621bc317ad88c65fe40555df42e0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a621bc317ad88c65fe40555df42e0ca">&#9670;&#160;</a></span>OwnedVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OwnedElementType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvctr_1_1OwnedVector.html">vctr::OwnedVector</a>&lt; OwnedElementType &gt;::OwnedVector </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; OwnedElementType * &gt;&#160;</td>
          <td class="paramname"><em>elementsToOwn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classvctr_1_1OwnedVector.html" title="A handy shortcut for Vector&lt;std::unique_ptr&lt;OwnedElementType&gt;&gt;.">OwnedVector</a> from an initializer list of raw pointers that will be owned by the <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>. </p>

</div>
</div>
<a id="a81bf557594c6041c55649eb92901e274" name="a81bf557594c6041c55649eb92901e274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81bf557594c6041c55649eb92901e274">&#9670;&#160;</a></span>OwnedVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OwnedElementType &gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvctr_1_1OwnedVector.html">vctr::OwnedVector</a>&lt; OwnedElementType &gt;::OwnedVector </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwards every other constructor call to the base class constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4c0aa01c4581292b0c61510403841e83" name="a4c0aa01c4581292b0c61510403841e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0aa01c4581292b0c61510403841e83">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::all </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all elements satisfy the predicate or if the container is empty. </p>

</div>
</div>
<a id="aa3e8eb4d0bb4ef2a93441c79f680607c" name="aa3e8eb4d0bb4ef2a93441c79f680607c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e8eb4d0bb4ef2a93441c79f680607c">&#9670;&#160;</a></span>allElementsAreFinite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::allElementsAreFinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all elements are finite. </p>

</div>
</div>
<a id="a73ad88bbdf3ff0b9ae4aabbe5da92c54" name="a73ad88bbdf3ff0b9ae4aabbe5da92c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ad88bbdf3ff0b9ae4aabbe5da92c54">&#9670;&#160;</a></span>allElementsAreFinite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::allElementsAreFinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all elements are finite. </p>

</div>
</div>
<a id="a9cf5f3b3d0920f0ef7b2a9cc09d91f86" name="a9cf5f3b3d0920f0ef7b2a9cc09d91f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf5f3b3d0920f0ef7b2a9cc09d91f86">&#9670;&#160;</a></span>allElementsEqual() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::allElementsEqual </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all elements are equal to themselves. </p>

</div>
</div>
<a id="aaf31bb72d409439360f387914d235757" name="aaf31bb72d409439360f387914d235757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf31bb72d409439360f387914d235757">&#9670;&#160;</a></span>allElementsEqual() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::allElementsEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all elements are equal to value or if the container is empty. </p>

</div>
</div>
<a id="ad9e58cc0b4db47384b4bb9a6b6799ab2" name="ad9e58cc0b4db47384b4bb9a6b6799ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e58cc0b4db47384b4bb9a6b6799ab2">&#9670;&#160;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::any </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if one or more elements satisfy the predicate. </p>

</div>
</div>
<a id="a78509572a38d4dc5ae95c7efaae0ec9d" name="a78509572a38d4dc5ae95c7efaae0ec9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78509572a38d4dc5ae95c7efaae0ec9d">&#9670;&#160;</a></span>anyElementIsNaN() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::anyElementIsNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if any element is NaN. </p>

</div>
</div>
<a id="a25b77066a3a1e469d00c316af2d94322" name="a25b77066a3a1e469d00c316af2d94322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b77066a3a1e469d00c316af2d94322">&#9670;&#160;</a></span>anyElementIsNaN() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::anyElementIsNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if any real or imaginary part of an element is NaN. </p>

</div>
</div>
<a id="a5629a26f7927e6c113be6636e379165a" name="a5629a26f7927e6c113be6636e379165a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5629a26f7927e6c113be6636e379165a">&#9670;&#160;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::append </td>
          <td>(</td>
          <td class="paramtype">VctrToAppend &amp;&amp;&#160;</td>
          <td class="paramname"><em>vctrToAppend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>moveValuesFromSrc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a>, <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> or <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a> to the end of this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>, optionally by moving elements from the source. </p>

</div>
</div>
<a id="a4eed8c702aa74cf5e9fbab436b8a6f20" name="a4eed8c702aa74cf5e9fbab436b8a6f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eed8c702aa74cf5e9fbab436b8a6f20">&#9670;&#160;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; ElementType &gt;&#160;</td>
          <td class="paramname"><em>elements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns elements from the initializer list to this instance. </p>
<p>In case it is a resizable <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>, it will be resized to match the size of the list, otherwise the list size must match the destination size. </p>

</div>
</div>
<a id="ac9b345685b9741d1b59ffaaf3bfca3a6" name="ac9b345685b9741d1b59ffaaf3bfca3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b345685b9741d1b59ffaaf3bfca3a6">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto &amp; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to element i. </p>
<p>Throws std::out_of_range if i &gt;= <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> </p>

</div>
</div>
<a id="a8f3c7eabe11604976881266c3f222fb6" name="a8f3c7eabe11604976881266c3f222fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3c7eabe11604976881266c3f222fb6">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto &amp; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to element i. </p>
<p>Throws std::out_of_range if i &gt;= <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> </p>

</div>
</div>
<a id="aa966d96bbeefb5c773194c70a126cbe7" name="aa966d96bbeefb5c773194c70a126cbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa966d96bbeefb5c773194c70a126cbe7">&#9670;&#160;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto &amp;&amp; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element. </p>

</div>
</div>
<a id="ae3e55deac0cab66b4bad8d75bd420c4f" name="ae3e55deac0cab66b4bad8d75bd420c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e55deac0cab66b4bad8d75bd420c4f">&#9670;&#160;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto &amp;&amp; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element. </p>

</div>
</div>
<a id="ab8d10b2c53d0ab60ef0c2f9e97578f8b" name="ab8d10b2c53d0ab60ef0c2f9e97578f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d10b2c53d0ab60ef0c2f9e97578f8b">&#9670;&#160;</a></span>backIdx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::backIdx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index referring to the last element in the vector. </p>
<p>This overload is a non-static function, used in case the extent is dynamic. </p>

</div>
</div>
<a id="a8181b278900a8f16079dcde8750e21d5" name="a8181b278900a8f16079dcde8750e21d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8181b278900a8f16079dcde8750e21d5">&#9670;&#160;</a></span>backIdx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::backIdx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index referring to the last element in the vector. </p>
<p>This overload is a static function, used in case the extent is static. </p>

</div>
</div>
<a id="a4d62467d4d84cd6e7fd185f73cf24033" name="a4d62467d4d84cd6e7fd185f73cf24033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d62467d4d84cd6e7fd185f73cf24033">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the begin of the storage. </p>

</div>
</div>
<a id="ae72810409ab6153d55e6f9afb0743449" name="ae72810409ab6153d55e6f9afb0743449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72810409ab6153d55e6f9afb0743449">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the begin of the storage. </p>

</div>
</div>
<a id="aa44807f8a6e6c21fe0e662fd0488f9dc" name="aa44807f8a6e6c21fe0e662fd0488f9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44807f8a6e6c21fe0e662fd0488f9dc">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements the <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a> can currently hold without re-allocation. </p>

</div>
</div>
<a id="ae86b97eadfbd8d9001b242badb20dbbd" name="ae86b97eadfbd8d9001b242badb20dbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86b97eadfbd8d9001b242badb20dbbd">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all elements from the <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>. </p>
<p>This is a standard interface function forwarded to std::vector::clear(). </p>

</div>
</div>
<a id="aeca7364ca53cdea690f09329ccb89c36" name="aeca7364ca53cdea690f09329ccb89c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca7364ca53cdea690f09329ccb89c36">&#9670;&#160;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if at least one element is equal to value. </p>

</div>
</div>
<a id="a08ae8625a2045e850b0a0162c1c7f3c3" name="a08ae8625a2045e850b0a0162c1c7f3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ae8625a2045e850b0a0162c1c7f3c3">&#9670;&#160;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::contiguousIteratorWithValueTypeSameAs&lt; ElementType &gt; It&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the iterator refers to an element inside this container or span. </p>
<p>It will return false in case it equals <a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf" title="Returns an iterator to the first element behind the storage.">end()</a>. </p>

</div>
</div>
<a id="a6a8d59c063990c037ff50a7a9e6b3749" name="a6a8d59c063990c037ff50a7a9e6b3749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8d59c063990c037ff50a7a9e6b3749">&#9670;&#160;</a></span>copyFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const ElementType *&#160;</td>
          <td class="paramname"><em>otherData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>otherSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the content from otherData to this instance. </p>
<p>In case the storage of this instance is resizable, it will resize it if necessary. Otherwise, it will simply assert that the size matches. </p>

</div>
</div>
<a id="a03a8ac49770a19c6d3bef9a59ffacbdd" name="a03a8ac49770a19c6d3bef9a59ffacbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a8ac49770a19c6d3bef9a59ffacbdd">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const ElementType &amp;&#160;</td>
          <td class="paramname"><em>valueToLookFor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements that are equal to valueToLookFor. </p>

</div>
</div>
<a id="a5a3203acc6a3098a878819b1e02f00d1" name="a5a3203acc6a3098a878819b1e02f00d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3203acc6a3098a878819b1e02f00d1">&#9670;&#160;</a></span>countIf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::countIf </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements that satisfy predicate. </p>

</div>
</div>
<a id="a776a0a4f16ecc3c25f5a1e2eac1d094b" name="a776a0a4f16ecc3c25f5a1e2eac1d094b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776a0a4f16ecc3c25f5a1e2eac1d094b">&#9670;&#160;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VCTR_FORCEDINLINE constexpr auto * <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a raw pointer to the underlying storage. </p>

</div>
</div>
<a id="a2ed4bae89175ad4f0da54a9d807d2d75" name="a2ed4bae89175ad4f0da54a9d807d2d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed4bae89175ad4f0da54a9d807d2d75">&#9670;&#160;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VCTR_FORCEDINLINE constexpr auto * <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a raw pointer to the underlying storage. </p>

</div>
</div>
<a id="ab71e907a8173889718559fef90a45aed" name="ab71e907a8173889718559fef90a45aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71e907a8173889718559fef90a45aed">&#9670;&#160;</a></span>elementsAreSorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::elementsAreSorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all elements are sorted. </p>

</div>
</div>
<a id="a62beb44c672def537e7179b3bd5de1ea" name="a62beb44c672def537e7179b3bd5de1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62beb44c672def537e7179b3bd5de1ea">&#9670;&#160;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an element in-place at the end of the <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>. </p>
<p>This is a standard interface function forwarded to std::vector::emplace_back(). </p>

</div>
</div>
<a id="acb907e744177485ef9aaf219b0756b90" name="acb907e744177485ef9aaf219b0756b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb907e744177485ef9aaf219b0756b90">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the container is empty. </p>

</div>
</div>
<a id="ae82f4383edea8be887d6f1617cfa4edf" name="ae82f4383edea8be887d6f1617cfa4edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82f4383edea8be887d6f1617cfa4edf">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element behind the storage. </p>

</div>
</div>
<a id="a8d0117b7f6fc7cd51595146070fa0533" name="a8d0117b7f6fc7cd51595146070fa0533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0117b7f6fc7cd51595146070fa0533">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the first element behind the storage. </p>

</div>
</div>
<a id="a5c0a51b21ebed67e1f7b94ccdefa2e1d" name="a5c0a51b21ebed67e1f7b94ccdefa2e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0a51b21ebed67e1f7b94ccdefa2e1d">&#9670;&#160;</a></span>erase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">ConstIterator&#160;</td>
          <td class="paramname"><em>elementToErase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases the element referenced by elementToErase and returns the iterator to the element behind it. </p>
<p>This is a standard interface function forwarded to std::vector::erase(). </p>

</div>
</div>
<a id="afc62a7501f19f0cfa810eea535158c96" name="afc62a7501f19f0cfa810eea535158c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc62a7501f19f0cfa810eea535158c96">&#9670;&#160;</a></span>erase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">ConstIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases the range of elements referenced by it and returns the iterator to the element behind it. </p>
<p>First is expected to be contained in the range while last is expected to be the first element after that range.</p>
<p>This is a standard interface function forwarded to std::vector::erase(). </p>

</div>
</div>
<a id="a6169a146004714cc4057f5eefa32292f" name="a6169a146004714cc4057f5eefa32292f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6169a146004714cc4057f5eefa32292f">&#9670;&#160;</a></span>erase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases the element at index idx and returns the iterator to the element behind it. </p>

</div>
</div>
<a id="aa4f332eed0002936fc2218866ecaba2f" name="aa4f332eed0002936fc2218866ecaba2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f332eed0002936fc2218866ecaba2f">&#9670;&#160;</a></span>erase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases numElements elements starting from index startIdx and returns the iterator to the element behind it. </p>

</div>
</div>
<a id="a487ed47ceaac55bd0e633673bf8b6a27" name="a487ed47ceaac55bd0e633673bf8b6a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487ed47ceaac55bd0e633673bf8b6a27">&#9670;&#160;</a></span>eraseAllOccurrencesIf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::eraseAllOccurrencesIf </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements inside this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a> for which predicate is true and adjusts its size. </p>
<p>Returns true if one or more predicate matches have been found and corresponding elements have been erased, false otherwise. </p>

</div>
</div>
<a id="aebfff322866872974a2d7249720e5ae0" name="aebfff322866872974a2d7249720e5ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebfff322866872974a2d7249720e5ae0">&#9670;&#160;</a></span>eraseAllOccurrencesOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::eraseAllOccurrencesOf </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all occurrences of value from this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a> and adjusts its size. </p>
<p>Returns true if one or more occurrences have been found and erased, false otherwise. </p>

</div>
</div>
<a id="a73c843ed894a40acde5dbe4a46813dad" name="a73c843ed894a40acde5dbe4a46813dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c843ed894a40acde5dbe4a46813dad">&#9670;&#160;</a></span>eraseFirstOccurrenceIf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::eraseFirstOccurrenceIf </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases the first occurrence for which predicate is true from this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a> and adjusts its size. </p>

</div>
</div>
<a id="ab4c52ecd0cfeceb21eaf37f8b6f36d01" name="ab4c52ecd0cfeceb21eaf37f8b6f36d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c52ecd0cfeceb21eaf37f8b6f36d01">&#9670;&#160;</a></span>eraseFirstOccurrenceOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::eraseFirstOccurrenceOf </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases the first occurrence of value from this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a> and adjusts its size. </p>

</div>
</div>
<a id="ad4a469facc53750163032618d7ec2751" name="ad4a469facc53750163032618d7ec2751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a469facc53750163032618d7ec2751">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the container with the given value. </p>

</div>
</div>
<a id="a13e42070dab5544e39faf3d372913c11" name="a13e42070dab5544e39faf3d372913c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e42070dab5544e39faf3d372913c11">&#9670;&#160;</a></span>fillLinspace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::fillLinspace </td>
          <td>(</td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeEnd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the vector with evenly spaced numbers between start and stop. </p>
<p>Properties:</p><ul>
<li>The length of the vector will not be changed and must be &gt; 0.</li>
<li>If start and stop are identical, the container will be filled with that value.</li>
<li>Ranges can have a negative increment, i.e., start &gt; stop is explicitly allowed.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>First value of the interval; always included. </td></tr>
    <tr><td class="paramname">stop</td><td>Last value of the interval; only included if includeEnd is true. </td></tr>
    <tr><td class="paramname">includeEnd</td><td>If this is true, both start and stop are included; otherwise only start is included. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b32192ab7691ff8e24fe85937df8cfc" name="a3b32192ab7691ff8e24fe85937df8cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b32192ab7691ff8e24fe85937df8cfc">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>valueToLookFor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element that equals valueToLookFor or <a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf" title="Returns an iterator to the first element behind the storage.">end()</a> if none was found. </p>

</div>
</div>
<a id="a457b883bdf44506a49faa497659aa0b4" name="a457b883bdf44506a49faa497659aa0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457b883bdf44506a49faa497659aa0b4">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>valueToLookFor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the first element that equals valueToLookFor or <a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf" title="Returns an iterator to the first element behind the storage.">end()</a> if none was found. </p>

</div>
</div>
<a id="a8a0a138a1344cc551cf44763435213e0" name="a8a0a138a1344cc551cf44763435213e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0a138a1344cc551cf44763435213e0">&#9670;&#160;</a></span>findIf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::findIf </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element in this vector for which predicate returns true or <a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf" title="Returns an iterator to the first element behind the storage.">end()</a> if none was found. </p>

</div>
</div>
<a id="ac30f1790e9e54a5e29bc28118a6bd136" name="ac30f1790e9e54a5e29bc28118a6bd136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30f1790e9e54a5e29bc28118a6bd136">&#9670;&#160;</a></span>findIf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::findIf </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the first element in this vector for which predicate returns true or <a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf" title="Returns an iterator to the first element behind the storage.">end()</a> if none was found. </p>

</div>
</div>
<a id="a9c04176763bb439535383f415e9a1a41" name="a9c04176763bb439535383f415e9a1a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c04176763bb439535383f415e9a1a41">&#9670;&#160;</a></span>findIfReverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::findIfReverse </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the last element in this vector for which predicate returns true or <a class="el" href="classvctr_1_1VctrBase.html#ac3f6fd77a0b41775cbbdddc212a1eb38" title="Returns a reverse iterator to the element before the first element in the storage.">rend()</a> if none was found. </p>

</div>
</div>
<a id="a91b0c83ff87a33d32f08669e39ace236" name="a91b0c83ff87a33d32f08669e39ace236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b0c83ff87a33d32f08669e39ace236">&#9670;&#160;</a></span>findIfReverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::findIfReverse </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the last element in this vector for which predicate returns true or <a class="el" href="classvctr_1_1VctrBase.html#ac3f6fd77a0b41775cbbdddc212a1eb38" title="Returns a reverse iterator to the element before the first element in the storage.">rend()</a> if none was found. </p>

</div>
</div>
<a id="a080fe9d9e226860b48acde1178bb3209" name="a080fe9d9e226860b48acde1178bb3209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080fe9d9e226860b48acde1178bb3209">&#9670;&#160;</a></span>findMaxElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::findMaxElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first greatest element. </p>

</div>
</div>
<a id="a029ddc0c88fbc4aac667bca7f6125348" name="a029ddc0c88fbc4aac667bca7f6125348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029ddc0c88fbc4aac667bca7f6125348">&#9670;&#160;</a></span>findMaxElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::findMaxElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first greatest element. </p>

</div>
</div>
<a id="a2261b01e1400927039586ef3b4be869b" name="a2261b01e1400927039586ef3b4be869b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2261b01e1400927039586ef3b4be869b">&#9670;&#160;</a></span>findMinElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::findMinElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first smallest element. </p>

</div>
</div>
<a id="ae24e1fbd352ce351643a5d410179bb8d" name="ae24e1fbd352ce351643a5d410179bb8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24e1fbd352ce351643a5d410179bb8d">&#9670;&#160;</a></span>findMinElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::findMinElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first smallest element. </p>

</div>
</div>
<a id="a13389760f277db65b2d08cc058e58e25" name="a13389760f277db65b2d08cc058e58e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13389760f277db65b2d08cc058e58e25">&#9670;&#160;</a></span>findReverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::findReverse </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>valueToLookFor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the last element in this vector that equals valueToLookFor or <a class="el" href="classvctr_1_1VctrBase.html#ac3f6fd77a0b41775cbbdddc212a1eb38" title="Returns a reverse iterator to the element before the first element in the storage.">rend()</a> if none was found. </p>

</div>
</div>
<a id="a684b197edd1baefcbb9db31bfd221faf" name="a684b197edd1baefcbb9db31bfd221faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684b197edd1baefcbb9db31bfd221faf">&#9670;&#160;</a></span>findReverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::findReverse </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>valueToLookFor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the last element in this vector that equals valueToLookFor or <a class="el" href="classvctr_1_1VctrBase.html#ac3f6fd77a0b41775cbbdddc212a1eb38" title="Returns a reverse iterator to the element before the first element in the storage.">rend()</a> if none was found. </p>

</div>
</div>
<a id="a9f8062350f8c34a092da9492372fb170" name="a9f8062350f8c34a092da9492372fb170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8062350f8c34a092da9492372fb170">&#9670;&#160;</a></span>firstValueGreaterThan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::optional&lt; value_type &gt; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::firstValueGreaterThan </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>valueToLookFor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a std::optional holding a copy of the first element value which is greater than valueToLookFor or std::nullopt if no such value is found. </p>
<p>This function requires that the elements are sorted. </p>

</div>
</div>
<a id="abaf31ce8bd7c61d08b1d0a0128d4a94e" name="abaf31ce8bd7c61d08b1d0a0128d4a94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf31ce8bd7c61d08b1d0a0128d4a94e">&#9670;&#160;</a></span>firstValueGreaterThanOrEqualTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::optional&lt; value_type &gt; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::firstValueGreaterThanOrEqualTo </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>valueToLookFor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a std::optional holding a copy of the first element value which is greater or equal to valueToLookFor or std::nullopt if no such value is found. </p>
<p>This function requires that the elements are sorted. </p>

</div>
</div>
<a id="a85f93b4ac09db43de3553fea3194b5fc" name="a85f93b4ac09db43de3553fea3194b5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f93b4ac09db43de3553fea3194b5fc">&#9670;&#160;</a></span>forEach() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; void(value_type &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function on each element. </p>
<p>The function returns void and might take the elements by reference to mutate them. </p>

</div>
</div>
<a id="a85f93b4ac09db43de3553fea3194b5fc" name="a85f93b4ac09db43de3553fea3194b5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f93b4ac09db43de3553fea3194b5fc">&#9670;&#160;</a></span>forEach() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; value_type(const value_type &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function on each element. </p>
<p>The function returns a value_type which is assigned as new value to the element. </p>

</div>
</div>
<a id="a85f93b4ac09db43de3553fea3194b5fc" name="a85f93b4ac09db43de3553fea3194b5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f93b4ac09db43de3553fea3194b5fc">&#9670;&#160;</a></span>forEach() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; void(value_type &amp;, size_t)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function on each element and passes the element index as second function argument. </p>
<p>The function returns void and might take the elements by reference to mutate them. </p>

</div>
</div>
<a id="a85f93b4ac09db43de3553fea3194b5fc" name="a85f93b4ac09db43de3553fea3194b5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f93b4ac09db43de3553fea3194b5fc">&#9670;&#160;</a></span>forEach() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; value_type(const value_type &amp;, size_t)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function on each element and passes the element index as second function argument. </p>
<p>The function returns a value_type which is assigned as new value to the element. </p>

</div>
</div>
<a id="a187a80a3e5380b3b61e666ce3f6d5424" name="a187a80a3e5380b3b61e666ce3f6d5424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187a80a3e5380b3b61e666ce3f6d5424">&#9670;&#160;</a></span>forEach() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; void(const value_type &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function on each element. </p>
<p>The function returns void and must not mutate the elements. </p>

</div>
</div>
<a id="a187a80a3e5380b3b61e666ce3f6d5424" name="a187a80a3e5380b3b61e666ce3f6d5424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187a80a3e5380b3b61e666ce3f6d5424">&#9670;&#160;</a></span>forEach() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; void(const value_type &amp;, size_t)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function on each element and passes the element index as second function argument. </p>
<p>The function returns void and must not mutate the elements. </p>

</div>
</div>
<a id="a62d70bbcdff2fd01c0f555d92467063a" name="a62d70bbcdff2fd01c0f555d92467063a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d70bbcdff2fd01c0f555d92467063a">&#9670;&#160;</a></span>forEach() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args, is::functionWithSignatureOrImplicitlyConvertible&lt; void(value_type &amp;, Args &amp;&amp;...)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fnArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function on each element and forwards fnArgs to the function after the value. </p>
<p>The function returns void and might take the elements by reference to mutate them. </p>

</div>
</div>
<a id="a62d70bbcdff2fd01c0f555d92467063a" name="a62d70bbcdff2fd01c0f555d92467063a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d70bbcdff2fd01c0f555d92467063a">&#9670;&#160;</a></span>forEach() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args, is::functionWithSignatureOrImplicitlyConvertible&lt; value_type(const value_type &amp;, Args &amp;&amp;...)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fnArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function on each element and forwards fnArgs to the function after the value. </p>
<p>The function returns a value_type which is assigned as new value to the element. </p>

</div>
</div>
<a id="ac3a72bd1e6f648eaa2c9780bc560c664" name="ac3a72bd1e6f648eaa2c9780bc560c664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a72bd1e6f648eaa2c9780bc560c664">&#9670;&#160;</a></span>forEach() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args, is::functionWithSignatureOrImplicitlyConvertible&lt; void(const value_type &amp;, Args &amp;&amp;...)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fnArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function on each element and forwards fnArgs to the function after the value. </p>
<p>The function returns void and must not mutate the elements. </p>

</div>
</div>
<a id="aa0b83cec6a9e6b0a5801d45331fefdf4" name="aa0b83cec6a9e6b0a5801d45331fefdf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b83cec6a9e6b0a5801d45331fefdf4">&#9670;&#160;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto &amp;&amp; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element. </p>

</div>
</div>
<a id="a9a5e8a34c7458574ddda43da9cfba433" name="a9a5e8a34c7458574ddda43da9cfba433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5e8a34c7458574ddda43da9cfba433">&#9670;&#160;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto &amp;&amp; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element. </p>

</div>
</div>
<a id="aac4956e9f906df5c7296a39bf059d54a" name="aac4956e9f906df5c7296a39bf059d54a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac4956e9f906df5c7296a39bf059d54a">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a> &lt; ElementType &gt; <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>. </p>
<p>This is a standard interface function forwarded to std::vector::get_allocator(). </p>

</div>
</div>
<a id="a0dbf4ef57c72393831bc95c2dbddd396" name="a0dbf4ef57c72393831bc95c2dbddd396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dbf4ef57c72393831bc95c2dbddd396">&#9670;&#160;</a></span>getExtent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static consteval size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::getExtent </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>amountToShrink</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the extent of this instance, optionally shrank by a certain amount. </p>
<p>In case the instance specifies a dynamic extent, the return value will always be std::dynamic_extent, no matter if we specified an amount to shrink. In case the instance specifies a static extent, the return value will be extent - amountToShrink. </p>

</div>
</div>
<a id="a82baf69e22b816a5b14994c89889a138" name="a82baf69e22b816a5b14994c89889a138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82baf69e22b816a5b14994c89889a138">&#9670;&#160;</a></span>getNeon()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvctr_1_1NeonRegister.html">NeonRegister</a>&lt; std::remove_const_t&lt; ElementType &gt; &gt; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::getNeon </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates a certain expression in place on this vector, e.g. </p>
<p>it assigns the expression result back to the vector. </p>

</div>
</div>
<a id="af232e22612aa17d3fc8eaeee4fec245a" name="af232e22612aa17d3fc8eaeee4fec245a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af232e22612aa17d3fc8eaeee4fec245a">&#9670;&#160;</a></span>getUnderlyingVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StdVectorType &amp; <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::getUnderlyingVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying storage. </p>
<p>The returned type is std::vector, possibly with a custom allocator type. </p>

</div>
</div>
<a id="ac046b6e082cc01f8523e113cf1c8998f" name="ac046b6e082cc01f8523e113cf1c8998f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac046b6e082cc01f8523e113cf1c8998f">&#9670;&#160;</a></span>getUnderlyingVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const StdVectorType &amp; <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::getUnderlyingVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying storage. </p>
<p>The returned type is std::vector, possibly with a custom allocator type. </p>

</div>
</div>
<a id="aefc631d848a921dbc4222a5890751067" name="aefc631d848a921dbc4222a5890751067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc631d848a921dbc4222a5890751067">&#9670;&#160;</a></span>indexIf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::optional&lt; size_t &gt; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::indexIf </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first element that satisfies the predicate or std::nullopt if none is found. </p>

</div>
</div>
<a id="a13755f0b72bc98a60663e7e90be620cc" name="a13755f0b72bc98a60663e7e90be620cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13755f0b72bc98a60663e7e90be620cc">&#9670;&#160;</a></span>indexIfReverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::optional&lt; size_t &gt; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::indexIfReverse </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the last element that satisfies the predicate or std::nullopt if none is found. </p>

</div>
</div>
<a id="a88aa485f2931bf79d075b06d132c6df7" name="a88aa485f2931bf79d075b06d132c6df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88aa485f2931bf79d075b06d132c6df7">&#9670;&#160;</a></span>indexOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::optional&lt; size_t &gt; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::indexOf </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first element that compares true to value or std::nullopt if none is found. </p>

</div>
</div>
<a id="abc8f6bb18b8c5fc752c3a3c2440bf589" name="abc8f6bb18b8c5fc752c3a3c2440bf589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8f6bb18b8c5fc752c3a3c2440bf589">&#9670;&#160;</a></span>indexOfMaxElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::indexOfMaxElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first greatest element (aka argMax). </p>

</div>
</div>
<a id="a575932e270e9eb0bb8bf3550cf47acf0" name="a575932e270e9eb0bb8bf3550cf47acf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575932e270e9eb0bb8bf3550cf47acf0">&#9670;&#160;</a></span>indexOfMinElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::indexOfMinElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first smallest element (aka argMin). </p>

</div>
</div>
<a id="a4d7733e55415e624cf6a97fab0cef693" name="a4d7733e55415e624cf6a97fab0cef693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7733e55415e624cf6a97fab0cef693">&#9670;&#160;</a></span>indexOfReverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::optional&lt; size_t &gt; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::indexOfReverse </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the last element that compares true to value or std::nullopt if none is found. </p>

</div>
</div>
<a id="a5f4ef71d511b27c5cd679b593a27d802" name="a5f4ef71d511b27c5cd679b593a27d802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4ef71d511b27c5cd679b593a27d802">&#9670;&#160;</a></span>init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::init </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes this vector to newSize and fills it with the given value. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classvctr_1_1Vector.html#ad4207603e009e34c913e8d2ac8dc5998" title="Changes the size of this Vector, potentially allocating memory.">resize</a>, <a class="el" href="classvctr_1_1VctrBase.html#ad4a469facc53750163032618d7ec2751" title="Fills the container with the given value.">fill</a>. </dd></dl>

</div>
</div>
<a id="a06cc75e1d308167e8a0f471f905432ad" name="a06cc75e1d308167e8a0f471f905432ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06cc75e1d308167e8a0f471f905432ad">&#9670;&#160;</a></span>init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::init </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>initializerFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes this vector to newSize and fills it via the given initializerFunction. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classvctr_1_1Vector.html#ad4207603e009e34c913e8d2ac8dc5998" title="Changes the size of this Vector, potentially allocating memory.">resize</a>, <a class="el" href="classvctr_1_1VctrBase.html#ad4a469facc53750163032618d7ec2751" title="Fills the container with the given value.">fill</a>. </dd></dl>

</div>
</div>
<a id="a4ab397edff06dbf1582240f63f97720b" name="a4ab397edff06dbf1582240f63f97720b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab397edff06dbf1582240f63f97720b">&#9670;&#160;</a></span>insert() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">ConstIterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ElementType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts value before the element referenced by pos and returns an iterator to the inserted value. </p>
<p>pos must refer to an element in this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>.</p>
<p>This is a standard interface function forwarded to std::vector::insert(). </p>

</div>
</div>
<a id="a325003ee01e17102300452a30c1116b9" name="a325003ee01e17102300452a30c1116b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325003ee01e17102300452a30c1116b9">&#9670;&#160;</a></span>insert() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">ConstIterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts value before the element referenced by pos and returns an iterator to the inserted value. </p>
<p>pos must refer to an element in this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>.</p>
<p>This is a standard interface function forwarded to std::vector::insert(). </p>

</div>
</div>
<a id="ad9502e1e348cc5d136856d6d37811e2c" name="ad9502e1e348cc5d136856d6d37811e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9502e1e348cc5d136856d6d37811e2c">&#9670;&#160;</a></span>insert() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">ConstIterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a range of values before the element referenced by pos and returns an iterator to the inserted values. </p>
<p>pos must refer to an element in this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>, first and last must denote the begin and end of the range to be inserted. The inserted range must not be part of this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>.</p>
<p>This is a standard interface function forwarded to std::vector::insert(). </p>

</div>
</div>
<a id="a05e76533439e1ec1bca764e5c0ce0953" name="a05e76533439e1ec1bca764e5c0ce0953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e76533439e1ec1bca764e5c0ce0953">&#9670;&#160;</a></span>insert() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">ConstIterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numCopies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ElementType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts numCopies copies of value before the element referenced by pos and returns an iterator to the inserted values. </p>
<p>pos must refer to an element in this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>.</p>
<p>This is a standard interface function forwarded to std::vector::insert(). </p>

</div>
</div>
<a id="a2f9b496a98a7cb851e433190342140f3" name="a2f9b496a98a7cb851e433190342140f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9b496a98a7cb851e433190342140f3">&#9670;&#160;</a></span>insert() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">ConstIterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; ElementType &gt;&#160;</td>
          <td class="paramname"><em>initList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a list of values before the element referenced by pos and returns an iterator to the first inserted value. </p>
<p>pos must refer to an element in this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>.</p>
<p>This is a standard interface function forwarded to std::vector::insert(). </p>

</div>
</div>
<a id="a7f7944fb6f9a3ad4d91cf742f3e624fb" name="a7f7944fb6f9a3ad4d91cf742f3e624fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7944fb6f9a3ad4d91cf742f3e624fb">&#9670;&#160;</a></span>insert() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">ConstIterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VctrToInsert &amp;&amp;&#160;</td>
          <td class="paramname"><em>vctrToInsert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>moveValuesFromSrc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a VCTR container before the element referenced by pos and returns an iterator to the first inserted value. </p>
<p>pos must refer to an element in this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>. If moveValuesFromSrc is true, the function attempts that it's safe to move the values out of vtrToInsert even if we pass it by reference or as a <a class="el" href="classvctr_1_1Span.html" title="The view type.">vctr::Span</a>. This will invalidate that source values. </p>

</div>
</div>
<a id="a0deef69f8b0773766929cd1c37193876" name="a0deef69f8b0773766929cd1c37193876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0deef69f8b0773766929cd1c37193876">&#9670;&#160;</a></span>insert() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ElementType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts value at index idx and returns an iterator to the inserted value. </p>

</div>
</div>
<a id="a9ef67c35c3ac6de7489b063a6e643b1d" name="a9ef67c35c3ac6de7489b063a6e643b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef67c35c3ac6de7489b063a6e643b1d">&#9670;&#160;</a></span>insert() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts value at index idx and returns an iterator to the inserted value. </p>

</div>
</div>
<a id="a6063deda9064e94fd866eb97e9277c15" name="a6063deda9064e94fd866eb97e9277c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6063deda9064e94fd866eb97e9277c15">&#9670;&#160;</a></span>insert() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a range of values at index idx and returns an iterator to the inserted values. </p>
<p>First and last must denote the begin and end of the range to be inserted. The inserted range must not be part of this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>. </p>

</div>
</div>
<a id="a667116b07d036368a6ad7e52770e95f6" name="a667116b07d036368a6ad7e52770e95f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667116b07d036368a6ad7e52770e95f6">&#9670;&#160;</a></span>insert() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numCopies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ElementType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts numCopies copies of value at index idx and returns an iterator to the inserted values. </p>

</div>
</div>
<a id="a4e7d385bccf2634d09ab21c9e2ff234b" name="a4e7d385bccf2634d09ab21c9e2ff234b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7d385bccf2634d09ab21c9e2ff234b">&#9670;&#160;</a></span>insert() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; ElementType &gt;&#160;</td>
          <td class="paramname"><em>initList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a list of values at index idx and returns an iterator to the first inserted value. </p>

</div>
</div>
<a id="ae2087b728f19b6ceea4bcc41d432c2f5" name="ae2087b728f19b6ceea4bcc41d432c2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2087b728f19b6ceea4bcc41d432c2f5">&#9670;&#160;</a></span>insert() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VctrToInsert &amp;&amp;&#160;</td>
          <td class="paramname"><em>vctrToInsert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>moveValuesFromSrc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a VCTR container at index idx and returns an iterator to the first inserted value. </p>
<p>If moveValuesFromSrc is true, the function attempts that it's safe to move the values out of vtrToInsert even if we pass it by reference or as a <a class="el" href="classvctr_1_1Span.html" title="The view type.">vctr::Span</a>. This will invalidate that source values. </p>

</div>
</div>
<a id="ac30ee026df44d26087f2b2e5242daabd" name="ac30ee026df44d26087f2b2e5242daabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30ee026df44d26087f2b2e5242daabd">&#9670;&#160;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ElementType <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum value of all elements. </p>

</div>
</div>
<a id="a549badde5c63e189373f2546bc30f964" name="a549badde5c63e189373f2546bc30f964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549badde5c63e189373f2546bc30f964">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold. </p>

</div>
</div>
<a id="a5928bed9ea669ad2500cdb1dd9346db7" name="a5928bed9ea669ad2500cdb1dd9346db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5928bed9ea669ad2500cdb1dd9346db7">&#9670;&#160;</a></span>maxAbs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ElementType <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::maxAbs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum absolute value of all elements. </p>

</div>
</div>
<a id="ad82b22bb7cf07b3d7441240fd4be96e8" name="ad82b22bb7cf07b3d7441240fd4be96e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82b22bb7cf07b3d7441240fd4be96e8">&#9670;&#160;</a></span>mean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ElementType <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mean value across all elements. </p>

</div>
</div>
<a id="ae8380fd770f1c73e257bb644c9745af0" name="ae8380fd770f1c73e257bb644c9745af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8380fd770f1c73e257bb644c9745af0">&#9670;&#160;</a></span>meanSquare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ElementType <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::meanSquare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mean value across all squared elements. </p>

</div>
</div>
<a id="a3809aad3dbd44783fb9d8b4dbbd97207" name="a3809aad3dbd44783fb9d8b4dbbd97207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3809aad3dbd44783fb9d8b4dbbd97207">&#9670;&#160;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ElementType <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimal value of all elements. </p>

</div>
</div>
<a id="ac2e4d6969b97cb396af2d0a1f31b8b1d" name="ac2e4d6969b97cb396af2d0a1f31b8b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e4d6969b97cb396af2d0a1f31b8b1d">&#9670;&#160;</a></span>minAbs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ElementType <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::minAbs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimal absolute value of all elements. </p>

</div>
</div>
<a id="af7a96f4ea593adeef523923771615c4c" name="af7a96f4ea593adeef523923771615c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a96f4ea593adeef523923771615c4c">&#9670;&#160;</a></span>moveUnderlyingVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StdVectorType &amp;&amp; <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::moveUnderlyingVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the underlying storage out of this wrapper class. </p>
<p>The returned type is std::vector, possibly with a custom allocator type. </p>

</div>
</div>
<a id="acefc323d674a4ed311f76affd72d0df6" name="acefc323d674a4ed311f76affd72d0df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefc323d674a4ed311f76affd72d0df6">&#9670;&#160;</a></span>operator const StdVectorType &amp;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::operator const StdVectorType &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator shortcut to getUnderlyingVector. </p>

</div>
</div>
<a id="a76c02120533daf85c9f05d32bb042533" name="a76c02120533daf85c9f05d32bb042533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c02120533daf85c9f05d32bb042533">&#9670;&#160;</a></span>operator std::vector&lt; ElementType, OtherAllocator &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::operator std::vector&lt; ElementType, OtherAllocator &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator that allows us to assign this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a> to a std::vector with different allocator type. </p>
<p>Note that values will be copied here and that the destination <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a> might allocate memory. </p>

</div>
</div>
<a id="a48a20e8c2566d1a37fbf5573263ef0cd" name="a48a20e8c2566d1a37fbf5573263ef0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a20e8c2566d1a37fbf5573263ef0cd">&#9670;&#160;</a></span>operator StdVectorType &amp;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::operator StdVectorType &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator shortcut to getUnderlyingVector. </p>

</div>
</div>
<a id="af9420adec66c33c58a40ecad62c94fdf" name="af9420adec66c33c58a40ecad62c94fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9420adec66c33c58a40ecad62c94fdf">&#9670;&#160;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::anyVctrOrExpression V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies this by a vector or expression in place. </p>

</div>
</div>
<a id="a7d393bcae1044593f341499d7e3ff784" name="a7d393bcae1044593f341499d7e3ff784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d393bcae1044593f341499d7e3ff784">&#9670;&#160;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies this by a constant in place. </p>

</div>
</div>
<a id="a34e6342e4327a648e9b7cf5a2ab46b3d" name="a34e6342e4327a648e9b7cf5a2ab46b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e6342e4327a648e9b7cf5a2ab46b3d">&#9670;&#160;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::anyVctrOrExpression V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a vector or expression to this in place. </p>
<p>In the special case where a multiplication expression is assigned for which none of the operands are expressions themselves, this will try to use accelerated multiply accumulate operations to evaluate the expression.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classvctr_1_1Array.html">vctr::Array&lt;float, 10&gt;</a> a, b, c;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code tries to use an accelerated multiply accumulate operation as it can access the values of a and b right away</span></div>
<div class="line">c += a * b;</div>
<div class="line">c += a * 42.0f;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cannot directly evaluate the accelerated operation as vctr::square (b) would have to be evaluated and stored to</span></div>
<div class="line"><span class="comment">// some temporary memory location first.</span></div>
<div class="line">c += a * <a class="code hl_variable" href="group__Expressions.html#gace331be21cfd6aa9705f5bc0e283e3f9">vctr::square</a> (b);</div>
<div class="ttc" id="aclassvctr_1_1Array_html"><div class="ttname"><a href="classvctr_1_1Array.html">vctr::Array</a></div><div class="ttdoc">The stack-based container type.</div><div class="ttdef"><b>Definition:</b> Array.h:53</div></div>
<div class="ttc" id="agroup__Expressions_html_gace331be21cfd6aa9705f5bc0e283e3f9"><div class="ttname"><a href="group__Expressions.html#gace331be21cfd6aa9705f5bc0e283e3f9">vctr::square</a></div><div class="ttdeci">constexpr ExpressionChainBuilder&lt; expressions::Square &gt; square</div><div class="ttdoc">Squares the source values.</div><div class="ttdef"><b>Definition:</b> Square.h:94</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8a24a9704cd970e3f6430b2e1cd495c0" name="a8a24a9704cd970e3f6430b2e1cd495c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a24a9704cd970e3f6430b2e1cd495c0">&#9670;&#160;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a constant to this in place. </p>

</div>
</div>
<a id="a2f082ed08028aef23fddf52425fb254e" name="a2f082ed08028aef23fddf52425fb254e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f082ed08028aef23fddf52425fb254e">&#9670;&#160;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::anyVctrOrExpression V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts a vector or expression from this in place. </p>

</div>
</div>
<a id="a5d4040fe16ec241401831c8f70781bf1" name="a5d4040fe16ec241401831c8f70781bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4040fe16ec241401831c8f70781bf1">&#9670;&#160;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts a constant from this in place. </p>

</div>
</div>
<a id="a441226b45536b133601da22b47a9ccad" name="a441226b45536b133601da22b47a9ccad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441226b45536b133601da22b47a9ccad">&#9670;&#160;</a></span>operator/=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::anyVctrOrExpression V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides this by a vector or expression in place. </p>

</div>
</div>
<a id="a44993d0d98bdad4d42f7a8522d348574" name="a44993d0d98bdad4d42f7a8522d348574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44993d0d98bdad4d42f7a8522d348574">&#9670;&#160;</a></span>operator/=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides this by a constant in place. </p>

</div>
</div>
<a id="aa689a52afa0d76a308cf176083f731c6" name="aa689a52afa0d76a308cf176083f731c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa689a52afa0d76a308cf176083f731c6">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto &amp; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to element i. </p>
<p>Asserts in debug builds if i &gt;= <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> </p>

</div>
</div>
<a id="a0d921dc0ff2a400920940dfee087ac8d" name="a0d921dc0ff2a400920940dfee087ac8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d921dc0ff2a400920940dfee087ac8d">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto &amp; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to element i. </p>
<p>Asserts in debug builds if i &gt;= <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> </p>

</div>
</div>
<a id="a8932b2885c55f96e4f00e4d9def65e09" name="a8932b2885c55f96e4f00e4d9def65e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8932b2885c55f96e4f00e4d9def65e09">&#9670;&#160;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ElementType <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last element in the vector, effectively reducing the container size by one. </p>
<p>In addition to std::vector::pop_back, this implementation also return the popped element. Calling pop_back on an empty vector causes undefined behaviour. </p>

</div>
</div>
<a id="ac934d9b8ecf1bf26c9b56c27227bcd67" name="ac934d9b8ecf1bf26c9b56c27227bcd67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac934d9b8ecf1bf26c9b56c27227bcd67">&#9670;&#160;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ElementType &amp; <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const ElementType &amp;&#160;</td>
          <td class="paramname"><em>newElement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an element to the end of the <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>. </p>
<p>This is a standard interface function forwarded to std::vector::push_back() but it adds a return value.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the just added element. </dd></dl>

</div>
</div>
<a id="aabb17ac821b61441fa7fe5627a020abd" name="aabb17ac821b61441fa7fe5627a020abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb17ac821b61441fa7fe5627a020abd">&#9670;&#160;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ElementType &amp; <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">ElementType &amp;&amp;&#160;</td>
          <td class="paramname"><em>newElement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an element to the end of the <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>. </p>
<p>This is a standard interface function forwarded to std::vector::push_back() but it adds a return value.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the just added element. </dd></dl>

</div>
</div>
<a id="af982e33f6fa36af4add9f0373bde98a8" name="af982e33f6fa36af4add9f0373bde98a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af982e33f6fa36af4add9f0373bde98a8">&#9670;&#160;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the last element in the storage. </p>

</div>
</div>
<a id="af5dad4052f5d8720bdfb2414ac9b6b75" name="af5dad4052f5d8720bdfb2414ac9b6b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dad4052f5d8720bdfb2414ac9b6b75">&#9670;&#160;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the last element in the storage. </p>

</div>
</div>
<a id="ac3f6fd77a0b41775cbbdddc212a1eb38" name="ac3f6fd77a0b41775cbbdddc212a1eb38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f6fd77a0b41775cbbdddc212a1eb38">&#9670;&#160;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element before the first element in the storage. </p>

</div>
</div>
<a id="aa539547c92850b3e14f2067afd070c4b" name="aa539547c92850b3e14f2067afd070c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa539547c92850b3e14f2067afd070c4b">&#9670;&#160;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the element before the first element in the storage. </p>

</div>
</div>
<a id="ae864434d9d6595ecbdd38a3c9efeeb08" name="ae864434d9d6595ecbdd38a3c9efeeb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae864434d9d6595ecbdd38a3c9efeeb08">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-allocates memory for the given number of elements. </p>
<p>This is a standard interface function forwarded to std::vector::reserve(). </p>

</div>
</div>
<a id="ad4207603e009e34c913e8d2ac8dc5998" name="ad4207603e009e34c913e8d2ac8dc5998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4207603e009e34c913e8d2ac8dc5998">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the size of this <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>, potentially allocating memory. </p>
<p>This is a standard interface function forwarded to std::vector::resize(). </p>

</div>
</div>
<a id="a9c46dbf4c7e9584c2d4bc2e627aa3ee6" name="a9c46dbf4c7e9584c2d4bc2e627aa3ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c46dbf4c7e9584c2d4bc2e627aa3ee6">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the order of all elements. </p>

</div>
</div>
<a id="a9b9ca4b0cc5d3894ff875bcc0a1fd431" name="a9b9ca4b0cc5d3894ff875bcc0a1fd431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9ca4b0cc5d3894ff875bcc0a1fd431">&#9670;&#160;</a></span>rms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ElementType <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::rms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the square root of the mean value across all squared elements. </p>

</div>
</div>
<a id="a17c6ce671353756da7465f3def164f10" name="a17c6ce671353756da7465f3def164f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c6ce671353756da7465f3def164f10">&#9670;&#160;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::rotate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newFirstElementIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotates the elements so that the element with the index newFirstElementIdx becomes the first element and the element with the index newFirstElementIdx - 1 becomes the last element. </p>

</div>
</div>
<a id="af4204c2b21ab30ea9a78e1c30f76111b" name="af4204c2b21ab30ea9a78e1c30f76111b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4204c2b21ab30ea9a78e1c30f76111b">&#9670;&#160;</a></span>shiftLeft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::shiftLeft </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearFreeSpaceAfterShiftedRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts all elements to the left by n. </p>
<p>In other words: It shifts the elements so that the element with the index n becomes the first element. If clearFreeSpaceAfterShiftedRegion is true, it clears all elements behind the shifted region by setting the memory to 0, otherwise it leaves that region as it was. For maximum efficiency, this works on a raw memory basis, so the elements have to be trivially copyable. </p>

</div>
</div>
<a id="a00b7cafbc190e73f31fbb191de2354e0" name="a00b7cafbc190e73f31fbb191de2354e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b7cafbc190e73f31fbb191de2354e0">&#9670;&#160;</a></span>shiftRight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::shiftRight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearFreeSpaceBeforeShiftedRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts all elements to the right by n. </p>
<p>In other words: It shifts the elements so that the previous first element now is the element with the index n. If clearFreeSpaceBeforeShiftedRegion is true, it clears all elements before the shifted region by setting the memory to 0, otherwise it leaves that region as it was. For maximum efficiency, this works on a raw memory basis, so the elements have to be trivially copyable. </p>

</div>
</div>
<a id="af33309cf31d84a89abd7cccb88ab13b2" name="af33309cf31d84a89abd7cccb88ab13b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33309cf31d84a89abd7cccb88ab13b2">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the allocated memory to the actual number of elements. </p>
<p>This is a standard interface function forwarded to std::vector::shrink_to_fit(). </p>

</div>
</div>
<a id="a0ec564aacdb2c8a90604e4fa142404ed" name="a0ec564aacdb2c8a90604e4fa142404ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec564aacdb2c8a90604e4fa142404ed">&#9670;&#160;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements. </p>
<p>This overload is a non-static function, used in case the extent is dynamic. </p>

</div>
</div>
<a id="ae83870ea4a869114785266ee2fab1598" name="ae83870ea4a869114785266ee2fab1598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83870ea4a869114785266ee2fab1598">&#9670;&#160;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements. </p>
<p>This overload is a static function, used in case the extent is static. </p>

</div>
</div>
<a id="a681a9fa9e731497b3cdfc9752c091c9b" name="a681a9fa9e731497b3cdfc9752c091c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681a9fa9e731497b3cdfc9752c091c9b">&#9670;&#160;</a></span>sizeInBytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::sizeInBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container size in bytes. </p>
<p>This overload is a non-static function, used in case the extent is dynamic. </p>

</div>
</div>
<a id="a4612236989c7950e0d69917a007f6b79" name="a4612236989c7950e0d69917a007f6b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4612236989c7950e0d69917a007f6b79">&#9670;&#160;</a></span>sizeInBytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::sizeInBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container size in bytes. </p>
<p>This overload is a static function, used in case the extent is static. </p>

</div>
</div>
<a id="a60ceab7317b693f9f763be9e74fc87d6" name="a60ceab7317b693f9f763be9e74fc87d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ceab7317b693f9f763be9e74fc87d6">&#9670;&#160;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts all elements in an ascending order using operator &lt;=&gt;. </p>

</div>
</div>
<a id="a09242aefc7ce2ef77ed27b6a0551552b" name="a09242aefc7ce2ef77ed27b6a0551552b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09242aefc7ce2ef77ed27b6a0551552b">&#9670;&#160;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const value_type &amp;, const value_type &amp;)&gt; ComparatorFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">ComparatorFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts all elements in this vector according to the compare function. </p>
<p>The compare function should receive true if the first argument is less than the second argument. </p>

</div>
</div>
<a id="a29d9c9c2d8cd0874aecc6f6ee17dfa66" name="a29d9c9c2d8cd0874aecc6f6ee17dfa66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d9c9c2d8cd0874aecc6f6ee17dfa66">&#9670;&#160;</a></span>subSpan() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;size_t startIdx&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::subSpan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> - startIdx. </p>
<p>This overload with a compile time static index will return a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> with a static extent in case this instance also has a static extent. </p>

</div>
</div>
<a id="a828d59afc6a87d40566840ffde8a6a50" name="a828d59afc6a87d40566840ffde8a6a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828d59afc6a87d40566840ffde8a6a50">&#9670;&#160;</a></span>subSpan() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;size_t startIdx, size_t numElements&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::subSpan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of numElements. </p>
<p>This overload with a compile time static length will always return a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> with a static extent. </p>

</div>
</div>
<a id="a8a1180d252ae45809e7150458345c93e" name="a8a1180d252ae45809e7150458345c93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1180d252ae45809e7150458345c93e">&#9670;&#160;</a></span>subSpan() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;size_t startIdx&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::subSpan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> - startIdx. </p>
<p>This overload with a compile time static index will return a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> with a static extent in case this instance also has a static extent. </p>

</div>
</div>
<a id="a214960993f1d15ed248de6382ae16b0e" name="a214960993f1d15ed248de6382ae16b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214960993f1d15ed248de6382ae16b0e">&#9670;&#160;</a></span>subSpan() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;size_t startIdx, size_t numElements&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::subSpan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of numElements. </p>
<p>This overload with a compile time static length will always return a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> with a static extent. </p>

</div>
</div>
<a id="a8e737d53237f32af2685faa02ae26d55" name="a8e737d53237f32af2685faa02ae26d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e737d53237f32af2685faa02ae26d55">&#9670;&#160;</a></span>subSpan() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::subSpan </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> - startIdx. </p>
<p>This overload with a runtime defined index will always return a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> with a dynamic extent. </p>

</div>
</div>
<a id="a2bc30017f36afa555e69770aadbb5fb2" name="a2bc30017f36afa555e69770aadbb5fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc30017f36afa555e69770aadbb5fb2">&#9670;&#160;</a></span>subSpan() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::subSpan </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> - startIdx. </p>
<p>This overload with a runtime defined index will always return a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> with a dynamic extent. </p>

</div>
</div>
<a id="a5ccea594565f121e340eb85db5ff972f" name="a5ccea594565f121e340eb85db5ff972f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ccea594565f121e340eb85db5ff972f">&#9670;&#160;</a></span>subSpan() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::subSpan </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of numElements. </p>
<p>This overload with a runtime defined length will always return a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> with a dynamic extent. </p>

</div>
</div>
<a id="a4ebddf025d6d6fb9bc5deb44b4c9ca3c" name="a4ebddf025d6d6fb9bc5deb44b4c9ca3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ebddf025d6d6fb9bc5deb44b4c9ca3c">&#9670;&#160;</a></span>subSpan() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::subSpan </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of numElements. </p>
<p>This overload with a runtime defined length will always return a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> with a dynamic extent. </p>

</div>
</div>
<a id="add5f3def86f5ab26a70456c779a91d9d" name="add5f3def86f5ab26a70456c779a91d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5f3def86f5ab26a70456c779a91d9d">&#9670;&#160;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ElementType <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sum of all elements. </p>

</div>
</div>
<a id="a9efdb84965206c223c69acb183ce74bd" name="a9efdb84965206c223c69acb183ce74bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efdb84965206c223c69acb183ce74bd">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1Vector.html">vctr::Vector</a>&lt; ElementType, <a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a>  &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvctr_1_1Vector.html">Vector</a>&lt; std::unique_ptr&lt; OwnedElementType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the underlying memory with the other <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>. </p>
<p>This is a standard interface function forwarded to std::vector::swap(). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/vctr/Containers/<a class="el" href="Vector_8h_source.html">Vector.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacevctr.html">vctr</a></li><li class="navelem"><a class="el" href="classvctr_1_1OwnedVector.html">OwnedVector</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
