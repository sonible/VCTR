<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VCTR: vctr::Array&lt; ElementType, extent, storageExtent &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="sonible_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">VCTR
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classvctr_1_1Array.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classvctr_1_1Array-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">vctr::Array&lt; ElementType, extent, storageExtent &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__Core.html">Core</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>The stack-based container type.  
 <a href="classvctr_1_1Array.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for vctr::Array&lt; ElementType, extent, storageExtent &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvctr_1_1Array.png" usemap="#vctr::Array_3C_20ElementType_2C_20extent_2C_20storageExtent_20_3E_map" alt=""/>
  <map id="vctr::Array_3C_20ElementType_2C_20extent_2C_20storageExtent_20_3E_map" name="vctr::Array_3C_20ElementType_2C_20extent_2C_20storageExtent_20_3E_map">
<area href="classvctr_1_1VctrBase.html" title="The base class to all one dimensional containers and views in the VCTR project." alt="vctr::VctrBase&lt; ElementType, StorageType, extent, StorageInfoType &gt;" shape="rect" coords="349,56,1037,80"/>
<area href="structvctr_1_1Config.html" alt="vctr::Config" shape="rect" coords="0,0,688,24"/>
<area href="structvctr_1_1StorageInfo.html" title="A helper class to describe some properties regarding the storage class wrapped in a VctrBase instance..." alt="vctr::StorageInfo&lt; StorageType &gt;" shape="rect" coords="698,0,1386,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3dd3c7b85ad05f52ed558e281b7ea4a6"><td class="memItemLeft" align="right" valign="top"><a id="a3dd3c7b85ad05f52ed558e281b7ea4a6" name="a3dd3c7b85ad05f52ed558e281b7ea4a6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = typename Vctr::value_type</td></tr>
<tr class="separator:a3dd3c7b85ad05f52ed558e281b7ea4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a88ddfa6f9624ca651326577d098b56b6"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Array.html#a88ddfa6f9624ca651326577d098b56b6">Array</a> ()</td></tr>
<tr class="memdesc:a88ddfa6f9624ca651326577d098b56b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an uninitialised <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a>.  <br /></td></tr>
<tr class="separator:a88ddfa6f9624ca651326577d098b56b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c3591456164d1c5519782158d5c410"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Array.html#a00c3591456164d1c5519782158d5c410">Array</a> (ElementType initialValue)</td></tr>
<tr class="memdesc:a00c3591456164d1c5519782158d5c410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> with all elements initialised to initialValue.  <br /></td></tr>
<tr class="separator:a00c3591456164d1c5519782158d5c410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c8292d5f832e80ddb0b085b308ef30"><td class="memTemplParams" colspan="2">template&lt;std::convertible_to&lt; ElementType &gt; T&gt; <br />
requires (extent == 1)</td></tr>
<tr class="memitem:a16c8292d5f832e80ddb0b085b308ef30"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1Array.html#a16c8292d5f832e80ddb0b085b308ef30">Array</a> (T &amp;&amp;initialValue)</td></tr>
<tr class="memdesc:a16c8292d5f832e80ddb0b085b308ef30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> with extent 1 from an initial value.  <br /></td></tr>
<tr class="separator:a16c8292d5f832e80ddb0b085b308ef30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219bef59c3f29f34b8635ea21009448e"><td class="memTemplParams" colspan="2">template&lt;is::suitableInitializerForElementType&lt; ElementType &gt;... T&gt; <br />
requires (sizeof...(T) &gt; 1)</td></tr>
<tr class="memitem:a219bef59c3f29f34b8635ea21009448e"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1Array.html#a219bef59c3f29f34b8635ea21009448e">Array</a> (T &amp;&amp;... initialValues)</td></tr>
<tr class="memdesc:a219bef59c3f29f34b8635ea21009448e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> from a list of at least two initial values.  <br /></td></tr>
<tr class="separator:a219bef59c3f29f34b8635ea21009448e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12663c821da364018f0601094452e7ab"><td class="memTemplParams" colspan="2">template&lt;class OtherElementType , size_t otherSize&gt; </td></tr>
<tr class="memitem:a12663c821da364018f0601094452e7ab"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1Array.html#a12663c821da364018f0601094452e7ab">Array</a> (std::array&lt; OtherElementType, otherSize &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a12663c821da364018f0601094452e7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> by moving a std::array into it.  <br /></td></tr>
<tr class="separator:a12663c821da364018f0601094452e7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eaf7f17f4ec7b84e68b69c47f17b5d7"><td class="memTemplParams" colspan="2">template&lt;is::triviallyCopyableWithDataAndSize OtherContainer&gt; <br />
requires (std::same_as&lt;value_type, <a class="el" href="namespacevctr.html#a83a43fd917a646b18b60be7e88becc33">ValueType</a>&lt;OtherContainer&gt;&gt; &amp;&amp; ! std::same_as&lt;<a class="el" href="classvctr_1_1Array.html">Array</a>, OtherContainer&gt;)</td></tr>
<tr class="memitem:a3eaf7f17f4ec7b84e68b69c47f17b5d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1Array.html#a3eaf7f17f4ec7b84e68b69c47f17b5d7">Array</a> (const OtherContainer &amp;other)</td></tr>
<tr class="memdesc:a3eaf7f17f4ec7b84e68b69c47f17b5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor will create an <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> instance of the same size as OtherContainer and will copy its values into this <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a>.  <br /></td></tr>
<tr class="separator:a3eaf7f17f4ec7b84e68b69c47f17b5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb666532509923815c06a593a2ba7b9"><td class="memTemplParams" colspan="2">template&lt;is::iteratorCopyable OtherContainer&gt; </td></tr>
<tr class="memitem:afcb666532509923815c06a593a2ba7b9"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1Array.html#afcb666532509923815c06a593a2ba7b9">Array</a> (const OtherContainer &amp;other)</td></tr>
<tr class="memdesc:afcb666532509923815c06a593a2ba7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor will create an <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> instance of the same size as OtherContainer and will copy its values into this <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a>.  <br /></td></tr>
<tr class="separator:afcb666532509923815c06a593a2ba7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea1bd962c51bd20de9777f75d3d0ab6"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Array.html#aeea1bd962c51bd20de9777f75d3d0ab6">Array</a> (const ElementType *<a class="el" href="classvctr_1_1VctrBase.html#a776a0a4f16ecc3c25f5a1e2eac1d094b">data</a>, size_t <a class="el" href="classvctr_1_1VctrBase.html#a0ec564aacdb2c8a90604e4fa142404ed">size</a>)</td></tr>
<tr class="memdesc:aeea1bd962c51bd20de9777f75d3d0ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies size elements from the memory location pointed to by data.  <br /></td></tr>
<tr class="separator:aeea1bd962c51bd20de9777f75d3d0ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448c1fede9201acb6820edc79b584168"><td class="memTemplParams" colspan="2">template&lt;is::inputIteratorToConstructValuesOfType&lt; ElementType &gt; Iterator, std::sentinel_for&lt; Iterator &gt; Sentinel&gt; </td></tr>
<tr class="memitem:a448c1fede9201acb6820edc79b584168"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1Array.html#a448c1fede9201acb6820edc79b584168">Array</a> (Iterator first, Sentinel last)</td></tr>
<tr class="memdesc:a448c1fede9201acb6820edc79b584168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> from an iterator and a sentinel by initialising the <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> with the content read from the iterator.  <br /></td></tr>
<tr class="separator:a448c1fede9201acb6820edc79b584168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6586c82c9867fd83561da975269cab"><td class="memTemplParams" colspan="2">template&lt;is::suitableInitializerFunctionForElementType&lt; ElementType &gt; Fn&gt; </td></tr>
<tr class="memitem:a1e6586c82c9867fd83561da975269cab"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1Array.html#a1e6586c82c9867fd83561da975269cab">Array</a> (Fn &amp;&amp;initializerFunction)</td></tr>
<tr class="memdesc:a1e6586c82c9867fd83561da975269cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector of the given size and initialises all elements by calling initializerFunction with the element's index.  <br /></td></tr>
<tr class="separator:a1e6586c82c9867fd83561da975269cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2a944ba41a9239d25743f338487eb0"><td class="memTemplParams" colspan="2">template&lt;is::expression Expression&gt; </td></tr>
<tr class="memitem:a3a2a944ba41a9239d25743f338487eb0"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1Array.html#a3a2a944ba41a9239d25743f338487eb0">Array</a> (Expression &amp;&amp;e)</td></tr>
<tr class="memdesc:a3a2a944ba41a9239d25743f338487eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> from an expression template.  <br /></td></tr>
<tr class="separator:a3a2a944ba41a9239d25743f338487eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27be2a744655b57b283dca8b093b3a0"><td class="memTemplParams" colspan="2">template&lt;has::sizeAndDataWithElementType&lt; ElementType &gt; Container&gt; </td></tr>
<tr class="memitem:ac27be2a744655b57b283dca8b093b3a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classvctr_1_1Array.html">Array</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1Array.html#ac27be2a744655b57b283dca8b093b3a0">operator=</a> (Container &amp;&amp;containerToCopyDataFrom)</td></tr>
<tr class="memdesc:ac27be2a744655b57b283dca8b093b3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies or moves the data of the source container to this <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a>.  <br /></td></tr>
<tr class="separator:ac27be2a744655b57b283dca8b093b3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4c6617d67dc77a490991425a8bb1b1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classvctr_1_1Array.html">Array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Array.html#a6f4c6617d67dc77a490991425a8bb1b1">operator=</a> (std::initializer_list&lt; ElementType &gt; elementsToAssign)</td></tr>
<tr class="memdesc:a6f4c6617d67dc77a490991425a8bb1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns elements from the initializer list to this <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a>.  <br /></td></tr>
<tr class="separator:a6f4c6617d67dc77a490991425a8bb1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a6c644fc5e650be8f608aee7ffbaaf"><td class="memTemplParams" colspan="2">template&lt;is::expression E&gt; </td></tr>
<tr class="memitem:a23a6c644fc5e650be8f608aee7ffbaaf"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1Array.html#a23a6c644fc5e650be8f608aee7ffbaaf">operator=</a> (const E &amp;expression)</td></tr>
<tr class="memdesc:a23a6c644fc5e650be8f608aee7ffbaaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the result of an expression to this vector.  <br /></td></tr>
<tr class="separator:a23a6c644fc5e650be8f608aee7ffbaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec564aacdb2c8a90604e4fa142404ed"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a0ec564aacdb2c8a90604e4fa142404ed">size</a> () const noexcept</td></tr>
<tr class="memdesc:a0ec564aacdb2c8a90604e4fa142404ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements.  <br /></td></tr>
<tr class="separator:a0ec564aacdb2c8a90604e4fa142404ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb907e744177485ef9aaf219b0756b90"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#acb907e744177485ef9aaf219b0756b90">empty</a> () const noexcept</td></tr>
<tr class="memdesc:acb907e744177485ef9aaf219b0756b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the container is empty.  <br /></td></tr>
<tr class="separator:acb907e744177485ef9aaf219b0756b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681a9fa9e731497b3cdfc9752c091c9b"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a681a9fa9e731497b3cdfc9752c091c9b">sizeInBytes</a> () const noexcept</td></tr>
<tr class="memdesc:a681a9fa9e731497b3cdfc9752c091c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container size in bytes.  <br /></td></tr>
<tr class="separator:a681a9fa9e731497b3cdfc9752c091c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d10b2c53d0ab60ef0c2f9e97578f8b"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ab8d10b2c53d0ab60ef0c2f9e97578f8b">backIdx</a> () const noexcept</td></tr>
<tr class="memdesc:ab8d10b2c53d0ab60ef0c2f9e97578f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index referring to the last element in the vector.  <br /></td></tr>
<tr class="separator:ab8d10b2c53d0ab60ef0c2f9e97578f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa689a52afa0d76a308cf176083f731c6"><td class="memItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#aa689a52afa0d76a308cf176083f731c6">operator[]</a> (size_t i)</td></tr>
<tr class="memdesc:aa689a52afa0d76a308cf176083f731c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to element i.  <br /></td></tr>
<tr class="separator:aa689a52afa0d76a308cf176083f731c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d921dc0ff2a400920940dfee087ac8d"><td class="memItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a0d921dc0ff2a400920940dfee087ac8d">operator[]</a> (size_t i) const</td></tr>
<tr class="memdesc:a0d921dc0ff2a400920940dfee087ac8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to element i.  <br /></td></tr>
<tr class="separator:a0d921dc0ff2a400920940dfee087ac8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b345685b9741d1b59ffaaf3bfca3a6"><td class="memItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ac9b345685b9741d1b59ffaaf3bfca3a6">at</a> (size_t i)</td></tr>
<tr class="memdesc:ac9b345685b9741d1b59ffaaf3bfca3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to element i.  <br /></td></tr>
<tr class="separator:ac9b345685b9741d1b59ffaaf3bfca3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3c7eabe11604976881266c3f222fb6"><td class="memItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a8f3c7eabe11604976881266c3f222fb6">at</a> (size_t i) const</td></tr>
<tr class="memdesc:a8f3c7eabe11604976881266c3f222fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to element i.  <br /></td></tr>
<tr class="separator:a8f3c7eabe11604976881266c3f222fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b83cec6a9e6b0a5801d45331fefdf4"><td class="memItemLeft" align="right" valign="top">constexpr auto &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#aa0b83cec6a9e6b0a5801d45331fefdf4">front</a> ()</td></tr>
<tr class="memdesc:aa0b83cec6a9e6b0a5801d45331fefdf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element.  <br /></td></tr>
<tr class="separator:aa0b83cec6a9e6b0a5801d45331fefdf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5e8a34c7458574ddda43da9cfba433"><td class="memItemLeft" align="right" valign="top">constexpr auto &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a9a5e8a34c7458574ddda43da9cfba433">front</a> () const</td></tr>
<tr class="memdesc:a9a5e8a34c7458574ddda43da9cfba433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element.  <br /></td></tr>
<tr class="separator:a9a5e8a34c7458574ddda43da9cfba433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa966d96bbeefb5c773194c70a126cbe7"><td class="memItemLeft" align="right" valign="top">constexpr auto &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#aa966d96bbeefb5c773194c70a126cbe7">back</a> ()</td></tr>
<tr class="memdesc:aa966d96bbeefb5c773194c70a126cbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element.  <br /></td></tr>
<tr class="separator:aa966d96bbeefb5c773194c70a126cbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e55deac0cab66b4bad8d75bd420c4f"><td class="memItemLeft" align="right" valign="top">constexpr auto &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ae3e55deac0cab66b4bad8d75bd420c4f">back</a> () const</td></tr>
<tr class="memdesc:ae3e55deac0cab66b4bad8d75bd420c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element.  <br /></td></tr>
<tr class="separator:ae3e55deac0cab66b4bad8d75bd420c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776a0a4f16ecc3c25f5a1e2eac1d094b"><td class="memItemLeft" align="right" valign="top">VCTR_FORCEDINLINE constexpr auto *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a776a0a4f16ecc3c25f5a1e2eac1d094b">data</a> ()</td></tr>
<tr class="memdesc:a776a0a4f16ecc3c25f5a1e2eac1d094b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw pointer to the underlying storage.  <br /></td></tr>
<tr class="separator:a776a0a4f16ecc3c25f5a1e2eac1d094b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed4bae89175ad4f0da54a9d807d2d75"><td class="memItemLeft" align="right" valign="top">VCTR_FORCEDINLINE constexpr auto *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a2ed4bae89175ad4f0da54a9d807d2d75">data</a> () const</td></tr>
<tr class="memdesc:a2ed4bae89175ad4f0da54a9d807d2d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw pointer to the underlying storage.  <br /></td></tr>
<tr class="separator:a2ed4bae89175ad4f0da54a9d807d2d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d62467d4d84cd6e7fd185f73cf24033"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a4d62467d4d84cd6e7fd185f73cf24033">begin</a> ()</td></tr>
<tr class="memdesc:a4d62467d4d84cd6e7fd185f73cf24033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the begin of the storage.  <br /></td></tr>
<tr class="separator:a4d62467d4d84cd6e7fd185f73cf24033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72810409ab6153d55e6f9afb0743449"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ae72810409ab6153d55e6f9afb0743449">begin</a> () const</td></tr>
<tr class="memdesc:ae72810409ab6153d55e6f9afb0743449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the begin of the storage.  <br /></td></tr>
<tr class="separator:ae72810409ab6153d55e6f9afb0743449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82f4383edea8be887d6f1617cfa4edf"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf">end</a> ()</td></tr>
<tr class="memdesc:ae82f4383edea8be887d6f1617cfa4edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element behind the storage.  <br /></td></tr>
<tr class="separator:ae82f4383edea8be887d6f1617cfa4edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0117b7f6fc7cd51595146070fa0533"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a8d0117b7f6fc7cd51595146070fa0533">end</a> () const</td></tr>
<tr class="memdesc:a8d0117b7f6fc7cd51595146070fa0533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the first element behind the storage.  <br /></td></tr>
<tr class="separator:a8d0117b7f6fc7cd51595146070fa0533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af982e33f6fa36af4add9f0373bde98a8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#af982e33f6fa36af4add9f0373bde98a8">rbegin</a> ()</td></tr>
<tr class="memdesc:af982e33f6fa36af4add9f0373bde98a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the last element in the storage.  <br /></td></tr>
<tr class="separator:af982e33f6fa36af4add9f0373bde98a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dad4052f5d8720bdfb2414ac9b6b75"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#af5dad4052f5d8720bdfb2414ac9b6b75">rbegin</a> () const</td></tr>
<tr class="memdesc:af5dad4052f5d8720bdfb2414ac9b6b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the last element in the storage.  <br /></td></tr>
<tr class="separator:af5dad4052f5d8720bdfb2414ac9b6b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f6fd77a0b41775cbbdddc212a1eb38"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ac3f6fd77a0b41775cbbdddc212a1eb38">rend</a> ()</td></tr>
<tr class="memdesc:ac3f6fd77a0b41775cbbdddc212a1eb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element before the first element in the storage.  <br /></td></tr>
<tr class="separator:ac3f6fd77a0b41775cbbdddc212a1eb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa539547c92850b3e14f2067afd070c4b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#aa539547c92850b3e14f2067afd070c4b">rend</a> () const</td></tr>
<tr class="memdesc:aa539547c92850b3e14f2067afd070c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the element before the first element in the storage.  <br /></td></tr>
<tr class="separator:aa539547c92850b3e14f2067afd070c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d9c9c2d8cd0874aecc6f6ee17dfa66"><td class="memTemplParams" colspan="2">template&lt;size_t startIdx&gt; </td></tr>
<tr class="memitem:a29d9c9c2d8cd0874aecc6f6ee17dfa66"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a29d9c9c2d8cd0874aecc6f6ee17dfa66">subSpan</a> ()</td></tr>
<tr class="memdesc:a29d9c9c2d8cd0874aecc6f6ee17dfa66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> - startIdx.  <br /></td></tr>
<tr class="separator:a29d9c9c2d8cd0874aecc6f6ee17dfa66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1180d252ae45809e7150458345c93e"><td class="memTemplParams" colspan="2">template&lt;size_t startIdx&gt; </td></tr>
<tr class="memitem:a8a1180d252ae45809e7150458345c93e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a8a1180d252ae45809e7150458345c93e">subSpan</a> () const</td></tr>
<tr class="memdesc:a8a1180d252ae45809e7150458345c93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> - startIdx.  <br /></td></tr>
<tr class="separator:a8a1180d252ae45809e7150458345c93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e737d53237f32af2685faa02ae26d55"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a8e737d53237f32af2685faa02ae26d55">subSpan</a> (size_t startIdx)</td></tr>
<tr class="memdesc:a8e737d53237f32af2685faa02ae26d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> - startIdx.  <br /></td></tr>
<tr class="separator:a8e737d53237f32af2685faa02ae26d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc30017f36afa555e69770aadbb5fb2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a2bc30017f36afa555e69770aadbb5fb2">subSpan</a> (size_t startIdx) const</td></tr>
<tr class="memdesc:a2bc30017f36afa555e69770aadbb5fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> - startIdx.  <br /></td></tr>
<tr class="separator:a2bc30017f36afa555e69770aadbb5fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828d59afc6a87d40566840ffde8a6a50"><td class="memTemplParams" colspan="2">template&lt;size_t startIdx, size_t numElements&gt; </td></tr>
<tr class="memitem:a828d59afc6a87d40566840ffde8a6a50"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a828d59afc6a87d40566840ffde8a6a50">subSpan</a> ()</td></tr>
<tr class="memdesc:a828d59afc6a87d40566840ffde8a6a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of numElements.  <br /></td></tr>
<tr class="separator:a828d59afc6a87d40566840ffde8a6a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214960993f1d15ed248de6382ae16b0e"><td class="memTemplParams" colspan="2">template&lt;size_t startIdx, size_t numElements&gt; </td></tr>
<tr class="memitem:a214960993f1d15ed248de6382ae16b0e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a214960993f1d15ed248de6382ae16b0e">subSpan</a> () const</td></tr>
<tr class="memdesc:a214960993f1d15ed248de6382ae16b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of numElements.  <br /></td></tr>
<tr class="separator:a214960993f1d15ed248de6382ae16b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ccea594565f121e340eb85db5ff972f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a5ccea594565f121e340eb85db5ff972f">subSpan</a> (size_t startIdx, size_t numElements)</td></tr>
<tr class="memdesc:a5ccea594565f121e340eb85db5ff972f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of numElements.  <br /></td></tr>
<tr class="separator:a5ccea594565f121e340eb85db5ff972f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebddf025d6d6fb9bc5deb44b4c9ca3c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a4ebddf025d6d6fb9bc5deb44b4c9ca3c">subSpan</a> (size_t startIdx, size_t numElements) const</td></tr>
<tr class="memdesc:a4ebddf025d6d6fb9bc5deb44b4c9ca3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of numElements.  <br /></td></tr>
<tr class="separator:a4ebddf025d6d6fb9bc5deb44b4c9ca3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eed8c702aa74cf5e9fbab436b8a6f20"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a4eed8c702aa74cf5e9fbab436b8a6f20">assign</a> (std::initializer_list&lt; ElementType &gt; elements)</td></tr>
<tr class="memdesc:a4eed8c702aa74cf5e9fbab436b8a6f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns elements from the initializer list to this instance.  <br /></td></tr>
<tr class="separator:a4eed8c702aa74cf5e9fbab436b8a6f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8d59c063990c037ff50a7a9e6b3749"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a6a8d59c063990c037ff50a7a9e6b3749">copyFrom</a> (const ElementType *otherData, size_t otherSize)</td></tr>
<tr class="memdesc:a6a8d59c063990c037ff50a7a9e6b3749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the content from otherData to this instance.  <br /></td></tr>
<tr class="separator:a6a8d59c063990c037ff50a7a9e6b3749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a469facc53750163032618d7ec2751"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ad4a469facc53750163032618d7ec2751">fill</a> (const value_type &amp;value)</td></tr>
<tr class="memdesc:ad4a469facc53750163032618d7ec2751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the container with the given value.  <br /></td></tr>
<tr class="separator:ad4a469facc53750163032618d7ec2751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e42070dab5544e39faf3d372913c11"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a13e42070dab5544e39faf3d372913c11">fillLinspace</a> (ElementType start, ElementType stop, bool includeEnd=true)</td></tr>
<tr class="memdesc:a13e42070dab5544e39faf3d372913c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the vector with evenly spaced numbers between start and stop.  <br /></td></tr>
<tr class="separator:a13e42070dab5544e39faf3d372913c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f93b4ac09db43de3553fea3194b5fc"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; void(value_type &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:a85f93b4ac09db43de3553fea3194b5fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a85f93b4ac09db43de3553fea3194b5fc">forEach</a> (Fn &amp;&amp;fn)</td></tr>
<tr class="memdesc:a85f93b4ac09db43de3553fea3194b5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function on each element.  <br /></td></tr>
<tr class="separator:a85f93b4ac09db43de3553fea3194b5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187a80a3e5380b3b61e666ce3f6d5424"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; void(const value_type &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:a187a80a3e5380b3b61e666ce3f6d5424"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a187a80a3e5380b3b61e666ce3f6d5424">forEach</a> (Fn &amp;&amp;fn) const</td></tr>
<tr class="memdesc:a187a80a3e5380b3b61e666ce3f6d5424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function on each element.  <br /></td></tr>
<tr class="separator:a187a80a3e5380b3b61e666ce3f6d5424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f93b4ac09db43de3553fea3194b5fc"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; value_type(const value_type &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:a85f93b4ac09db43de3553fea3194b5fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a85f93b4ac09db43de3553fea3194b5fc">forEach</a> (Fn &amp;&amp;fn)</td></tr>
<tr class="memdesc:a85f93b4ac09db43de3553fea3194b5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function on each element.  <br /></td></tr>
<tr class="separator:a85f93b4ac09db43de3553fea3194b5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f93b4ac09db43de3553fea3194b5fc"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; void(value_type &amp;, size_t)&gt; Fn&gt; </td></tr>
<tr class="memitem:a85f93b4ac09db43de3553fea3194b5fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a85f93b4ac09db43de3553fea3194b5fc">forEach</a> (Fn &amp;&amp;fn)</td></tr>
<tr class="memdesc:a85f93b4ac09db43de3553fea3194b5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function on each element and passes the element index as second function argument.  <br /></td></tr>
<tr class="separator:a85f93b4ac09db43de3553fea3194b5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187a80a3e5380b3b61e666ce3f6d5424"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; void(const value_type &amp;, size_t)&gt; Fn&gt; </td></tr>
<tr class="memitem:a187a80a3e5380b3b61e666ce3f6d5424"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a187a80a3e5380b3b61e666ce3f6d5424">forEach</a> (Fn &amp;&amp;fn) const</td></tr>
<tr class="memdesc:a187a80a3e5380b3b61e666ce3f6d5424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function on each element and passes the element index as second function argument.  <br /></td></tr>
<tr class="separator:a187a80a3e5380b3b61e666ce3f6d5424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f93b4ac09db43de3553fea3194b5fc"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; value_type(const value_type &amp;, size_t)&gt; Fn&gt; </td></tr>
<tr class="memitem:a85f93b4ac09db43de3553fea3194b5fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a85f93b4ac09db43de3553fea3194b5fc">forEach</a> (Fn &amp;&amp;fn)</td></tr>
<tr class="memdesc:a85f93b4ac09db43de3553fea3194b5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function on each element and passes the element index as second function argument.  <br /></td></tr>
<tr class="separator:a85f93b4ac09db43de3553fea3194b5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d70bbcdff2fd01c0f555d92467063a"><td class="memTemplParams" colspan="2">template&lt;class... Args, is::functionWithSignatureOrImplicitlyConvertible&lt; void(value_type &amp;, Args &amp;&amp;...)&gt; Fn&gt; </td></tr>
<tr class="memitem:a62d70bbcdff2fd01c0f555d92467063a"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a62d70bbcdff2fd01c0f555d92467063a">forEach</a> (Fn &amp;&amp;fn, Args &amp;&amp;... fnArgs)</td></tr>
<tr class="memdesc:a62d70bbcdff2fd01c0f555d92467063a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function on each element and forwards fnArgs to the function after the value.  <br /></td></tr>
<tr class="separator:a62d70bbcdff2fd01c0f555d92467063a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a72bd1e6f648eaa2c9780bc560c664"><td class="memTemplParams" colspan="2">template&lt;class... Args, is::functionWithSignatureOrImplicitlyConvertible&lt; void(const value_type &amp;, Args &amp;&amp;...)&gt; Fn&gt; </td></tr>
<tr class="memitem:ac3a72bd1e6f648eaa2c9780bc560c664"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ac3a72bd1e6f648eaa2c9780bc560c664">forEach</a> (Fn &amp;&amp;fn, Args &amp;&amp;... fnArgs) const</td></tr>
<tr class="memdesc:ac3a72bd1e6f648eaa2c9780bc560c664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function on each element and forwards fnArgs to the function after the value.  <br /></td></tr>
<tr class="separator:ac3a72bd1e6f648eaa2c9780bc560c664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d70bbcdff2fd01c0f555d92467063a"><td class="memTemplParams" colspan="2">template&lt;class... Args, is::functionWithSignatureOrImplicitlyConvertible&lt; value_type(const value_type &amp;, Args &amp;&amp;...)&gt; Fn&gt; </td></tr>
<tr class="memitem:a62d70bbcdff2fd01c0f555d92467063a"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a62d70bbcdff2fd01c0f555d92467063a">forEach</a> (Fn &amp;&amp;fn, Args &amp;&amp;... fnArgs)</td></tr>
<tr class="memdesc:a62d70bbcdff2fd01c0f555d92467063a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function on each element and forwards fnArgs to the function after the value.  <br /></td></tr>
<tr class="separator:a62d70bbcdff2fd01c0f555d92467063a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b32192ab7691ff8e24fe85937df8cfc"><td class="memTemplParams" colspan="2">template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </td></tr>
<tr class="memitem:a3b32192ab7691ff8e24fe85937df8cfc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a3b32192ab7691ff8e24fe85937df8cfc">find</a> (const T &amp;valueToLookFor)</td></tr>
<tr class="memdesc:a3b32192ab7691ff8e24fe85937df8cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element that equals valueToLookFor or <a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf" title="Returns an iterator to the first element behind the storage.">end()</a> if none was found.  <br /></td></tr>
<tr class="separator:a3b32192ab7691ff8e24fe85937df8cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457b883bdf44506a49faa497659aa0b4"><td class="memTemplParams" colspan="2">template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </td></tr>
<tr class="memitem:a457b883bdf44506a49faa497659aa0b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a457b883bdf44506a49faa497659aa0b4">find</a> (const T &amp;valueToLookFor) const</td></tr>
<tr class="memdesc:a457b883bdf44506a49faa497659aa0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the first element that equals valueToLookFor or <a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf" title="Returns an iterator to the first element behind the storage.">end()</a> if none was found.  <br /></td></tr>
<tr class="separator:a457b883bdf44506a49faa497659aa0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13389760f277db65b2d08cc058e58e25"><td class="memTemplParams" colspan="2">template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </td></tr>
<tr class="memitem:a13389760f277db65b2d08cc058e58e25"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a13389760f277db65b2d08cc058e58e25">findReverse</a> (const T &amp;valueToLookFor)</td></tr>
<tr class="memdesc:a13389760f277db65b2d08cc058e58e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the last element in this vector that equals valueToLookFor or <a class="el" href="classvctr_1_1VctrBase.html#ac3f6fd77a0b41775cbbdddc212a1eb38" title="Returns a reverse iterator to the element before the first element in the storage.">rend()</a> if none was found.  <br /></td></tr>
<tr class="separator:a13389760f277db65b2d08cc058e58e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684b197edd1baefcbb9db31bfd221faf"><td class="memTemplParams" colspan="2">template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </td></tr>
<tr class="memitem:a684b197edd1baefcbb9db31bfd221faf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a684b197edd1baefcbb9db31bfd221faf">findReverse</a> (const T &amp;valueToLookFor) const</td></tr>
<tr class="memdesc:a684b197edd1baefcbb9db31bfd221faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the last element in this vector that equals valueToLookFor or <a class="el" href="classvctr_1_1VctrBase.html#ac3f6fd77a0b41775cbbdddc212a1eb38" title="Returns a reverse iterator to the element before the first element in the storage.">rend()</a> if none was found.  <br /></td></tr>
<tr class="separator:a684b197edd1baefcbb9db31bfd221faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0a138a1344cc551cf44763435213e0"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:a8a0a138a1344cc551cf44763435213e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a8a0a138a1344cc551cf44763435213e0">findIf</a> (Fn &amp;&amp;predicate)</td></tr>
<tr class="memdesc:a8a0a138a1344cc551cf44763435213e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element in this vector for which predicate returns true or <a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf" title="Returns an iterator to the first element behind the storage.">end()</a> if none was found.  <br /></td></tr>
<tr class="separator:a8a0a138a1344cc551cf44763435213e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30f1790e9e54a5e29bc28118a6bd136"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:ac30f1790e9e54a5e29bc28118a6bd136"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ac30f1790e9e54a5e29bc28118a6bd136">findIf</a> (Fn &amp;&amp;predicate) const</td></tr>
<tr class="memdesc:ac30f1790e9e54a5e29bc28118a6bd136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the first element in this vector for which predicate returns true or <a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf" title="Returns an iterator to the first element behind the storage.">end()</a> if none was found.  <br /></td></tr>
<tr class="separator:ac30f1790e9e54a5e29bc28118a6bd136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c04176763bb439535383f415e9a1a41"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:a9c04176763bb439535383f415e9a1a41"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a9c04176763bb439535383f415e9a1a41">findIfReverse</a> (Fn &amp;&amp;predicate)</td></tr>
<tr class="memdesc:a9c04176763bb439535383f415e9a1a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the last element in this vector for which predicate returns true or <a class="el" href="classvctr_1_1VctrBase.html#ac3f6fd77a0b41775cbbdddc212a1eb38" title="Returns a reverse iterator to the element before the first element in the storage.">rend()</a> if none was found.  <br /></td></tr>
<tr class="separator:a9c04176763bb439535383f415e9a1a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b0c83ff87a33d32f08669e39ace236"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:a91b0c83ff87a33d32f08669e39ace236"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a91b0c83ff87a33d32f08669e39ace236">findIfReverse</a> (Fn &amp;&amp;predicate) const</td></tr>
<tr class="memdesc:a91b0c83ff87a33d32f08669e39ace236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the last element in this vector for which predicate returns true or <a class="el" href="classvctr_1_1VctrBase.html#ac3f6fd77a0b41775cbbdddc212a1eb38" title="Returns a reverse iterator to the element before the first element in the storage.">rend()</a> if none was found.  <br /></td></tr>
<tr class="separator:a91b0c83ff87a33d32f08669e39ace236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a8ac49770a19c6d3bef9a59ffacbdd"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a03a8ac49770a19c6d3bef9a59ffacbdd">count</a> (const ElementType &amp;valueToLookFor) const</td></tr>
<tr class="memdesc:a03a8ac49770a19c6d3bef9a59ffacbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that are equal to valueToLookFor.  <br /></td></tr>
<tr class="separator:a03a8ac49770a19c6d3bef9a59ffacbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3203acc6a3098a878819b1e02f00d1"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:a5a3203acc6a3098a878819b1e02f00d1"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a5a3203acc6a3098a878819b1e02f00d1">countIf</a> (Fn &amp;&amp;predicate) const</td></tr>
<tr class="memdesc:a5a3203acc6a3098a878819b1e02f00d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that satisfy predicate.  <br /></td></tr>
<tr class="separator:a5a3203acc6a3098a878819b1e02f00d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0aa01c4581292b0c61510403841e83"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:a4c0aa01c4581292b0c61510403841e83"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a4c0aa01c4581292b0c61510403841e83">all</a> (Fn &amp;&amp;predicate) const</td></tr>
<tr class="memdesc:a4c0aa01c4581292b0c61510403841e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements satisfy the predicate or if the container is empty.  <br /></td></tr>
<tr class="separator:a4c0aa01c4581292b0c61510403841e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e58cc0b4db47384b4bb9a6b6799ab2"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:ad9e58cc0b4db47384b4bb9a6b6799ab2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ad9e58cc0b4db47384b4bb9a6b6799ab2">any</a> (Fn &amp;&amp;predicate) const</td></tr>
<tr class="memdesc:ad9e58cc0b4db47384b4bb9a6b6799ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if one or more elements satisfy the predicate.  <br /></td></tr>
<tr class="separator:ad9e58cc0b4db47384b4bb9a6b6799ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf31bb72d409439360f387914d235757"><td class="memTemplParams" colspan="2">template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </td></tr>
<tr class="memitem:aaf31bb72d409439360f387914d235757"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#aaf31bb72d409439360f387914d235757">allElementsEqual</a> (const T &amp;value) const</td></tr>
<tr class="memdesc:aaf31bb72d409439360f387914d235757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements are equal to value or if the container is empty.  <br /></td></tr>
<tr class="separator:aaf31bb72d409439360f387914d235757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf5f3b3d0920f0ef7b2a9cc09d91f86"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a9cf5f3b3d0920f0ef7b2a9cc09d91f86">allElementsEqual</a> () const</td></tr>
<tr class="memdesc:a9cf5f3b3d0920f0ef7b2a9cc09d91f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements are equal to themselves.  <br /></td></tr>
<tr class="separator:a9cf5f3b3d0920f0ef7b2a9cc09d91f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca7364ca53cdea690f09329ccb89c36"><td class="memTemplParams" colspan="2">template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </td></tr>
<tr class="memitem:aeca7364ca53cdea690f09329ccb89c36"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#aeca7364ca53cdea690f09329ccb89c36">contains</a> (const T &amp;value) const</td></tr>
<tr class="memdesc:aeca7364ca53cdea690f09329ccb89c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if at least one element is equal to value.  <br /></td></tr>
<tr class="separator:aeca7364ca53cdea690f09329ccb89c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ae8625a2045e850b0a0162c1c7f3c3"><td class="memTemplParams" colspan="2">template&lt;is::contiguousIteratorWithValueTypeSameAs&lt; ElementType &gt; It&gt; </td></tr>
<tr class="memitem:a08ae8625a2045e850b0a0162c1c7f3c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a08ae8625a2045e850b0a0162c1c7f3c3">contains</a> (It it) const</td></tr>
<tr class="memdesc:a08ae8625a2045e850b0a0162c1c7f3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the iterator refers to an element inside this container or span.  <br /></td></tr>
<tr class="separator:a08ae8625a2045e850b0a0162c1c7f3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88aa485f2931bf79d075b06d132c6df7"><td class="memTemplParams" colspan="2">template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </td></tr>
<tr class="memitem:a88aa485f2931bf79d075b06d132c6df7"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::optional&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a88aa485f2931bf79d075b06d132c6df7">indexOf</a> (const T &amp;value) const</td></tr>
<tr class="memdesc:a88aa485f2931bf79d075b06d132c6df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first element that compares true to value or std::nullopt if none is found.  <br /></td></tr>
<tr class="separator:a88aa485f2931bf79d075b06d132c6df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7733e55415e624cf6a97fab0cef693"><td class="memTemplParams" colspan="2">template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </td></tr>
<tr class="memitem:a4d7733e55415e624cf6a97fab0cef693"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::optional&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a4d7733e55415e624cf6a97fab0cef693">indexOfReverse</a> (const T &amp;value) const</td></tr>
<tr class="memdesc:a4d7733e55415e624cf6a97fab0cef693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the last element that compares true to value or std::nullopt if none is found.  <br /></td></tr>
<tr class="separator:a4d7733e55415e624cf6a97fab0cef693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc631d848a921dbc4222a5890751067"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:aefc631d848a921dbc4222a5890751067"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::optional&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#aefc631d848a921dbc4222a5890751067">indexIf</a> (Fn &amp;&amp;predicate) const</td></tr>
<tr class="memdesc:aefc631d848a921dbc4222a5890751067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first element that satisfies the predicate or std::nullopt if none is found.  <br /></td></tr>
<tr class="separator:aefc631d848a921dbc4222a5890751067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13755f0b72bc98a60663e7e90be620cc"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </td></tr>
<tr class="memitem:a13755f0b72bc98a60663e7e90be620cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::optional&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a13755f0b72bc98a60663e7e90be620cc">indexIfReverse</a> (Fn &amp;&amp;predicate) const</td></tr>
<tr class="memdesc:a13755f0b72bc98a60663e7e90be620cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the last element that satisfies the predicate or std::nullopt if none is found.  <br /></td></tr>
<tr class="separator:a13755f0b72bc98a60663e7e90be620cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080fe9d9e226860b48acde1178bb3209"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a080fe9d9e226860b48acde1178bb3209">findMaxElement</a> ()</td></tr>
<tr class="memdesc:a080fe9d9e226860b48acde1178bb3209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first greatest element.  <br /></td></tr>
<tr class="separator:a080fe9d9e226860b48acde1178bb3209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029ddc0c88fbc4aac667bca7f6125348"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a029ddc0c88fbc4aac667bca7f6125348">findMaxElement</a> () const</td></tr>
<tr class="memdesc:a029ddc0c88fbc4aac667bca7f6125348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first greatest element.  <br /></td></tr>
<tr class="separator:a029ddc0c88fbc4aac667bca7f6125348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2261b01e1400927039586ef3b4be869b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a2261b01e1400927039586ef3b4be869b">findMinElement</a> ()</td></tr>
<tr class="memdesc:a2261b01e1400927039586ef3b4be869b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first smallest element.  <br /></td></tr>
<tr class="separator:a2261b01e1400927039586ef3b4be869b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24e1fbd352ce351643a5d410179bb8d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ae24e1fbd352ce351643a5d410179bb8d">findMinElement</a> () const</td></tr>
<tr class="memdesc:ae24e1fbd352ce351643a5d410179bb8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first smallest element.  <br /></td></tr>
<tr class="separator:ae24e1fbd352ce351643a5d410179bb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8f6bb18b8c5fc752c3a3c2440bf589"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#abc8f6bb18b8c5fc752c3a3c2440bf589">indexOfMaxElement</a> () const</td></tr>
<tr class="memdesc:abc8f6bb18b8c5fc752c3a3c2440bf589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first greatest element (aka argMax).  <br /></td></tr>
<tr class="separator:abc8f6bb18b8c5fc752c3a3c2440bf589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575932e270e9eb0bb8bf3550cf47acf0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a575932e270e9eb0bb8bf3550cf47acf0">indexOfMinElement</a> () const</td></tr>
<tr class="memdesc:a575932e270e9eb0bb8bf3550cf47acf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first smallest element (aka argMin).  <br /></td></tr>
<tr class="separator:a575932e270e9eb0bb8bf3550cf47acf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf31ce8bd7c61d08b1d0a0128d4a94e"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#abaf31ce8bd7c61d08b1d0a0128d4a94e">firstValueGreaterThanOrEqualTo</a> (const value_type &amp;valueToLookFor) const</td></tr>
<tr class="memdesc:abaf31ce8bd7c61d08b1d0a0128d4a94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a std::optional holding a copy of the first element value which is greater or equal to valueToLookFor or std::nullopt if no such value is found.  <br /></td></tr>
<tr class="separator:abaf31ce8bd7c61d08b1d0a0128d4a94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8062350f8c34a092da9492372fb170"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a9f8062350f8c34a092da9492372fb170">firstValueGreaterThan</a> (const value_type &amp;valueToLookFor) const</td></tr>
<tr class="memdesc:a9f8062350f8c34a092da9492372fb170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a std::optional holding a copy of the first element value which is greater than valueToLookFor or std::nullopt if no such value is found.  <br /></td></tr>
<tr class="separator:a9f8062350f8c34a092da9492372fb170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c46dbf4c7e9584c2d4bc2e627aa3ee6"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a9c46dbf4c7e9584c2d4bc2e627aa3ee6">reverse</a> ()</td></tr>
<tr class="memdesc:a9c46dbf4c7e9584c2d4bc2e627aa3ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of all elements.  <br /></td></tr>
<tr class="separator:a9c46dbf4c7e9584c2d4bc2e627aa3ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c6ce671353756da7465f3def164f10"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a17c6ce671353756da7465f3def164f10">rotate</a> (size_t newFirstElementIdx)</td></tr>
<tr class="memdesc:a17c6ce671353756da7465f3def164f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates the elements so that the element with the index newFirstElementIdx becomes the first element and the element with the index newFirstElementIdx - 1 becomes the last element.  <br /></td></tr>
<tr class="separator:a17c6ce671353756da7465f3def164f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4204c2b21ab30ea9a78e1c30f76111b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#af4204c2b21ab30ea9a78e1c30f76111b">shiftLeft</a> (size_t n, bool clearFreeSpaceAfterShiftedRegion)</td></tr>
<tr class="memdesc:af4204c2b21ab30ea9a78e1c30f76111b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts all elements to the left by n.  <br /></td></tr>
<tr class="separator:af4204c2b21ab30ea9a78e1c30f76111b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b7cafbc190e73f31fbb191de2354e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a00b7cafbc190e73f31fbb191de2354e0">shiftRight</a> (size_t n, bool clearFreeSpaceBeforeShiftedRegion)</td></tr>
<tr class="memdesc:a00b7cafbc190e73f31fbb191de2354e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts all elements to the right by n.  <br /></td></tr>
<tr class="separator:a00b7cafbc190e73f31fbb191de2354e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ceab7317b693f9f763be9e74fc87d6"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a60ceab7317b693f9f763be9e74fc87d6">sort</a> ()</td></tr>
<tr class="memdesc:a60ceab7317b693f9f763be9e74fc87d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts all elements in an ascending order using operator &lt;=&gt;.  <br /></td></tr>
<tr class="separator:a60ceab7317b693f9f763be9e74fc87d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09242aefc7ce2ef77ed27b6a0551552b"><td class="memTemplParams" colspan="2">template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const value_type &amp;, const value_type &amp;)&gt; ComparatorFn&gt; </td></tr>
<tr class="memitem:a09242aefc7ce2ef77ed27b6a0551552b"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a09242aefc7ce2ef77ed27b6a0551552b">sort</a> (ComparatorFn &amp;&amp;compare)</td></tr>
<tr class="memdesc:a09242aefc7ce2ef77ed27b6a0551552b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts all elements in this vector according to the compare function.  <br /></td></tr>
<tr class="separator:a09242aefc7ce2ef77ed27b6a0551552b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71e907a8173889718559fef90a45aed"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ab71e907a8173889718559fef90a45aed">elementsAreSorted</a> () const</td></tr>
<tr class="memdesc:ab71e907a8173889718559fef90a45aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements are sorted.  <br /></td></tr>
<tr class="separator:ab71e907a8173889718559fef90a45aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd7d6eb3c0dbb9edca5ba132a77d4a5"><td class="memItemLeft" align="right" valign="top"><a id="afdd7d6eb3c0dbb9edca5ba132a77d4a5" name="afdd7d6eb3c0dbb9edca5ba132a77d4a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>prepareNeonEvaluation</b> () const</td></tr>
<tr class="separator:afdd7d6eb3c0dbb9edca5ba132a77d4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82baf69e22b816a5b14994c89889a138"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvctr_1_1NeonRegister.html">NeonRegister</a>&lt; std::remove_const_t&lt; ElementType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a82baf69e22b816a5b14994c89889a138">getNeon</a> (size_t i) const &amp;&amp;is</td></tr>
<tr class="memdesc:a82baf69e22b816a5b14994c89889a138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a certain expression in place on this vector, e.g.  <br /></td></tr>
<tr class="separator:a82baf69e22b816a5b14994c89889a138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fa683177debc6197094583a4b482d2"><td class="memItemLeft" align="right" valign="top"><a id="aa0fa683177debc6197094583a4b482d2" name="aa0fa683177debc6197094583a4b482d2"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>isNotAliased</b> (const void *) const</td></tr>
<tr class="separator:aa0fa683177debc6197094583a4b482d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdacaca21b643300b7f6cdc923204887"><td class="memItemLeft" align="right" valign="top"><a id="abdacaca21b643300b7f6cdc923204887" name="abdacaca21b643300b7f6cdc923204887"></a>
VCTR_FORCEDINLINE const ElementType *&#160;</td><td class="memItemRight" valign="bottom"><b>evalNextVectorOpInExpressionChain</b> (void *) const</td></tr>
<tr class="separator:abdacaca21b643300b7f6cdc923204887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dba12f45d035bd1a479ba0bc1a55437"><td class="memItemLeft" align="right" valign="top"><a id="a1dba12f45d035bd1a479ba0bc1a55437" name="a1dba12f45d035bd1a479ba0bc1a55437"></a>
constexpr const <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getStorageInfo</b> () const</td></tr>
<tr class="separator:a1dba12f45d035bd1a479ba0bc1a55437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9420adec66c33c58a40ecad62c94fdf"><td class="memTemplParams" colspan="2">template&lt;is::anyVctrOrExpression V&gt; </td></tr>
<tr class="memitem:af9420adec66c33c58a40ecad62c94fdf"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#af9420adec66c33c58a40ecad62c94fdf">operator*=</a> (const V &amp;v)</td></tr>
<tr class="memdesc:af9420adec66c33c58a40ecad62c94fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this by a vector or expression in place.  <br /></td></tr>
<tr class="separator:af9420adec66c33c58a40ecad62c94fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d393bcae1044593f341499d7e3ff784"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a7d393bcae1044593f341499d7e3ff784">operator*=</a> (value_type c)</td></tr>
<tr class="memdesc:a7d393bcae1044593f341499d7e3ff784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this by a constant in place.  <br /></td></tr>
<tr class="separator:a7d393bcae1044593f341499d7e3ff784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441226b45536b133601da22b47a9ccad"><td class="memTemplParams" colspan="2">template&lt;is::anyVctrOrExpression V&gt; </td></tr>
<tr class="memitem:a441226b45536b133601da22b47a9ccad"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a441226b45536b133601da22b47a9ccad">operator/=</a> (const V &amp;v)</td></tr>
<tr class="memdesc:a441226b45536b133601da22b47a9ccad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides this by a vector or expression in place.  <br /></td></tr>
<tr class="separator:a441226b45536b133601da22b47a9ccad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44993d0d98bdad4d42f7a8522d348574"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a44993d0d98bdad4d42f7a8522d348574">operator/=</a> (value_type c)</td></tr>
<tr class="memdesc:a44993d0d98bdad4d42f7a8522d348574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides this by a constant in place.  <br /></td></tr>
<tr class="separator:a44993d0d98bdad4d42f7a8522d348574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e6342e4327a648e9b7cf5a2ab46b3d"><td class="memTemplParams" colspan="2">template&lt;is::anyVctrOrExpression V&gt; </td></tr>
<tr class="memitem:a34e6342e4327a648e9b7cf5a2ab46b3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a34e6342e4327a648e9b7cf5a2ab46b3d">operator+=</a> (const V &amp;v)</td></tr>
<tr class="memdesc:a34e6342e4327a648e9b7cf5a2ab46b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a vector or expression to this in place.  <br /></td></tr>
<tr class="separator:a34e6342e4327a648e9b7cf5a2ab46b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a24a9704cd970e3f6430b2e1cd495c0"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a8a24a9704cd970e3f6430b2e1cd495c0">operator+=</a> (value_type c)</td></tr>
<tr class="memdesc:a8a24a9704cd970e3f6430b2e1cd495c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant to this in place.  <br /></td></tr>
<tr class="separator:a8a24a9704cd970e3f6430b2e1cd495c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f082ed08028aef23fddf52425fb254e"><td class="memTemplParams" colspan="2">template&lt;is::anyVctrOrExpression V&gt; </td></tr>
<tr class="memitem:a2f082ed08028aef23fddf52425fb254e"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a2f082ed08028aef23fddf52425fb254e">operator-=</a> (const V &amp;v)</td></tr>
<tr class="memdesc:a2f082ed08028aef23fddf52425fb254e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a vector or expression from this in place.  <br /></td></tr>
<tr class="separator:a2f082ed08028aef23fddf52425fb254e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4040fe16ec241401831c8f70781bf1"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a5d4040fe16ec241401831c8f70781bf1">operator-=</a> (value_type c)</td></tr>
<tr class="memdesc:a5d4040fe16ec241401831c8f70781bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a constant from this in place.  <br /></td></tr>
<tr class="separator:a5d4040fe16ec241401831c8f70781bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3809aad3dbd44783fb9d8b4dbbd97207"><td class="memItemLeft" align="right" valign="top">constexpr ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a3809aad3dbd44783fb9d8b4dbbd97207">min</a> () const</td></tr>
<tr class="memdesc:a3809aad3dbd44783fb9d8b4dbbd97207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimal value of all elements.  <br /></td></tr>
<tr class="separator:a3809aad3dbd44783fb9d8b4dbbd97207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e4d6969b97cb396af2d0a1f31b8b1d"><td class="memItemLeft" align="right" valign="top">constexpr ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ac2e4d6969b97cb396af2d0a1f31b8b1d">minAbs</a> () const</td></tr>
<tr class="memdesc:ac2e4d6969b97cb396af2d0a1f31b8b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimal absolute value of all elements.  <br /></td></tr>
<tr class="separator:ac2e4d6969b97cb396af2d0a1f31b8b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30ee026df44d26087f2b2e5242daabd"><td class="memItemLeft" align="right" valign="top">constexpr ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ac30ee026df44d26087f2b2e5242daabd">max</a> () const</td></tr>
<tr class="memdesc:ac30ee026df44d26087f2b2e5242daabd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum value of all elements.  <br /></td></tr>
<tr class="separator:ac30ee026df44d26087f2b2e5242daabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5928bed9ea669ad2500cdb1dd9346db7"><td class="memItemLeft" align="right" valign="top">constexpr ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a5928bed9ea669ad2500cdb1dd9346db7">maxAbs</a> () const</td></tr>
<tr class="memdesc:a5928bed9ea669ad2500cdb1dd9346db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum absolute value of all elements.  <br /></td></tr>
<tr class="separator:a5928bed9ea669ad2500cdb1dd9346db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82b22bb7cf07b3d7441240fd4be96e8"><td class="memItemLeft" align="right" valign="top">constexpr ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ad82b22bb7cf07b3d7441240fd4be96e8">mean</a> () const</td></tr>
<tr class="memdesc:ad82b22bb7cf07b3d7441240fd4be96e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mean value across all elements.  <br /></td></tr>
<tr class="separator:ad82b22bb7cf07b3d7441240fd4be96e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8380fd770f1c73e257bb644c9745af0"><td class="memItemLeft" align="right" valign="top">constexpr ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ae8380fd770f1c73e257bb644c9745af0">meanSquare</a> () const</td></tr>
<tr class="memdesc:ae8380fd770f1c73e257bb644c9745af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mean value across all squared elements.  <br /></td></tr>
<tr class="separator:ae8380fd770f1c73e257bb644c9745af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9ca4b0cc5d3894ff875bcc0a1fd431"><td class="memItemLeft" align="right" valign="top">constexpr ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a9b9ca4b0cc5d3894ff875bcc0a1fd431">rms</a> () const</td></tr>
<tr class="memdesc:a9b9ca4b0cc5d3894ff875bcc0a1fd431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the square root of the mean value across all squared elements.  <br /></td></tr>
<tr class="separator:a9b9ca4b0cc5d3894ff875bcc0a1fd431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5f3def86f5ab26a70456c779a91d9d"><td class="memItemLeft" align="right" valign="top">constexpr ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#add5f3def86f5ab26a70456c779a91d9d">sum</a> () const</td></tr>
<tr class="memdesc:add5f3def86f5ab26a70456c779a91d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements.  <br /></td></tr>
<tr class="separator:add5f3def86f5ab26a70456c779a91d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e8eb4d0bb4ef2a93441c79f680607c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#aa3e8eb4d0bb4ef2a93441c79f680607c">allElementsAreFinite</a> ()</td></tr>
<tr class="memdesc:aa3e8eb4d0bb4ef2a93441c79f680607c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements are finite.  <br /></td></tr>
<tr class="separator:aa3e8eb4d0bb4ef2a93441c79f680607c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ad88bbdf3ff0b9ae4aabbe5da92c54"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a73ad88bbdf3ff0b9ae4aabbe5da92c54">allElementsAreFinite</a> ()</td></tr>
<tr class="memdesc:a73ad88bbdf3ff0b9ae4aabbe5da92c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements are finite.  <br /></td></tr>
<tr class="separator:a73ad88bbdf3ff0b9ae4aabbe5da92c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78509572a38d4dc5ae95c7efaae0ec9d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a78509572a38d4dc5ae95c7efaae0ec9d">anyElementIsNaN</a> ()</td></tr>
<tr class="memdesc:a78509572a38d4dc5ae95c7efaae0ec9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any element is NaN.  <br /></td></tr>
<tr class="separator:a78509572a38d4dc5ae95c7efaae0ec9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b77066a3a1e469d00c316af2d94322"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a25b77066a3a1e469d00c316af2d94322">anyElementIsNaN</a> ()</td></tr>
<tr class="memdesc:a25b77066a3a1e469d00c316af2d94322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any real or imaginary part of an element is NaN.  <br /></td></tr>
<tr class="separator:a25b77066a3a1e469d00c316af2d94322"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0dbf4ef57c72393831bc95c2dbddd396"><td class="memItemLeft" align="right" valign="top">static consteval size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a0dbf4ef57c72393831bc95c2dbddd396">getExtent</a> (size_t amountToShrink=0)</td></tr>
<tr class="memdesc:a0dbf4ef57c72393831bc95c2dbddd396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the extent of this instance, optionally shrank by a certain amount.  <br /></td></tr>
<tr class="separator:a0dbf4ef57c72393831bc95c2dbddd396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83870ea4a869114785266ee2fab1598"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598">size</a> () noexcept</td></tr>
<tr class="memdesc:ae83870ea4a869114785266ee2fab1598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements.  <br /></td></tr>
<tr class="separator:ae83870ea4a869114785266ee2fab1598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4612236989c7950e0d69917a007f6b79"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a4612236989c7950e0d69917a007f6b79">sizeInBytes</a> () noexcept</td></tr>
<tr class="memdesc:a4612236989c7950e0d69917a007f6b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the container size in bytes.  <br /></td></tr>
<tr class="separator:a4612236989c7950e0d69917a007f6b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8181b278900a8f16079dcde8750e21d5"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html#a8181b278900a8f16079dcde8750e21d5">backIdx</a> () noexcept</td></tr>
<tr class="memdesc:a8181b278900a8f16079dcde8750e21d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index referring to the last element in the vector.  <br /></td></tr>
<tr class="separator:a8181b278900a8f16079dcde8750e21d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class ElementType, size_t extent, size_t storageExtent = detail::StorageExtent&lt;ElementType, extent&gt;::extent&gt;<br />
requires (extent != std::dynamic_extent &amp;&amp; extent &lt;= storageExtent)<br />
class vctr::Array&lt; ElementType, extent, storageExtent &gt;</div><p>The stack-based container type. </p>
<p>Wraps a std::array of at least the length extent. The size of the underlying std::array might be greater for certain types in order to facilitate SIMD loops, however, the size reported by <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> and the value of extent always refer to the expected size. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a88ddfa6f9624ca651326577d098b56b6" name="a88ddfa6f9624ca651326577d098b56b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ddfa6f9624ca651326577d098b56b6">&#9670;&#160;</a></span>Array() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , size_t extent, size_t storageExtent = detail::StorageExtent&lt;ElementType, extent&gt;::extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classvctr_1_1Array.html">vctr::Array</a>&lt; ElementType, extent, storageExtent &gt;::Array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an uninitialised <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a>. </p>
<p>In case of constant evaluation the values are actually default initialized since uninitialized data structures are not allowed in that case. </p>

</div>
</div>
<a id="a00c3591456164d1c5519782158d5c410" name="a00c3591456164d1c5519782158d5c410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c3591456164d1c5519782158d5c410">&#9670;&#160;</a></span>Array() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , size_t extent, size_t storageExtent = detail::StorageExtent&lt;ElementType, extent&gt;::extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classvctr_1_1Array.html">vctr::Array</a>&lt; ElementType, extent, storageExtent &gt;::Array </td>
          <td>(</td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>initialValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> with all elements initialised to initialValue. </p>

</div>
</div>
<a id="a16c8292d5f832e80ddb0b085b308ef30" name="a16c8292d5f832e80ddb0b085b308ef30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c8292d5f832e80ddb0b085b308ef30">&#9670;&#160;</a></span>Array() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , size_t extent, size_t storageExtent = detail::StorageExtent&lt;ElementType, extent&gt;::extent&gt; </div>
<div class="memtemplate">
template&lt;std::convertible_to&lt; ElementType &gt; T&gt; <br />
requires (extent == 1)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classvctr_1_1Array.html">vctr::Array</a>&lt; ElementType, extent, storageExtent &gt;::Array </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>initialValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> with extent 1 from an initial value. </p>

</div>
</div>
<a id="a219bef59c3f29f34b8635ea21009448e" name="a219bef59c3f29f34b8635ea21009448e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219bef59c3f29f34b8635ea21009448e">&#9670;&#160;</a></span>Array() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , size_t extent, size_t storageExtent = detail::StorageExtent&lt;ElementType, extent&gt;::extent&gt; </div>
<div class="memtemplate">
template&lt;is::suitableInitializerForElementType&lt; ElementType &gt;... T&gt; <br />
requires (sizeof...(T) &gt; 1)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classvctr_1_1Array.html">vctr::Array</a>&lt; ElementType, extent, storageExtent &gt;::Array </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>initialValues</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> from a list of at least two initial values. </p>

</div>
</div>
<a id="a12663c821da364018f0601094452e7ab" name="a12663c821da364018f0601094452e7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12663c821da364018f0601094452e7ab">&#9670;&#160;</a></span>Array() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , size_t extent, size_t storageExtent = detail::StorageExtent&lt;ElementType, extent&gt;::extent&gt; </div>
<div class="memtemplate">
template&lt;class OtherElementType , size_t otherSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classvctr_1_1Array.html">vctr::Array</a>&lt; ElementType, extent, storageExtent &gt;::Array </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; OtherElementType, otherSize &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> by moving a std::array into it. </p>

</div>
</div>
<a id="a3eaf7f17f4ec7b84e68b69c47f17b5d7" name="a3eaf7f17f4ec7b84e68b69c47f17b5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eaf7f17f4ec7b84e68b69c47f17b5d7">&#9670;&#160;</a></span>Array() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , size_t extent, size_t storageExtent = detail::StorageExtent&lt;ElementType, extent&gt;::extent&gt; </div>
<div class="memtemplate">
template&lt;is::triviallyCopyableWithDataAndSize OtherContainer&gt; <br />
requires (std::same_as&lt;value_type, <a class="el" href="namespacevctr.html#a83a43fd917a646b18b60be7e88becc33">ValueType</a>&lt;OtherContainer&gt;&gt; &amp;&amp; ! std::same_as&lt;<a class="el" href="classvctr_1_1Array.html">Array</a>, OtherContainer&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classvctr_1_1Array.html">vctr::Array</a>&lt; ElementType, extent, storageExtent &gt;::Array </td>
          <td>(</td>
          <td class="paramtype">const OtherContainer &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This constructor will create an <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> instance of the same size as OtherContainer and will copy its values into this <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a>. </p>
<p>OtherContainer has to satisfy triviallyCopyableWithDataAndSize, that is</p><ul>
<li>Its elements are trivially copyable</li>
<li>It supplies a <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> member function returning the number of elements</li>
<li>It supplies a <a class="el" href="classvctr_1_1VctrBase.html#a776a0a4f16ecc3c25f5a1e2eac1d094b" title="Returns a raw pointer to the underlying storage.">data()</a> member function returning a raw pointer to the storage</li>
<li>It supplies an operator[] returning the nth element </li>
</ul>

</div>
</div>
<a id="afcb666532509923815c06a593a2ba7b9" name="afcb666532509923815c06a593a2ba7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb666532509923815c06a593a2ba7b9">&#9670;&#160;</a></span>Array() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , size_t extent, size_t storageExtent = detail::StorageExtent&lt;ElementType, extent&gt;::extent&gt; </div>
<div class="memtemplate">
template&lt;is::iteratorCopyable OtherContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classvctr_1_1Array.html">vctr::Array</a>&lt; ElementType, extent, storageExtent &gt;::Array </td>
          <td>(</td>
          <td class="paramtype">const OtherContainer &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This constructor will create an <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> instance of the same size as OtherContainer and will copy its values into this <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a>. </p>
<p>OtherContainer has to satisfy iteratorCopyable, that is</p><ul>
<li>It supplies a <a class="el" href="classvctr_1_1VctrBase.html#a4d62467d4d84cd6e7fd185f73cf24033" title="Returns an iterator to the begin of the storage.">begin()</a> and <a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf" title="Returns an iterator to the first element behind the storage.">end()</a> member function returning iterators</li>
<li>It must not satisfy triviallyCopyableWithDataAndSize </li>
</ul>

</div>
</div>
<a id="aeea1bd962c51bd20de9777f75d3d0ab6" name="aeea1bd962c51bd20de9777f75d3d0ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea1bd962c51bd20de9777f75d3d0ab6">&#9670;&#160;</a></span>Array() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , size_t extent, size_t storageExtent = detail::StorageExtent&lt;ElementType, extent&gt;::extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classvctr_1_1Array.html">vctr::Array</a>&lt; ElementType, extent, storageExtent &gt;::Array </td>
          <td>(</td>
          <td class="paramtype">const ElementType *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies size elements from the memory location pointed to by data. </p>

</div>
</div>
<a id="a448c1fede9201acb6820edc79b584168" name="a448c1fede9201acb6820edc79b584168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448c1fede9201acb6820edc79b584168">&#9670;&#160;</a></span>Array() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , size_t extent, size_t storageExtent = detail::StorageExtent&lt;ElementType, extent&gt;::extent&gt; </div>
<div class="memtemplate">
template&lt;is::inputIteratorToConstructValuesOfType&lt; ElementType &gt; Iterator, std::sentinel_for&lt; Iterator &gt; Sentinel&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classvctr_1_1Array.html">vctr::Array</a>&lt; ElementType, extent, storageExtent &gt;::Array </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> from an iterator and a sentinel by initialising the <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> with the content read from the iterator. </p>

</div>
</div>
<a id="a1e6586c82c9867fd83561da975269cab" name="a1e6586c82c9867fd83561da975269cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6586c82c9867fd83561da975269cab">&#9670;&#160;</a></span>Array() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , size_t extent, size_t storageExtent = detail::StorageExtent&lt;ElementType, extent&gt;::extent&gt; </div>
<div class="memtemplate">
template&lt;is::suitableInitializerFunctionForElementType&lt; ElementType &gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classvctr_1_1Array.html">vctr::Array</a>&lt; ElementType, extent, storageExtent &gt;::Array </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>initializerFunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a vector of the given size and initialises all elements by calling initializerFunction with the element's index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Fn</td><td>must be a function that takes a size_t argument and returns a suitable element type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a2a944ba41a9239d25743f338487eb0" name="a3a2a944ba41a9239d25743f338487eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2a944ba41a9239d25743f338487eb0">&#9670;&#160;</a></span>Array() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , size_t extent, size_t storageExtent = detail::StorageExtent&lt;ElementType, extent&gt;::extent&gt; </div>
<div class="memtemplate">
template&lt;is::expression Expression&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classvctr_1_1Array.html">vctr::Array</a>&lt; ElementType, extent, storageExtent &gt;::Array </td>
          <td>(</td>
          <td class="paramtype">Expression &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> from an expression template. </p>
<p>In case the expressions extent is non-dynamic, e.g. its sources are Arrays or Spans with a non-dynamic extent, class template argument deduction will work with this constructor. If you are trying to assign an expression with dynamic extent and you know the expected size, a runtime check is performed to figure out if the size matches. Class template argument decuction obviously does not work for those cases. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4c0aa01c4581292b0c61510403841e83" name="a4c0aa01c4581292b0c61510403841e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0aa01c4581292b0c61510403841e83">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::all </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all elements satisfy the predicate or if the container is empty. </p>

</div>
</div>
<a id="aa3e8eb4d0bb4ef2a93441c79f680607c" name="aa3e8eb4d0bb4ef2a93441c79f680607c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e8eb4d0bb4ef2a93441c79f680607c">&#9670;&#160;</a></span>allElementsAreFinite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::allElementsAreFinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all elements are finite. </p>

</div>
</div>
<a id="a73ad88bbdf3ff0b9ae4aabbe5da92c54" name="a73ad88bbdf3ff0b9ae4aabbe5da92c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ad88bbdf3ff0b9ae4aabbe5da92c54">&#9670;&#160;</a></span>allElementsAreFinite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::allElementsAreFinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all elements are finite. </p>

</div>
</div>
<a id="a9cf5f3b3d0920f0ef7b2a9cc09d91f86" name="a9cf5f3b3d0920f0ef7b2a9cc09d91f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf5f3b3d0920f0ef7b2a9cc09d91f86">&#9670;&#160;</a></span>allElementsEqual() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::allElementsEqual </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all elements are equal to themselves. </p>

</div>
</div>
<a id="aaf31bb72d409439360f387914d235757" name="aaf31bb72d409439360f387914d235757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf31bb72d409439360f387914d235757">&#9670;&#160;</a></span>allElementsEqual() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::allElementsEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all elements are equal to value or if the container is empty. </p>

</div>
</div>
<a id="ad9e58cc0b4db47384b4bb9a6b6799ab2" name="ad9e58cc0b4db47384b4bb9a6b6799ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e58cc0b4db47384b4bb9a6b6799ab2">&#9670;&#160;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::any </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if one or more elements satisfy the predicate. </p>

</div>
</div>
<a id="a78509572a38d4dc5ae95c7efaae0ec9d" name="a78509572a38d4dc5ae95c7efaae0ec9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78509572a38d4dc5ae95c7efaae0ec9d">&#9670;&#160;</a></span>anyElementIsNaN() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::anyElementIsNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if any element is NaN. </p>

</div>
</div>
<a id="a25b77066a3a1e469d00c316af2d94322" name="a25b77066a3a1e469d00c316af2d94322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b77066a3a1e469d00c316af2d94322">&#9670;&#160;</a></span>anyElementIsNaN() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::anyElementIsNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if any real or imaginary part of an element is NaN. </p>

</div>
</div>
<a id="a4eed8c702aa74cf5e9fbab436b8a6f20" name="a4eed8c702aa74cf5e9fbab436b8a6f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eed8c702aa74cf5e9fbab436b8a6f20">&#9670;&#160;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; ElementType &gt;&#160;</td>
          <td class="paramname"><em>elements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns elements from the initializer list to this instance. </p>
<p>In case it is a resizable <a class="el" href="classvctr_1_1Vector.html" title="The heap-allocated container type.">Vector</a>, it will be resized to match the size of the list, otherwise the list size must match the destination size. </p>

</div>
</div>
<a id="ac9b345685b9741d1b59ffaaf3bfca3a6" name="ac9b345685b9741d1b59ffaaf3bfca3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b345685b9741d1b59ffaaf3bfca3a6">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto &amp; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to element i. </p>
<p>Throws std::out_of_range if i &gt;= <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> </p>

</div>
</div>
<a id="a8f3c7eabe11604976881266c3f222fb6" name="a8f3c7eabe11604976881266c3f222fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3c7eabe11604976881266c3f222fb6">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto &amp; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to element i. </p>
<p>Throws std::out_of_range if i &gt;= <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> </p>

</div>
</div>
<a id="aa966d96bbeefb5c773194c70a126cbe7" name="aa966d96bbeefb5c773194c70a126cbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa966d96bbeefb5c773194c70a126cbe7">&#9670;&#160;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto &amp;&amp; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element. </p>

</div>
</div>
<a id="ae3e55deac0cab66b4bad8d75bd420c4f" name="ae3e55deac0cab66b4bad8d75bd420c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e55deac0cab66b4bad8d75bd420c4f">&#9670;&#160;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto &amp;&amp; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element. </p>

</div>
</div>
<a id="ab8d10b2c53d0ab60ef0c2f9e97578f8b" name="ab8d10b2c53d0ab60ef0c2f9e97578f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d10b2c53d0ab60ef0c2f9e97578f8b">&#9670;&#160;</a></span>backIdx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::backIdx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index referring to the last element in the vector. </p>
<p>This overload is a non-static function, used in case the extent is dynamic. </p>

</div>
</div>
<a id="a8181b278900a8f16079dcde8750e21d5" name="a8181b278900a8f16079dcde8750e21d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8181b278900a8f16079dcde8750e21d5">&#9670;&#160;</a></span>backIdx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::backIdx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index referring to the last element in the vector. </p>
<p>This overload is a static function, used in case the extent is static. </p>

</div>
</div>
<a id="a4d62467d4d84cd6e7fd185f73cf24033" name="a4d62467d4d84cd6e7fd185f73cf24033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d62467d4d84cd6e7fd185f73cf24033">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the begin of the storage. </p>

</div>
</div>
<a id="ae72810409ab6153d55e6f9afb0743449" name="ae72810409ab6153d55e6f9afb0743449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72810409ab6153d55e6f9afb0743449">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the begin of the storage. </p>

</div>
</div>
<a id="aeca7364ca53cdea690f09329ccb89c36" name="aeca7364ca53cdea690f09329ccb89c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca7364ca53cdea690f09329ccb89c36">&#9670;&#160;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if at least one element is equal to value. </p>

</div>
</div>
<a id="a08ae8625a2045e850b0a0162c1c7f3c3" name="a08ae8625a2045e850b0a0162c1c7f3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ae8625a2045e850b0a0162c1c7f3c3">&#9670;&#160;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::contiguousIteratorWithValueTypeSameAs&lt; ElementType &gt; It&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the iterator refers to an element inside this container or span. </p>
<p>It will return false in case it equals <a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf" title="Returns an iterator to the first element behind the storage.">end()</a>. </p>

</div>
</div>
<a id="a6a8d59c063990c037ff50a7a9e6b3749" name="a6a8d59c063990c037ff50a7a9e6b3749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8d59c063990c037ff50a7a9e6b3749">&#9670;&#160;</a></span>copyFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const ElementType *&#160;</td>
          <td class="paramname"><em>otherData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>otherSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the content from otherData to this instance. </p>
<p>In case the storage of this instance is resizable, it will resize it if necessary. Otherwise, it will simply assert that the size matches. </p>

</div>
</div>
<a id="a03a8ac49770a19c6d3bef9a59ffacbdd" name="a03a8ac49770a19c6d3bef9a59ffacbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a8ac49770a19c6d3bef9a59ffacbdd">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const ElementType &amp;&#160;</td>
          <td class="paramname"><em>valueToLookFor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements that are equal to valueToLookFor. </p>

</div>
</div>
<a id="a5a3203acc6a3098a878819b1e02f00d1" name="a5a3203acc6a3098a878819b1e02f00d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3203acc6a3098a878819b1e02f00d1">&#9670;&#160;</a></span>countIf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::countIf </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements that satisfy predicate. </p>

</div>
</div>
<a id="a776a0a4f16ecc3c25f5a1e2eac1d094b" name="a776a0a4f16ecc3c25f5a1e2eac1d094b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776a0a4f16ecc3c25f5a1e2eac1d094b">&#9670;&#160;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VCTR_FORCEDINLINE constexpr auto * <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a raw pointer to the underlying storage. </p>

</div>
</div>
<a id="a2ed4bae89175ad4f0da54a9d807d2d75" name="a2ed4bae89175ad4f0da54a9d807d2d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed4bae89175ad4f0da54a9d807d2d75">&#9670;&#160;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VCTR_FORCEDINLINE constexpr auto * <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a raw pointer to the underlying storage. </p>

</div>
</div>
<a id="ab71e907a8173889718559fef90a45aed" name="ab71e907a8173889718559fef90a45aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71e907a8173889718559fef90a45aed">&#9670;&#160;</a></span>elementsAreSorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::elementsAreSorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all elements are sorted. </p>

</div>
</div>
<a id="acb907e744177485ef9aaf219b0756b90" name="acb907e744177485ef9aaf219b0756b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb907e744177485ef9aaf219b0756b90">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the container is empty. </p>

</div>
</div>
<a id="ae82f4383edea8be887d6f1617cfa4edf" name="ae82f4383edea8be887d6f1617cfa4edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82f4383edea8be887d6f1617cfa4edf">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element behind the storage. </p>

</div>
</div>
<a id="a8d0117b7f6fc7cd51595146070fa0533" name="a8d0117b7f6fc7cd51595146070fa0533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0117b7f6fc7cd51595146070fa0533">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the first element behind the storage. </p>

</div>
</div>
<a id="ad4a469facc53750163032618d7ec2751" name="ad4a469facc53750163032618d7ec2751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a469facc53750163032618d7ec2751">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the container with the given value. </p>

</div>
</div>
<a id="a13e42070dab5544e39faf3d372913c11" name="a13e42070dab5544e39faf3d372913c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e42070dab5544e39faf3d372913c11">&#9670;&#160;</a></span>fillLinspace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::fillLinspace </td>
          <td>(</td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeEnd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the vector with evenly spaced numbers between start and stop. </p>
<p>Properties:</p><ul>
<li>The length of the vector will not be changed and must be &gt; 0.</li>
<li>If start and stop are identical, the container will be filled with that value.</li>
<li>Ranges can have a negative increment, i.e., start &gt; stop is explicitly allowed.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>First value of the interval; always included. </td></tr>
    <tr><td class="paramname">stop</td><td>Last value of the interval; only included if includeEnd is true. </td></tr>
    <tr><td class="paramname">includeEnd</td><td>If this is true, both start and stop are included; otherwise only start is included. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b32192ab7691ff8e24fe85937df8cfc" name="a3b32192ab7691ff8e24fe85937df8cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b32192ab7691ff8e24fe85937df8cfc">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>valueToLookFor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element that equals valueToLookFor or <a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf" title="Returns an iterator to the first element behind the storage.">end()</a> if none was found. </p>

</div>
</div>
<a id="a457b883bdf44506a49faa497659aa0b4" name="a457b883bdf44506a49faa497659aa0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457b883bdf44506a49faa497659aa0b4">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>valueToLookFor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the first element that equals valueToLookFor or <a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf" title="Returns an iterator to the first element behind the storage.">end()</a> if none was found. </p>

</div>
</div>
<a id="a8a0a138a1344cc551cf44763435213e0" name="a8a0a138a1344cc551cf44763435213e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0a138a1344cc551cf44763435213e0">&#9670;&#160;</a></span>findIf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::findIf </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element in this vector for which predicate returns true or <a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf" title="Returns an iterator to the first element behind the storage.">end()</a> if none was found. </p>

</div>
</div>
<a id="ac30f1790e9e54a5e29bc28118a6bd136" name="ac30f1790e9e54a5e29bc28118a6bd136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30f1790e9e54a5e29bc28118a6bd136">&#9670;&#160;</a></span>findIf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::findIf </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the first element in this vector for which predicate returns true or <a class="el" href="classvctr_1_1VctrBase.html#ae82f4383edea8be887d6f1617cfa4edf" title="Returns an iterator to the first element behind the storage.">end()</a> if none was found. </p>

</div>
</div>
<a id="a9c04176763bb439535383f415e9a1a41" name="a9c04176763bb439535383f415e9a1a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c04176763bb439535383f415e9a1a41">&#9670;&#160;</a></span>findIfReverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::findIfReverse </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the last element in this vector for which predicate returns true or <a class="el" href="classvctr_1_1VctrBase.html#ac3f6fd77a0b41775cbbdddc212a1eb38" title="Returns a reverse iterator to the element before the first element in the storage.">rend()</a> if none was found. </p>

</div>
</div>
<a id="a91b0c83ff87a33d32f08669e39ace236" name="a91b0c83ff87a33d32f08669e39ace236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b0c83ff87a33d32f08669e39ace236">&#9670;&#160;</a></span>findIfReverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::findIfReverse </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the last element in this vector for which predicate returns true or <a class="el" href="classvctr_1_1VctrBase.html#ac3f6fd77a0b41775cbbdddc212a1eb38" title="Returns a reverse iterator to the element before the first element in the storage.">rend()</a> if none was found. </p>

</div>
</div>
<a id="a080fe9d9e226860b48acde1178bb3209" name="a080fe9d9e226860b48acde1178bb3209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080fe9d9e226860b48acde1178bb3209">&#9670;&#160;</a></span>findMaxElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::findMaxElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first greatest element. </p>
<p>Note: If you are only interested in the value of the max element, the <a class="el" href="group__Expressions.html#gab29b54656df0ab50dad4271e1addf2c7" title="Computes the maximum value of the source values.">max()</a> function is a more efficient alternative to that. </p>

</div>
</div>
<a id="a029ddc0c88fbc4aac667bca7f6125348" name="a029ddc0c88fbc4aac667bca7f6125348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029ddc0c88fbc4aac667bca7f6125348">&#9670;&#160;</a></span>findMaxElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::findMaxElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first greatest element. </p>
<p>Note: If you are only interested in the value of the max element, the <a class="el" href="group__Expressions.html#gab29b54656df0ab50dad4271e1addf2c7" title="Computes the maximum value of the source values.">max()</a> function is a more efficient alternative to that. </p>

</div>
</div>
<a id="a2261b01e1400927039586ef3b4be869b" name="a2261b01e1400927039586ef3b4be869b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2261b01e1400927039586ef3b4be869b">&#9670;&#160;</a></span>findMinElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::findMinElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first smallest element. </p>
<p>Note: If you are only interested in the value of the min element, the <a class="el" href="group__Expressions.html#gae77e3e38e1fb46de60f48d2977edc8d5" title="Computes the minimum value of the source values.">min()</a> function is a more efficient alternative to that. </p>

</div>
</div>
<a id="ae24e1fbd352ce351643a5d410179bb8d" name="ae24e1fbd352ce351643a5d410179bb8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24e1fbd352ce351643a5d410179bb8d">&#9670;&#160;</a></span>findMinElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::findMinElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first smallest element. </p>
<p>Note: If you are only interested in the value of the min element, the <a class="el" href="group__Expressions.html#gae77e3e38e1fb46de60f48d2977edc8d5" title="Computes the minimum value of the source values.">min()</a> function is a more efficient alternative to that. </p>

</div>
</div>
<a id="a13389760f277db65b2d08cc058e58e25" name="a13389760f277db65b2d08cc058e58e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13389760f277db65b2d08cc058e58e25">&#9670;&#160;</a></span>findReverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::findReverse </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>valueToLookFor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the last element in this vector that equals valueToLookFor or <a class="el" href="classvctr_1_1VctrBase.html#ac3f6fd77a0b41775cbbdddc212a1eb38" title="Returns a reverse iterator to the element before the first element in the storage.">rend()</a> if none was found. </p>

</div>
</div>
<a id="a684b197edd1baefcbb9db31bfd221faf" name="a684b197edd1baefcbb9db31bfd221faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684b197edd1baefcbb9db31bfd221faf">&#9670;&#160;</a></span>findReverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::findReverse </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>valueToLookFor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the last element in this vector that equals valueToLookFor or <a class="el" href="classvctr_1_1VctrBase.html#ac3f6fd77a0b41775cbbdddc212a1eb38" title="Returns a reverse iterator to the element before the first element in the storage.">rend()</a> if none was found. </p>

</div>
</div>
<a id="a9f8062350f8c34a092da9492372fb170" name="a9f8062350f8c34a092da9492372fb170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8062350f8c34a092da9492372fb170">&#9670;&#160;</a></span>firstValueGreaterThan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::optional&lt; value_type &gt; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::firstValueGreaterThan </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>valueToLookFor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a std::optional holding a copy of the first element value which is greater than valueToLookFor or std::nullopt if no such value is found. </p>
<p>This function requires that the elements are sorted. </p>

</div>
</div>
<a id="abaf31ce8bd7c61d08b1d0a0128d4a94e" name="abaf31ce8bd7c61d08b1d0a0128d4a94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf31ce8bd7c61d08b1d0a0128d4a94e">&#9670;&#160;</a></span>firstValueGreaterThanOrEqualTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::optional&lt; value_type &gt; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::firstValueGreaterThanOrEqualTo </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>valueToLookFor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a std::optional holding a copy of the first element value which is greater or equal to valueToLookFor or std::nullopt if no such value is found. </p>
<p>This function requires that the elements are sorted. </p>

</div>
</div>
<a id="a85f93b4ac09db43de3553fea3194b5fc" name="a85f93b4ac09db43de3553fea3194b5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f93b4ac09db43de3553fea3194b5fc">&#9670;&#160;</a></span>forEach() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; void(value_type &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function on each element. </p>
<p>The function returns void and might take the elements by reference to mutate them. </p>

</div>
</div>
<a id="a85f93b4ac09db43de3553fea3194b5fc" name="a85f93b4ac09db43de3553fea3194b5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f93b4ac09db43de3553fea3194b5fc">&#9670;&#160;</a></span>forEach() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; value_type(const value_type &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function on each element. </p>
<p>The function returns a value_type which is assigned as new value to the element. </p>

</div>
</div>
<a id="a85f93b4ac09db43de3553fea3194b5fc" name="a85f93b4ac09db43de3553fea3194b5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f93b4ac09db43de3553fea3194b5fc">&#9670;&#160;</a></span>forEach() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; void(value_type &amp;, size_t)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function on each element and passes the element index as second function argument. </p>
<p>The function returns void and might take the elements by reference to mutate them. </p>

</div>
</div>
<a id="a85f93b4ac09db43de3553fea3194b5fc" name="a85f93b4ac09db43de3553fea3194b5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f93b4ac09db43de3553fea3194b5fc">&#9670;&#160;</a></span>forEach() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; value_type(const value_type &amp;, size_t)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function on each element and passes the element index as second function argument. </p>
<p>The function returns a value_type which is assigned as new value to the element. </p>

</div>
</div>
<a id="a187a80a3e5380b3b61e666ce3f6d5424" name="a187a80a3e5380b3b61e666ce3f6d5424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187a80a3e5380b3b61e666ce3f6d5424">&#9670;&#160;</a></span>forEach() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; void(const value_type &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function on each element. </p>
<p>The function returns void and must not mutate the elements. </p>

</div>
</div>
<a id="a187a80a3e5380b3b61e666ce3f6d5424" name="a187a80a3e5380b3b61e666ce3f6d5424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187a80a3e5380b3b61e666ce3f6d5424">&#9670;&#160;</a></span>forEach() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; void(const value_type &amp;, size_t)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function on each element and passes the element index as second function argument. </p>
<p>The function returns void and must not mutate the elements. </p>

</div>
</div>
<a id="a62d70bbcdff2fd01c0f555d92467063a" name="a62d70bbcdff2fd01c0f555d92467063a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d70bbcdff2fd01c0f555d92467063a">&#9670;&#160;</a></span>forEach() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args, is::functionWithSignatureOrImplicitlyConvertible&lt; void(value_type &amp;, Args &amp;&amp;...)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fnArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function on each element and forwards fnArgs to the function after the value. </p>
<p>The function returns void and might take the elements by reference to mutate them. </p>

</div>
</div>
<a id="a62d70bbcdff2fd01c0f555d92467063a" name="a62d70bbcdff2fd01c0f555d92467063a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d70bbcdff2fd01c0f555d92467063a">&#9670;&#160;</a></span>forEach() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args, is::functionWithSignatureOrImplicitlyConvertible&lt; value_type(const value_type &amp;, Args &amp;&amp;...)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fnArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function on each element and forwards fnArgs to the function after the value. </p>
<p>The function returns a value_type which is assigned as new value to the element. </p>

</div>
</div>
<a id="ac3a72bd1e6f648eaa2c9780bc560c664" name="ac3a72bd1e6f648eaa2c9780bc560c664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a72bd1e6f648eaa2c9780bc560c664">&#9670;&#160;</a></span>forEach() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args, is::functionWithSignatureOrImplicitlyConvertible&lt; void(const value_type &amp;, Args &amp;&amp;...)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fnArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function on each element and forwards fnArgs to the function after the value. </p>
<p>The function returns void and must not mutate the elements. </p>

</div>
</div>
<a id="aa0b83cec6a9e6b0a5801d45331fefdf4" name="aa0b83cec6a9e6b0a5801d45331fefdf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b83cec6a9e6b0a5801d45331fefdf4">&#9670;&#160;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto &amp;&amp; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element. </p>

</div>
</div>
<a id="a9a5e8a34c7458574ddda43da9cfba433" name="a9a5e8a34c7458574ddda43da9cfba433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5e8a34c7458574ddda43da9cfba433">&#9670;&#160;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto &amp;&amp; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element. </p>

</div>
</div>
<a id="a0dbf4ef57c72393831bc95c2dbddd396" name="a0dbf4ef57c72393831bc95c2dbddd396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dbf4ef57c72393831bc95c2dbddd396">&#9670;&#160;</a></span>getExtent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static consteval size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::getExtent </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>amountToShrink</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the extent of this instance, optionally shrank by a certain amount. </p>
<p>In case the instance specifies a dynamic extent, the return value will always be std::dynamic_extent, no matter if we specified an amount to shrink. In case the instance specifies a static extent, the return value will be extent - amountToShrink. </p>

</div>
</div>
<a id="a82baf69e22b816a5b14994c89889a138" name="a82baf69e22b816a5b14994c89889a138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82baf69e22b816a5b14994c89889a138">&#9670;&#160;</a></span>getNeon()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvctr_1_1NeonRegister.html">NeonRegister</a>&lt; std::remove_const_t&lt; ElementType &gt; &gt; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::getNeon </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates a certain expression in place on this vector, e.g. </p>
<p>it assigns the expression result back to the vector. </p>

</div>
</div>
<a id="aefc631d848a921dbc4222a5890751067" name="aefc631d848a921dbc4222a5890751067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc631d848a921dbc4222a5890751067">&#9670;&#160;</a></span>indexIf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::optional&lt; size_t &gt; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::indexIf </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first element that satisfies the predicate or std::nullopt if none is found. </p>

</div>
</div>
<a id="a13755f0b72bc98a60663e7e90be620cc" name="a13755f0b72bc98a60663e7e90be620cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13755f0b72bc98a60663e7e90be620cc">&#9670;&#160;</a></span>indexIfReverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const ElementType &amp;)&gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::optional&lt; size_t &gt; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::indexIfReverse </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the last element that satisfies the predicate or std::nullopt if none is found. </p>

</div>
</div>
<a id="a88aa485f2931bf79d075b06d132c6df7" name="a88aa485f2931bf79d075b06d132c6df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88aa485f2931bf79d075b06d132c6df7">&#9670;&#160;</a></span>indexOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::optional&lt; size_t &gt; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::indexOf </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first element that compares true to value or std::nullopt if none is found. </p>

</div>
</div>
<a id="abc8f6bb18b8c5fc752c3a3c2440bf589" name="abc8f6bb18b8c5fc752c3a3c2440bf589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8f6bb18b8c5fc752c3a3c2440bf589">&#9670;&#160;</a></span>indexOfMaxElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::indexOfMaxElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first greatest element (aka argMax). </p>

</div>
</div>
<a id="a575932e270e9eb0bb8bf3550cf47acf0" name="a575932e270e9eb0bb8bf3550cf47acf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575932e270e9eb0bb8bf3550cf47acf0">&#9670;&#160;</a></span>indexOfMinElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::indexOfMinElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first smallest element (aka argMin). </p>

</div>
</div>
<a id="a4d7733e55415e624cf6a97fab0cef693" name="a4d7733e55415e624cf6a97fab0cef693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7733e55415e624cf6a97fab0cef693">&#9670;&#160;</a></span>indexOfReverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::equality_comparable_with&lt; ElementType &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::optional&lt; size_t &gt; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::indexOfReverse </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the last element that compares true to value or std::nullopt if none is found. </p>

</div>
</div>
<a id="ac30ee026df44d26087f2b2e5242daabd" name="ac30ee026df44d26087f2b2e5242daabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30ee026df44d26087f2b2e5242daabd">&#9670;&#160;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ElementType <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum value of all elements. </p>

</div>
</div>
<a id="a5928bed9ea669ad2500cdb1dd9346db7" name="a5928bed9ea669ad2500cdb1dd9346db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5928bed9ea669ad2500cdb1dd9346db7">&#9670;&#160;</a></span>maxAbs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ElementType <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::maxAbs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum absolute value of all elements. </p>

</div>
</div>
<a id="ad82b22bb7cf07b3d7441240fd4be96e8" name="ad82b22bb7cf07b3d7441240fd4be96e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82b22bb7cf07b3d7441240fd4be96e8">&#9670;&#160;</a></span>mean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ElementType <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mean value across all elements. </p>

</div>
</div>
<a id="ae8380fd770f1c73e257bb644c9745af0" name="ae8380fd770f1c73e257bb644c9745af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8380fd770f1c73e257bb644c9745af0">&#9670;&#160;</a></span>meanSquare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ElementType <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::meanSquare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mean value across all squared elements. </p>

</div>
</div>
<a id="a3809aad3dbd44783fb9d8b4dbbd97207" name="a3809aad3dbd44783fb9d8b4dbbd97207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3809aad3dbd44783fb9d8b4dbbd97207">&#9670;&#160;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ElementType <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimal value of all elements. </p>

</div>
</div>
<a id="ac2e4d6969b97cb396af2d0a1f31b8b1d" name="ac2e4d6969b97cb396af2d0a1f31b8b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e4d6969b97cb396af2d0a1f31b8b1d">&#9670;&#160;</a></span>minAbs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ElementType <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::minAbs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimal absolute value of all elements. </p>

</div>
</div>
<a id="af9420adec66c33c58a40ecad62c94fdf" name="af9420adec66c33c58a40ecad62c94fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9420adec66c33c58a40ecad62c94fdf">&#9670;&#160;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::anyVctrOrExpression V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies this by a vector or expression in place. </p>

</div>
</div>
<a id="a7d393bcae1044593f341499d7e3ff784" name="a7d393bcae1044593f341499d7e3ff784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d393bcae1044593f341499d7e3ff784">&#9670;&#160;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies this by a constant in place. </p>

</div>
</div>
<a id="a34e6342e4327a648e9b7cf5a2ab46b3d" name="a34e6342e4327a648e9b7cf5a2ab46b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e6342e4327a648e9b7cf5a2ab46b3d">&#9670;&#160;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::anyVctrOrExpression V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a vector or expression to this in place. </p>
<p>In the special case where a multiplication expression is assigned for which none of the operands are expressions themselves, this will try to use accelerated multiply accumulate operations to evaluate the expression.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classvctr_1_1Array.html">vctr::Array&lt;float, 10&gt;</a> a, b, c;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code tries to use an accelerated multiply accumulate operation as it can access the values of a and b right away</span></div>
<div class="line">c += a * b;</div>
<div class="line">c += a * 42.0f;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cannot directly evaluate the accelerated operation as vctr::square (b) would have to be evaluated and stored to</span></div>
<div class="line"><span class="comment">// some temporary memory location first.</span></div>
<div class="line">c += a * <a class="code hl_variable" href="group__Expressions.html#gace331be21cfd6aa9705f5bc0e283e3f9">vctr::square</a> (b);</div>
<div class="ttc" id="aclassvctr_1_1Array_html"><div class="ttname"><a href="classvctr_1_1Array.html">vctr::Array</a></div><div class="ttdoc">The stack-based container type.</div><div class="ttdef"><b>Definition:</b> Array.h:53</div></div>
<div class="ttc" id="agroup__Expressions_html_gace331be21cfd6aa9705f5bc0e283e3f9"><div class="ttname"><a href="group__Expressions.html#gace331be21cfd6aa9705f5bc0e283e3f9">vctr::square</a></div><div class="ttdeci">constexpr ExpressionChainBuilder&lt; expressions::Square &gt; square</div><div class="ttdoc">Squares the source values.</div><div class="ttdef"><b>Definition:</b> Square.h:94</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8a24a9704cd970e3f6430b2e1cd495c0" name="a8a24a9704cd970e3f6430b2e1cd495c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a24a9704cd970e3f6430b2e1cd495c0">&#9670;&#160;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a constant to this in place. </p>

</div>
</div>
<a id="a2f082ed08028aef23fddf52425fb254e" name="a2f082ed08028aef23fddf52425fb254e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f082ed08028aef23fddf52425fb254e">&#9670;&#160;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::anyVctrOrExpression V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts a vector or expression from this in place. </p>

</div>
</div>
<a id="a5d4040fe16ec241401831c8f70781bf1" name="a5d4040fe16ec241401831c8f70781bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4040fe16ec241401831c8f70781bf1">&#9670;&#160;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts a constant from this in place. </p>

</div>
</div>
<a id="a441226b45536b133601da22b47a9ccad" name="a441226b45536b133601da22b47a9ccad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441226b45536b133601da22b47a9ccad">&#9670;&#160;</a></span>operator/=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::anyVctrOrExpression V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides this by a vector or expression in place. </p>

</div>
</div>
<a id="a44993d0d98bdad4d42f7a8522d348574" name="a44993d0d98bdad4d42f7a8522d348574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44993d0d98bdad4d42f7a8522d348574">&#9670;&#160;</a></span>operator/=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides this by a constant in place. </p>

</div>
</div>
<a id="a23a6c644fc5e650be8f608aee7ffbaaf" name="a23a6c644fc5e650be8f608aee7ffbaaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a6c644fc5e650be8f608aee7ffbaaf">&#9670;&#160;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , size_t extent, size_t storageExtent = detail::StorageExtent&lt;ElementType, extent&gt;::extent&gt; </div>
<div class="memtemplate">
template&lt;is::expression E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1Array.html">vctr::Array</a>&lt; ElementType, extent, storageExtent &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>expression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the result of an expression to this vector. </p>
<p>The <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a> has to match the size of the expression. </p>

</div>
</div>
<a id="ac27be2a744655b57b283dca8b093b3a0" name="ac27be2a744655b57b283dca8b093b3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27be2a744655b57b283dca8b093b3a0">&#9670;&#160;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , size_t extent, size_t storageExtent = detail::StorageExtent&lt;ElementType, extent&gt;::extent&gt; </div>
<div class="memtemplate">
template&lt;has::sizeAndDataWithElementType&lt; ElementType &gt; Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classvctr_1_1Array.html">Array</a> &amp; <a class="el" href="classvctr_1_1Array.html">vctr::Array</a>&lt; ElementType, extent, storageExtent &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>containerToCopyDataFrom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies or moves the data of the source container to this <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a>. </p>
<p>You have to ensure that the source size matches. </p>

</div>
</div>
<a id="a6f4c6617d67dc77a490991425a8bb1b1" name="a6f4c6617d67dc77a490991425a8bb1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f4c6617d67dc77a490991425a8bb1b1">&#9670;&#160;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , size_t extent, size_t storageExtent = detail::StorageExtent&lt;ElementType, extent&gt;::extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classvctr_1_1Array.html">Array</a> &amp; <a class="el" href="classvctr_1_1Array.html">vctr::Array</a>&lt; ElementType, extent, storageExtent &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; ElementType &gt;&#160;</td>
          <td class="paramname"><em>elementsToAssign</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns elements from the initializer list to this <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a>. </p>
<p>You have to ensure that the source size matches. </p>

</div>
</div>
<a id="aa689a52afa0d76a308cf176083f731c6" name="aa689a52afa0d76a308cf176083f731c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa689a52afa0d76a308cf176083f731c6">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto &amp; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to element i. </p>
<p>Asserts in debug builds if i &gt;= <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> </p>

</div>
</div>
<a id="a0d921dc0ff2a400920940dfee087ac8d" name="a0d921dc0ff2a400920940dfee087ac8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d921dc0ff2a400920940dfee087ac8d">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto &amp; <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to element i. </p>
<p>Asserts in debug builds if i &gt;= <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> </p>

</div>
</div>
<a id="af982e33f6fa36af4add9f0373bde98a8" name="af982e33f6fa36af4add9f0373bde98a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af982e33f6fa36af4add9f0373bde98a8">&#9670;&#160;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the last element in the storage. </p>

</div>
</div>
<a id="af5dad4052f5d8720bdfb2414ac9b6b75" name="af5dad4052f5d8720bdfb2414ac9b6b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dad4052f5d8720bdfb2414ac9b6b75">&#9670;&#160;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the last element in the storage. </p>

</div>
</div>
<a id="ac3f6fd77a0b41775cbbdddc212a1eb38" name="ac3f6fd77a0b41775cbbdddc212a1eb38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f6fd77a0b41775cbbdddc212a1eb38">&#9670;&#160;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element before the first element in the storage. </p>

</div>
</div>
<a id="aa539547c92850b3e14f2067afd070c4b" name="aa539547c92850b3e14f2067afd070c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa539547c92850b3e14f2067afd070c4b">&#9670;&#160;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the element before the first element in the storage. </p>

</div>
</div>
<a id="a9c46dbf4c7e9584c2d4bc2e627aa3ee6" name="a9c46dbf4c7e9584c2d4bc2e627aa3ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c46dbf4c7e9584c2d4bc2e627aa3ee6">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the order of all elements. </p>

</div>
</div>
<a id="a9b9ca4b0cc5d3894ff875bcc0a1fd431" name="a9b9ca4b0cc5d3894ff875bcc0a1fd431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9ca4b0cc5d3894ff875bcc0a1fd431">&#9670;&#160;</a></span>rms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ElementType <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::rms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the square root of the mean value across all squared elements. </p>

</div>
</div>
<a id="a17c6ce671353756da7465f3def164f10" name="a17c6ce671353756da7465f3def164f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c6ce671353756da7465f3def164f10">&#9670;&#160;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::rotate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newFirstElementIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotates the elements so that the element with the index newFirstElementIdx becomes the first element and the element with the index newFirstElementIdx - 1 becomes the last element. </p>

</div>
</div>
<a id="af4204c2b21ab30ea9a78e1c30f76111b" name="af4204c2b21ab30ea9a78e1c30f76111b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4204c2b21ab30ea9a78e1c30f76111b">&#9670;&#160;</a></span>shiftLeft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::shiftLeft </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearFreeSpaceAfterShiftedRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts all elements to the left by n. </p>
<p>In other words: It shifts the elements so that the element with the index n becomes the first element. If clearFreeSpaceAfterShiftedRegion is true, it clears all elements behind the shifted region by setting the memory to 0, otherwise it leaves that region as it was. For maximum efficiency, this works on a raw memory basis, so the elements have to be trivially copyable. </p>

</div>
</div>
<a id="a00b7cafbc190e73f31fbb191de2354e0" name="a00b7cafbc190e73f31fbb191de2354e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b7cafbc190e73f31fbb191de2354e0">&#9670;&#160;</a></span>shiftRight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::shiftRight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearFreeSpaceBeforeShiftedRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts all elements to the right by n. </p>
<p>In other words: It shifts the elements so that the previous first element now is the element with the index n. If clearFreeSpaceBeforeShiftedRegion is true, it clears all elements before the shifted region by setting the memory to 0, otherwise it leaves that region as it was. For maximum efficiency, this works on a raw memory basis, so the elements have to be trivially copyable. </p>

</div>
</div>
<a id="a0ec564aacdb2c8a90604e4fa142404ed" name="a0ec564aacdb2c8a90604e4fa142404ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec564aacdb2c8a90604e4fa142404ed">&#9670;&#160;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements. </p>
<p>This overload is a non-static function, used in case the extent is dynamic. </p>

</div>
</div>
<a id="ae83870ea4a869114785266ee2fab1598" name="ae83870ea4a869114785266ee2fab1598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83870ea4a869114785266ee2fab1598">&#9670;&#160;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements. </p>
<p>This overload is a static function, used in case the extent is static. </p>

</div>
</div>
<a id="a681a9fa9e731497b3cdfc9752c091c9b" name="a681a9fa9e731497b3cdfc9752c091c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681a9fa9e731497b3cdfc9752c091c9b">&#9670;&#160;</a></span>sizeInBytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::sizeInBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container size in bytes. </p>
<p>This overload is a non-static function, used in case the extent is dynamic. </p>

</div>
</div>
<a id="a4612236989c7950e0d69917a007f6b79" name="a4612236989c7950e0d69917a007f6b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4612236989c7950e0d69917a007f6b79">&#9670;&#160;</a></span>sizeInBytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_t <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::sizeInBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the container size in bytes. </p>
<p>This overload is a static function, used in case the extent is static. </p>

</div>
</div>
<a id="a60ceab7317b693f9f763be9e74fc87d6" name="a60ceab7317b693f9f763be9e74fc87d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ceab7317b693f9f763be9e74fc87d6">&#9670;&#160;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts all elements in an ascending order using operator &lt;=&gt;. </p>

</div>
</div>
<a id="a09242aefc7ce2ef77ed27b6a0551552b" name="a09242aefc7ce2ef77ed27b6a0551552b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09242aefc7ce2ef77ed27b6a0551552b">&#9670;&#160;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;is::functionWithSignatureOrImplicitlyConvertible&lt; bool(const value_type &amp;, const value_type &amp;)&gt; ComparatorFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">ComparatorFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts all elements in this vector according to the compare function. </p>
<p>The compare function should receive true if the first argument is less than the second argument. </p>

</div>
</div>
<a id="a29d9c9c2d8cd0874aecc6f6ee17dfa66" name="a29d9c9c2d8cd0874aecc6f6ee17dfa66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d9c9c2d8cd0874aecc6f6ee17dfa66">&#9670;&#160;</a></span>subSpan() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;size_t startIdx&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::subSpan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> - startIdx. </p>
<p>This overload with a compile time static index will return a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> with a static extent in case this instance also has a static extent. </p>

</div>
</div>
<a id="a828d59afc6a87d40566840ffde8a6a50" name="a828d59afc6a87d40566840ffde8a6a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828d59afc6a87d40566840ffde8a6a50">&#9670;&#160;</a></span>subSpan() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;size_t startIdx, size_t numElements&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::subSpan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of numElements. </p>
<p>This overload with a compile time static length will always return a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> with a static extent. </p>

</div>
</div>
<a id="a8a1180d252ae45809e7150458345c93e" name="a8a1180d252ae45809e7150458345c93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1180d252ae45809e7150458345c93e">&#9670;&#160;</a></span>subSpan() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;size_t startIdx&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::subSpan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> - startIdx. </p>
<p>This overload with a compile time static index will return a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> with a static extent in case this instance also has a static extent. </p>

</div>
</div>
<a id="a214960993f1d15ed248de6382ae16b0e" name="a214960993f1d15ed248de6382ae16b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214960993f1d15ed248de6382ae16b0e">&#9670;&#160;</a></span>subSpan() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<div class="memtemplate">
template&lt;size_t startIdx, size_t numElements&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::subSpan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of numElements. </p>
<p>This overload with a compile time static length will always return a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> with a static extent. </p>

</div>
</div>
<a id="a8e737d53237f32af2685faa02ae26d55" name="a8e737d53237f32af2685faa02ae26d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e737d53237f32af2685faa02ae26d55">&#9670;&#160;</a></span>subSpan() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::subSpan </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> - startIdx. </p>
<p>This overload with a runtime defined index will always return a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> with a dynamic extent. </p>

</div>
</div>
<a id="a2bc30017f36afa555e69770aadbb5fb2" name="a2bc30017f36afa555e69770aadbb5fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc30017f36afa555e69770aadbb5fb2">&#9670;&#160;</a></span>subSpan() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::subSpan </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of <a class="el" href="classvctr_1_1VctrBase.html#ae83870ea4a869114785266ee2fab1598" title="Returns the number of elements.">size()</a> - startIdx. </p>
<p>This overload with a runtime defined index will always return a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> with a dynamic extent. </p>

</div>
</div>
<a id="a5ccea594565f121e340eb85db5ff972f" name="a5ccea594565f121e340eb85db5ff972f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ccea594565f121e340eb85db5ff972f">&#9670;&#160;</a></span>subSpan() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::subSpan </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of numElements. </p>
<p>This overload with a runtime defined length will always return a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> with a dynamic extent. </p>

</div>
</div>
<a id="a4ebddf025d6d6fb9bc5deb44b4c9ca3c" name="a4ebddf025d6d6fb9bc5deb44b4c9ca3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ebddf025d6d6fb9bc5deb44b4c9ca3c">&#9670;&#160;</a></span>subSpan() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::subSpan </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> that views a portion of this instance, starting at startIdx with a length of numElements. </p>
<p>This overload with a runtime defined length will always return a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> with a dynamic extent. </p>

</div>
</div>
<a id="add5f3def86f5ab26a70456c779a91d9d" name="add5f3def86f5ab26a70456c779a91d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5f3def86f5ab26a70456c779a91d9d">&#9670;&#160;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , class StorageType , size_t extent, class <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>  = StorageInfo&lt;StorageType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ElementType <a class="el" href="classvctr_1_1VctrBase.html">vctr::VctrBase</a>&lt; ElementType, StorageType, extent, <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> &gt;::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sum of all elements. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/vctr/Containers/<a class="el" href="Array_8h_source.html">Array.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacevctr.html">vctr</a></li><li class="navelem"><a class="el" href="classvctr_1_1Array.html">Array</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
