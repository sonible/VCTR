<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VCTR: vctr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="sonible_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">VCTR
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacevctr.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">vctr Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The main namespace of the VCTR project.  
<a href="namespacevctr.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacevctr_1_1juce__helpers"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevctr_1_1juce__helpers.html">juce_helpers</a></td></tr>
<tr class="memdesc:namespacevctr_1_1juce__helpers"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions to integrate vctr into dsp code written with JUCE (<a href="https://github.com/juce-framework/JUCE">https://github.com/juce-framework/JUCE</a>). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1AlignedAllocator.html">AlignedAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns aligned pointers when allocations are requested.  <a href="classvctr_1_1AlignedAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stack-based container type.  <a href="classvctr_1_1Array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1AVXRegister.html">AVXRegister</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1CombinedStorageInfo.html">CombinedStorageInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1CombinedStorageInfo_3_01InfoA_00_01InfoB_01_4.html">CombinedStorageInfo&lt; InfoA, InfoB &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1Config.html">Config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1Constant.html">Constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple helper struct to pass a constant as argument wrapped in a struct with a single public static constexpr member variable named value.  <a href="structvctr_1_1Constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1dBFS.html">dBFS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decibel constant dbFS to be passed to dbToMag or magToDb.  <a href="structvctr_1_1dBFS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1dBPower.html">dBPower</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decibel constant dbPower to be passed to dbToMag or magToDb.  <a href="structvctr_1_1dBPower.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1dBVoltage.html">dBVoltage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decibel constant dbVoltage to be passed to dbToMag or magToDb.  <a href="structvctr_1_1dBVoltage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1DefaultVectorAllocator.html">DefaultVectorAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default allocator choice for non-arithmetic types is a simple std::allocator.  <a href="structvctr_1_1DefaultVectorAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1DefaultVectorAllocator_3_01ElementType_01_4.html">DefaultVectorAllocator&lt; ElementType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default allocator choice for arithmetic types is an <a class="el" href="classvctr_1_1AlignedAllocator.html" title="Returns aligned pointers when allocations are requested.">AlignedAllocator</a>.  <a href="structvctr_1_1DefaultVectorAllocator_3_01ElementType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1DisabledConstant.html">DisabledConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper struct to indicate that a constant template should be considered disabled.  <a href="structvctr_1_1DisabledConstant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1ExpressionChainBuilderWithRuntimeArgs.html">ExpressionChainBuilderWithRuntimeArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An expression chain builder is an object which supplies various operator&lt;&lt; overloads which build chains of Expression Templates by prepending the templated ExpressionType to the source.  <a href="structvctr_1_1ExpressionChainBuilderWithRuntimeArgs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1ExpressionTemplateBase.html">ExpressionTemplateBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class to every expression template.  <a href="structvctr_1_1ExpressionTemplateBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1NeonRegister.html">NeonRegister</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1OwnedArray.html">OwnedArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handy shortcut for <a class="el" href="classvctr_1_1Array.html" title="The stack-based container type.">Array</a>&lt;std::unique_ptr&lt;OwnedElementType&gt;, n&gt;.  <a href="classvctr_1_1OwnedArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1OwnedVector.html">OwnedVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handy shortcut for <a class="el" href="classvctr_1_1Vector.html">Vector&lt;std::unique_ptr&lt;OwnedElementType&gt;&gt;</a>.  <a href="classvctr_1_1OwnedVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple range class.  <a href="classvctr_1_1Range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1ReductionExpression.html">ReductionExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of static functions used to evaluate reduction expressions.  <a href="classvctr_1_1ReductionExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1RequireConstexpr.html">RequireConstexpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper struct intended to check if a value is a constexpr.  <a href="structvctr_1_1RequireConstexpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Span.html">Span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The view type.  <a href="classvctr_1_1Span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1SSERegister.html">SSERegister</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1StaticStorageInfo.html">StaticStorageInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A storage info type especially used to pass compile time constant traits when viewing externally owned memory via a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> in case we know that the viewed memory will fulfil certain traits.  <a href="structvctr_1_1StaticStorageInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1StorageInfo.html">StorageInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to describe some properties regarding the storage class wrapped in a <a class="el" href="classvctr_1_1VctrBase.html" title="The base class to all one dimensional containers and views in the VCTR project.">VctrBase</a> instance.  <a href="structvctr_1_1StorageInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>StorageInfo&lt; detail::VectorBoolWorkaround&lt; Allocator &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1StorageInfo_3_01std_1_1array_3_01ElementType_00_01size_01_4_01_4.html">StorageInfo&lt; std::array&lt; ElementType, size &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1StorageInfo_3_01std_1_1vector_3_01ElementType_00_01AlignedAllocator_3_01ElementTypb1ff9125abc35bf2a038ab1c1b675ea6.html">StorageInfo&lt; std::vector&lt; ElementType, AlignedAllocator&lt; ElementType, alignmentInBytes &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1StorageInfo_3_01StorageType_01_4.html">StorageInfo&lt; StorageType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvctr_1_1StorageInfoWithMemberAlignment.html">StorageInfoWithMemberAlignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A storage info type especially used for <a class="el" href="classvctr_1_1Span.html" title="The view type.">vctr::Span</a>.  <a href="structvctr_1_1StorageInfoWithMemberAlignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1VctrBase.html">VctrBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class to all one dimensional containers and views in the VCTR project.  <a href="classvctr_1_1VctrBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvctr_1_1Vector.html">Vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The heap-allocated container type.  <a href="classvctr_1_1Vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a40c9f56937ddfca3c1b85f5f52627deb"><td class="memTemplParams" colspan="2">template&lt;template&lt; size_t, class... &gt; class ExpressionType, class... AdditionalCompileTimeParameters&gt; </td></tr>
<tr class="memitem:a40c9f56937ddfca3c1b85f5f52627deb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a> = <a class="el" href="structvctr_1_1ExpressionChainBuilderWithRuntimeArgs.html">ExpressionChainBuilderWithRuntimeArgs</a>&lt; ExpressionType, detail::RuntimeArgChain&lt; std::tuple&lt;&gt; &gt;, AdditionalCompileTimeParameters... &gt;</td></tr>
<tr class="memdesc:a40c9f56937ddfca3c1b85f5f52627deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient typedef to create a simple expression chain builder instance for an expression template.  <br /></td></tr>
<tr class="separator:a40c9f56937ddfca3c1b85f5f52627deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a43fd917a646b18b60be7e88becc33"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a83a43fd917a646b18b60be7e88becc33"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevctr.html#a83a43fd917a646b18b60be7e88becc33">ValueType</a> = typename detail::ValueType&lt; std::remove_cvref_t&lt; T &gt; &gt;::Type</td></tr>
<tr class="memdesc:a83a43fd917a646b18b60be7e88becc33"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an expression template, it equals its return type, if it's a type that defines value_type as a public typedef, it equals value_type.  <br /></td></tr>
<tr class="separator:a83a43fd917a646b18b60be7e88becc33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3cbb6dc6bd6736802f5a7537b8dfb62"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad3cbb6dc6bd6736802f5a7537b8dfb62"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevctr.html#ad3cbb6dc6bd6736802f5a7537b8dfb62">DataType</a> = typename detail::DataType&lt; std::remove_reference_t&lt; T &gt; &gt;::Type</td></tr>
<tr class="memdesc:ad3cbb6dc6bd6736802f5a7537b8dfb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const correct element type derived from a call to T::data.  <br /></td></tr>
<tr class="separator:ad3cbb6dc6bd6736802f5a7537b8dfb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf99aea4bbfba08d526a19614f28516"><td class="memTemplParams" colspan="2">template&lt;is::number T&gt; </td></tr>
<tr class="memitem:abbf99aea4bbfba08d526a19614f28516"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevctr.html#abbf99aea4bbfba08d526a19614f28516">RealType</a> = typename detail::RealType&lt; std::remove_cvref_t&lt; T &gt; &gt;::Type</td></tr>
<tr class="memdesc:abbf99aea4bbfba08d526a19614f28516"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is any instance of std::complex, this will be the real value_type, otherwise this will be T.  <br /></td></tr>
<tr class="separator:abbf99aea4bbfba08d526a19614f28516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10a74a826089c483c4eb7feb374f09f"><td class="memTemplParams" colspan="2">template&lt;is::realNumber T&gt; </td></tr>
<tr class="memitem:aa10a74a826089c483c4eb7feb374f09f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevctr.html#aa10a74a826089c483c4eb7feb374f09f">FloatType</a> = typename detail::FloatType&lt; std::remove_cvref_t&lt; T &gt; &gt;::Type</td></tr>
<tr class="memdesc:aa10a74a826089c483c4eb7feb374f09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The best matching float type for the real number type T.  <br /></td></tr>
<tr class="separator:aa10a74a826089c483c4eb7feb374f09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222cc9e4338c24b2f0751c132503ce3a"><td class="memTemplParams" colspan="2">template&lt;has::sizeAndData T&gt; </td></tr>
<tr class="memitem:a222cc9e4338c24b2f0751c132503ce3a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a> = typename detail::StorageInfoType&lt; std::remove_cvref_t&lt; T &gt; &gt;::Type</td></tr>
<tr class="memdesc:a222cc9e4338c24b2f0751c132503ce3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If t is a type derived from <a class="el" href="classvctr_1_1VctrBase.html" title="The base class to all one dimensional containers and views in the VCTR project.">VctrBase</a>, this will equal the return value of T::getStorageInfo, otherwise this will be StorageInfo&lt;T&gt;.  <br /></td></tr>
<tr class="separator:a222cc9e4338c24b2f0751c132503ce3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a49c8e2687aa55e0477e6aff04c3c543b"><td class="memItemLeft" align="right" valign="top"><a id="a49c8e2687aa55e0477e6aff04c3c543b" name="a49c8e2687aa55e0477e6aff04c3c543b"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>CPUInstructionSet</b> { <br />
&#160;&#160;<b>sse4_1</b>
, <b>avx</b>
, <b>avx2</b>
, <b>neon</b>
, <br />
&#160;&#160;<b>fallback</b>
<br />
 }</td></tr>
<tr class="separator:a49c8e2687aa55e0477e6aff04c3c543b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9971cf366f6407a787a05c3fdd414111"><td class="memTemplParams" colspan="2"><a id="a9971cf366f6407a787a05c3fdd414111" name="a9971cf366f6407a787a05c3fdd414111"></a>
template&lt;class OtherElementType , size_t otherSize&gt; </td></tr>
<tr class="memitem:a9971cf366f6407a787a05c3fdd414111"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Array</b> (std::array&lt; OtherElementType, otherSize &gt; &amp;&amp;) -&gt; <a class="el" href="classvctr_1_1Array.html">Array</a>&lt; OtherElementType, otherSize, otherSize &gt;</td></tr>
<tr class="separator:a9971cf366f6407a787a05c3fdd414111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d4228a3433864e7cb10d32af5d7c5b"><td class="memTemplParams" colspan="2"><a id="a69d4228a3433864e7cb10d32af5d7c5b" name="a69d4228a3433864e7cb10d32af5d7c5b"></a>
template&lt;class First , is::suitableInitializerForElementType&lt; std::remove_cvref_t&lt; First &gt; &gt;... Other&gt; </td></tr>
<tr class="memitem:a69d4228a3433864e7cb10d32af5d7c5b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Array</b> (First &amp;&amp;, Other &amp;&amp;...) -&gt; <a class="el" href="classvctr_1_1Array.html">Array</a>&lt; std::remove_cvref_t&lt; First &gt;, sizeof...(Other)+1 &gt;</td></tr>
<tr class="separator:a69d4228a3433864e7cb10d32af5d7c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c52f752eac59f161cba0c5ee33c3e0"><td class="memTemplParams" colspan="2"><a id="ad9c52f752eac59f161cba0c5ee33c3e0" name="ad9c52f752eac59f161cba0c5ee33c3e0"></a>
template&lt;class SingleArg &gt; </td></tr>
<tr class="memitem:ad9c52f752eac59f161cba0c5ee33c3e0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Array</b> (SingleArg &amp;&amp;) -&gt; <a class="el" href="classvctr_1_1Array.html">Array</a>&lt; typename detail::SingleArgDeductionHelper&lt; SingleArg &gt;::Type, detail::SingleArgDeductionHelper&lt; SingleArg &gt;::extent &gt;</td></tr>
<tr class="separator:ad9c52f752eac59f161cba0c5ee33c3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af540982ade5f6a808dae856d0cd5180c"><td class="memTemplParams" colspan="2"><a id="af540982ade5f6a808dae856d0cd5180c" name="af540982ade5f6a808dae856d0cd5180c"></a>
template&lt;class Pointer , std::same_as&lt; Pointer &gt;... Pointers&gt; </td></tr>
<tr class="memitem:af540982ade5f6a808dae856d0cd5180c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>OwnedArray</b> (Pointer *, Pointers *...) -&gt; <a class="el" href="classvctr_1_1OwnedArray.html">OwnedArray</a>&lt; Pointer, sizeof...(Pointers)+1 &gt;</td></tr>
<tr class="separator:af540982ade5f6a808dae856d0cd5180c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0c57eb1dc57e153788f2a8631ed6a6"><td class="memTemplParams" colspan="2">template&lt;class ElementType &gt; </td></tr>
<tr class="memitem:abb0c57eb1dc57e153788f2a8631ed6a6"><td class="memTemplItemLeft" align="right" valign="top">consteval auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevctr.html#abb0c57eb1dc57e153788f2a8631ed6a6">simdAlignedSpanStorageInfo</a> ()</td></tr>
<tr class="memdesc:abb0c57eb1dc57e153788f2a8631ed6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="structvctr_1_1StaticStorageInfo.html" title="A storage info type especially used to pass compile time constant traits when viewing externally owne...">StaticStorageInfo</a> instance suitable to be passed to a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> constructor.  <br /></td></tr>
<tr class="separator:abb0c57eb1dc57e153788f2a8631ed6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4a1b8aeba8647ce5b8d1196fd9be23"><td class="memTemplParams" colspan="2"><a id="a8f4a1b8aeba8647ce5b8d1196fd9be23" name="a8f4a1b8aeba8647ce5b8d1196fd9be23"></a>
template&lt;class ElementType , bool isDataSIMDAligned, bool isStorageSIMDExtended&gt; </td></tr>
<tr class="memitem:a8f4a1b8aeba8647ce5b8d1196fd9be23"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Span</b> (ElementType *, size_t, const <a class="el" href="structvctr_1_1StaticStorageInfo.html">StaticStorageInfo</a>&lt; isDataSIMDAligned, isStorageSIMDExtended, alignof(std::span&lt; ElementType &gt;)&gt; &amp;) -&gt; <a class="el" href="classvctr_1_1Span.html">Span</a>&lt; ElementType, std::dynamic_extent, <a class="el" href="structvctr_1_1StaticStorageInfo.html">StaticStorageInfo</a>&lt; isDataSIMDAligned, isStorageSIMDExtended, alignof(std::span&lt; ElementType &gt;)&gt; &gt;</td></tr>
<tr class="separator:a8f4a1b8aeba8647ce5b8d1196fd9be23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258aa32930d21e7c25e889f50c0337af"><td class="memTemplParams" colspan="2"><a id="a258aa32930d21e7c25e889f50c0337af" name="a258aa32930d21e7c25e889f50c0337af"></a>
template&lt;class Container &gt; </td></tr>
<tr class="memitem:a258aa32930d21e7c25e889f50c0337af"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Span</b> (Container &amp;&amp;) -&gt; <a class="el" href="classvctr_1_1Span.html">Span</a>&lt; <a class="el" href="namespacevctr.html#ad3cbb6dc6bd6736802f5a7537b8dfb62">DataType</a>&lt; Container &gt;, <a class="el" href="namespacevctr.html#a0e2879d4e781cb85ff0ae8cf4f1deefd">extentOf</a>&lt; Container &gt;, <a class="el" href="structvctr_1_1StorageInfoWithMemberAlignment.html">StorageInfoWithMemberAlignment</a>&lt; alignof(std::span&lt; <a class="el" href="namespacevctr.html#ad3cbb6dc6bd6736802f5a7537b8dfb62">DataType</a>&lt; Container &gt;, <a class="el" href="namespacevctr.html#a0e2879d4e781cb85ff0ae8cf4f1deefd">extentOf</a>&lt; Container &gt; &gt;), <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">StorageInfoType</a>&lt; Container &gt; &gt; &gt;</td></tr>
<tr class="separator:a258aa32930d21e7c25e889f50c0337af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0f84cd9c134342df3b80ca8e067aab"><td class="memTemplParams" colspan="2"><a id="a6d0f84cd9c134342df3b80ca8e067aab" name="a6d0f84cd9c134342df3b80ca8e067aab"></a>
template&lt;class ElementType , size_t size&gt; </td></tr>
<tr class="memitem:a6d0f84cd9c134342df3b80ca8e067aab"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Span</b> (ElementType(&amp;)[size]) -&gt; <a class="el" href="classvctr_1_1Span.html">Span</a>&lt; ElementType, size, <a class="el" href="structvctr_1_1StorageInfoWithMemberAlignment.html">StorageInfoWithMemberAlignment</a>&lt; alignof(std::span&lt; ElementType, size &gt;), <a class="el" href="structvctr_1_1StorageInfo.html">StorageInfo</a>&lt; std::span&lt; ElementType, size &gt; &gt; &gt; &gt;</td></tr>
<tr class="separator:a6d0f84cd9c134342df3b80ca8e067aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7c9ccef500aff1ca7881f2e1904408"><td class="memTemplParams" colspan="2">template&lt;class ElementType &gt; </td></tr>
<tr class="memitem:a5e7c9ccef500aff1ca7881f2e1904408"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevctr.html#a5e7c9ccef500aff1ca7881f2e1904408">makeSimdAlignedSpan</a> (ElementType *data, size_t size)</td></tr>
<tr class="memdesc:a5e7c9ccef500aff1ca7881f2e1904408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a span with dynamic extent pointing to a memory location that is expected to be SIMD aligned.  <br /></td></tr>
<tr class="separator:a5e7c9ccef500aff1ca7881f2e1904408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946767da5d097bc029825bba6c2a2595"><td class="memTemplParams" colspan="2">template&lt;size_t extent, class ElementType &gt; <br />
requires (extent != std::dynamic_extent)</td></tr>
<tr class="memitem:a946767da5d097bc029825bba6c2a2595"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevctr.html#a946767da5d097bc029825bba6c2a2595">makeSimdAlignedSpan</a> (ElementType *data)</td></tr>
<tr class="memdesc:a946767da5d097bc029825bba6c2a2595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a span with static extent pointing to a memory location that is expected to be SIMD aligned.  <br /></td></tr>
<tr class="separator:a946767da5d097bc029825bba6c2a2595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90149542071c83fddeb04c75e9cfd3a"><td class="memTemplParams" colspan="2">template&lt;is::anyVctr Lhs, is::anyVctr Rhs&gt; <br />
requires std::same_as&lt;<a class="el" href="namespacevctr.html#a83a43fd917a646b18b60be7e88becc33">ValueType</a>&lt;Lhs&gt;, <a class="el" href="namespacevctr.html#a83a43fd917a646b18b60be7e88becc33">ValueType</a>&lt;Rhs&gt;&gt;</td></tr>
<tr class="memitem:af90149542071c83fddeb04c75e9cfd3a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevctr.html#af90149542071c83fddeb04c75e9cfd3a">operator==</a> (const Lhs &amp;lhs, const Rhs &amp;rhs)</td></tr>
<tr class="memdesc:af90149542071c83fddeb04c75e9cfd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs for equality.  <br /></td></tr>
<tr class="separator:af90149542071c83fddeb04c75e9cfd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9d85f508d94dd1e962cde1d89683bc"><td class="memTemplParams" colspan="2"><a id="afd9d85f508d94dd1e962cde1d89683bc" name="afd9d85f508d94dd1e962cde1d89683bc"></a>
template&lt;is::triviallyCopyableWithDataAndSize OtherContainer&gt; </td></tr>
<tr class="memitem:afd9d85f508d94dd1e962cde1d89683bc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Vector</b> (const OtherContainer &amp;other) -&gt; <a class="el" href="classvctr_1_1Vector.html">Vector</a>&lt; <a class="el" href="namespacevctr.html#a83a43fd917a646b18b60be7e88becc33">ValueType</a>&lt; OtherContainer &gt; &gt;</td></tr>
<tr class="separator:afd9d85f508d94dd1e962cde1d89683bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ded73c09e949449a14be77f5de6e880"><td class="memTemplParams" colspan="2"><a id="a9ded73c09e949449a14be77f5de6e880" name="a9ded73c09e949449a14be77f5de6e880"></a>
template&lt;std::input_iterator Iterator, std::sentinel_for&lt; Iterator &gt; Sentinel&gt; </td></tr>
<tr class="memitem:a9ded73c09e949449a14be77f5de6e880"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Vector</b> (Iterator first, Sentinel last) -&gt; <a class="el" href="classvctr_1_1Vector.html">Vector</a>&lt; std::iter_value_t&lt; Iterator &gt; &gt;</td></tr>
<tr class="separator:a9ded73c09e949449a14be77f5de6e880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6417ba1fa0f30ae10c04557eb5c0fdd1"><td class="memTemplParams" colspan="2"><a id="a6417ba1fa0f30ae10c04557eb5c0fdd1" name="a6417ba1fa0f30ae10c04557eb5c0fdd1"></a>
template&lt;is::suitableInitializerFunction Fn&gt; </td></tr>
<tr class="memitem:a6417ba1fa0f30ae10c04557eb5c0fdd1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Vector</b> (size_t size, Fn &amp;&amp;initializerFunction) -&gt; <a class="el" href="classvctr_1_1Vector.html">Vector</a>&lt; std::invoke_result_t&lt; Fn, size_t &gt; &gt;</td></tr>
<tr class="separator:a6417ba1fa0f30ae10c04557eb5c0fdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d6e9e8f3399df7a79c879cb8a4db2a"><td class="memTemplParams" colspan="2"><a id="a34d6e9e8f3399df7a79c879cb8a4db2a" name="a34d6e9e8f3399df7a79c879cb8a4db2a"></a>
template&lt;is::expression Expression&gt; </td></tr>
<tr class="memitem:a34d6e9e8f3399df7a79c879cb8a4db2a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Vector</b> (Expression &amp;&amp;e) -&gt; <a class="el" href="classvctr_1_1Vector.html">Vector</a>&lt; <a class="el" href="namespacevctr.html#a83a43fd917a646b18b60be7e88becc33">ValueType</a>&lt; Expression &gt; &gt;</td></tr>
<tr class="separator:a34d6e9e8f3399df7a79c879cb8a4db2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1aae899c0ed0aae68ad1562bb1a9adb"><td class="memTemplParams" colspan="2"><a id="ab1aae899c0ed0aae68ad1562bb1a9adb" name="ab1aae899c0ed0aae68ad1562bb1a9adb"></a>
template&lt;is::uniquePtr FirstArg, is::uniquePtr... Args&gt; <br />
requires (are::same&lt;FirstArg, Args...&gt;)</td></tr>
<tr class="memitem:ab1aae899c0ed0aae68ad1562bb1a9adb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>OwnedVector</b> (FirstArg &amp;&amp;, Args &amp;&amp;...) -&gt; <a class="el" href="classvctr_1_1OwnedVector.html">OwnedVector</a>&lt; typename FirstArg::element_type &gt;</td></tr>
<tr class="separator:ab1aae899c0ed0aae68ad1562bb1a9adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f93431c14c872955baaaf0d2052381"><td class="memTemplParams" colspan="2">template&lt;is::anyVctrOrExpression SrcAType, is::anyVctrOrExpression SrcBType&gt; </td></tr>
<tr class="memitem:ga36f93431c14c872955baaaf0d2052381"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga36f93431c14c872955baaaf0d2052381">operator+</a> (SrcAType &amp;&amp;a, SrcBType &amp;&amp;b)</td></tr>
<tr class="memdesc:ga36f93431c14c872955baaaf0d2052381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression that adds two vector or expression sources.  <br /></td></tr>
<tr class="separator:ga36f93431c14c872955baaaf0d2052381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24470bf226cfd8eccac84baacc1988be"><td class="memTemplParams" colspan="2">template&lt;is::anyVctrOrExpression Src&gt; </td></tr>
<tr class="memitem:ga24470bf226cfd8eccac84baacc1988be"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga24470bf226cfd8eccac84baacc1988be">operator+</a> (typename std::remove_cvref_t&lt; Src &gt;::value_type single, Src &amp;&amp;vec)</td></tr>
<tr class="memdesc:ga24470bf226cfd8eccac84baacc1988be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression that adds a single value to a vector or expression source.  <br /></td></tr>
<tr class="separator:ga24470bf226cfd8eccac84baacc1988be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0aa5a68cba8ed5ab033240d238b6002"><td class="memTemplParams" colspan="2">template&lt;is::anyVctrOrExpression Src&gt; </td></tr>
<tr class="memitem:gad0aa5a68cba8ed5ab033240d238b6002"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gad0aa5a68cba8ed5ab033240d238b6002">operator+</a> (Src &amp;&amp;vec, typename std::remove_cvref_t&lt; Src &gt;::value_type single)</td></tr>
<tr class="memdesc:gad0aa5a68cba8ed5ab033240d238b6002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression that adds a vector or expression source to a single value.  <br /></td></tr>
<tr class="separator:gad0aa5a68cba8ed5ab033240d238b6002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69329f63042f587f726465da4ef612d8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga69329f63042f587f726465da4ef612d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga69329f63042f587f726465da4ef612d8">clampLow</a> (T lowerBound)</td></tr>
<tr class="memdesc:ga69329f63042f587f726465da4ef612d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the elements are not lower than lowerBound.  <br /></td></tr>
<tr class="separator:ga69329f63042f587f726465da4ef612d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa42cf0dd0e425bad94a420c9ac6805c7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaa42cf0dd0e425bad94a420c9ac6805c7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gaa42cf0dd0e425bad94a420c9ac6805c7">clampHigh</a> (T upperBound)</td></tr>
<tr class="memdesc:gaa42cf0dd0e425bad94a420c9ac6805c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the elements are not greater than upperBound.  <br /></td></tr>
<tr class="separator:gaa42cf0dd0e425bad94a420c9ac6805c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb6fc764c304eda32439875e7b50d485"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gadb6fc764c304eda32439875e7b50d485"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gadb6fc764c304eda32439875e7b50d485">clamp</a> (T lowerBound, T upperBound)</td></tr>
<tr class="memdesc:gadb6fc764c304eda32439875e7b50d485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the elements are not lower than lowerBound and not higher than upperBound.  <br /></td></tr>
<tr class="separator:gadb6fc764c304eda32439875e7b50d485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fa04c18dbf489b3dfccc7d15ea11c2e"><td class="memTemplParams" colspan="2">template&lt;class SrcAType , class SrcBType &gt; <br />
requires (is::anyVctrOrExpression&lt;std::remove_cvref_t&lt;SrcAType&gt;&gt; &amp;&amp; is::anyVctrOrExpression&lt;std::remove_cvref_t&lt;SrcBType&gt;&gt;)</td></tr>
<tr class="memitem:ga7fa04c18dbf489b3dfccc7d15ea11c2e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga7fa04c18dbf489b3dfccc7d15ea11c2e">operator/</a> (SrcAType &amp;&amp;a, SrcBType &amp;&amp;b)</td></tr>
<tr class="memdesc:ga7fa04c18dbf489b3dfccc7d15ea11c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression that divides vector or expression a by vector or expression b.  <br /></td></tr>
<tr class="separator:ga7fa04c18dbf489b3dfccc7d15ea11c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33e144c46ba685bf55b8b06fc85e912a"><td class="memTemplParams" colspan="2">template&lt;class Src &gt; <br />
requires is::anyVctrOrExpression&lt;Src&gt;</td></tr>
<tr class="memitem:ga33e144c46ba685bf55b8b06fc85e912a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga33e144c46ba685bf55b8b06fc85e912a">operator/</a> (typename std::remove_cvref_t&lt; Src &gt;::value_type single, Src &amp;&amp;vec)</td></tr>
<tr class="memdesc:ga33e144c46ba685bf55b8b06fc85e912a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression that divides a single value by a vector or expression source.  <br /></td></tr>
<tr class="separator:ga33e144c46ba685bf55b8b06fc85e912a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ca2de641883cfdd1d28b122424864eb"><td class="memTemplParams" colspan="2">template&lt;class Src &gt; <br />
requires is::anyVctrOrExpression&lt;Src&gt;</td></tr>
<tr class="memitem:ga7ca2de641883cfdd1d28b122424864eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga7ca2de641883cfdd1d28b122424864eb">operator/</a> (Src &amp;&amp;vec, typename std::remove_cvref_t&lt; Src &gt;::value_type single)</td></tr>
<tr class="memdesc:ga7ca2de641883cfdd1d28b122424864eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression that divides a vector or expression source by a single value.  <br /></td></tr>
<tr class="separator:ga7ca2de641883cfdd1d28b122424864eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace45c99e6906fb1273db0cfb3ec4fd01"><td class="memTemplParams" colspan="2">template&lt;class SrcAType , class SrcBType &gt; <br />
requires (is::anyVctrOrExpression&lt;std::remove_cvref_t&lt;SrcAType&gt;&gt; &amp;&amp; is::anyVctrOrExpression&lt;std::remove_cvref_t&lt;SrcBType&gt;&gt;)</td></tr>
<tr class="memitem:gace45c99e6906fb1273db0cfb3ec4fd01"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gace45c99e6906fb1273db0cfb3ec4fd01">operator*</a> (SrcAType &amp;&amp;a, SrcBType &amp;&amp;b)</td></tr>
<tr class="memdesc:gace45c99e6906fb1273db0cfb3ec4fd01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression that multiplies vector or expression a with vector or expression b.  <br /></td></tr>
<tr class="separator:gace45c99e6906fb1273db0cfb3ec4fd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c66069ba0f2ac2876104893c73a4521"><td class="memTemplParams" colspan="2">template&lt;class Src &gt; <br />
requires is::anyVctrOrExpression&lt;Src&gt;</td></tr>
<tr class="memitem:ga5c66069ba0f2ac2876104893c73a4521"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga5c66069ba0f2ac2876104893c73a4521">operator*</a> (typename std::remove_cvref_t&lt; Src &gt;::value_type single, Src &amp;&amp;vec)</td></tr>
<tr class="memdesc:ga5c66069ba0f2ac2876104893c73a4521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression that multiplies a single value with a vector or expression source.  <br /></td></tr>
<tr class="separator:ga5c66069ba0f2ac2876104893c73a4521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga381264b52d81641d1e0e7fba44b95b33"><td class="memTemplParams" colspan="2">template&lt;class Src &gt; <br />
requires is::anyVctrOrExpression&lt;Src&gt;</td></tr>
<tr class="memitem:ga381264b52d81641d1e0e7fba44b95b33"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga381264b52d81641d1e0e7fba44b95b33">operator*</a> (Src &amp;&amp;vec, typename std::remove_cvref_t&lt; Src &gt;::value_type single)</td></tr>
<tr class="memdesc:ga381264b52d81641d1e0e7fba44b95b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression that multiplies a vector or expression source with a single value.  <br /></td></tr>
<tr class="separator:ga381264b52d81641d1e0e7fba44b95b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9174be97e2f8cdaa08c40b5b5f24628b"><td class="memTemplParams" colspan="2">template&lt;class SrcAType , class SrcBType &gt; <br />
requires (is::anyVctrOrExpression&lt;std::remove_cvref_t&lt;SrcAType&gt;&gt; &amp;&amp; is::anyVctrOrExpression&lt;std::remove_cvref_t&lt;SrcBType&gt;&gt;)</td></tr>
<tr class="memitem:ga9174be97e2f8cdaa08c40b5b5f24628b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga9174be97e2f8cdaa08c40b5b5f24628b">operator-</a> (SrcAType &amp;&amp;a, SrcBType &amp;&amp;b)</td></tr>
<tr class="memdesc:ga9174be97e2f8cdaa08c40b5b5f24628b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression that subtracts vector or expression b from vector or expression a.  <br /></td></tr>
<tr class="separator:ga9174be97e2f8cdaa08c40b5b5f24628b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaa9cb36a35a3e2be8103e71e6642153"><td class="memTemplParams" colspan="2">template&lt;class Src &gt; <br />
requires is::anyVctrOrExpression&lt;Src&gt;</td></tr>
<tr class="memitem:gaeaa9cb36a35a3e2be8103e71e6642153"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gaeaa9cb36a35a3e2be8103e71e6642153">operator-</a> (typename std::remove_cvref_t&lt; Src &gt;::value_type single, Src &amp;&amp;vec)</td></tr>
<tr class="memdesc:gaeaa9cb36a35a3e2be8103e71e6642153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression that subtracts a vector or expression source from a single value.  <br /></td></tr>
<tr class="separator:gaeaa9cb36a35a3e2be8103e71e6642153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga396d48225010859e9c01a718afd0f922"><td class="memTemplParams" colspan="2">template&lt;class Src &gt; <br />
requires is::anyVctrOrExpression&lt;Src&gt;</td></tr>
<tr class="memitem:ga396d48225010859e9c01a718afd0f922"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga396d48225010859e9c01a718afd0f922">operator-</a> (Src &amp;&amp;vec, typename std::remove_cvref_t&lt; Src &gt;::value_type single)</td></tr>
<tr class="memdesc:ga396d48225010859e9c01a718afd0f922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression that subtracts a single value from a vector or expression.  <br /></td></tr>
<tr class="separator:ga396d48225010859e9c01a718afd0f922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bee671c8b09c5aa9d952e8529e47e8b"><td class="memTemplParams" colspan="2">template&lt;is::anyVctrOrExpression SrcBaseType, is::anyVctrOrExpression SrcExpType&gt; </td></tr>
<tr class="memitem:ga9bee671c8b09c5aa9d952e8529e47e8b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga9bee671c8b09c5aa9d952e8529e47e8b">pow</a> (SrcBaseType &amp;&amp;bases, SrcExpType &amp;&amp;exponents)</td></tr>
<tr class="memdesc:ga9bee671c8b09c5aa9d952e8529e47e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression that raises the elements in bases element-wise to the power of the elements in exponents.  <br /></td></tr>
<tr class="separator:ga9bee671c8b09c5aa9d952e8529e47e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd4fec61c0c7d256340f9483a17d13eb"><td class="memTemplParams" colspan="2">template&lt;is::anyVctrOrExpression Src&gt; </td></tr>
<tr class="memitem:gacd4fec61c0c7d256340f9483a17d13eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gacd4fec61c0c7d256340f9483a17d13eb">pow</a> (typename std::remove_cvref_t&lt; Src &gt;::value_type base, Src &amp;&amp;exponents)</td></tr>
<tr class="memdesc:gacd4fec61c0c7d256340f9483a17d13eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression that raises the base value base to the power of the elements in exponents.  <br /></td></tr>
<tr class="separator:gacd4fec61c0c7d256340f9483a17d13eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b49d9d6f6070cc6a9af10c8c167cc35"><td class="memTemplParams" colspan="2">template&lt;is::anyVctrOrExpression Src&gt; </td></tr>
<tr class="memitem:ga3b49d9d6f6070cc6a9af10c8c167cc35"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga3b49d9d6f6070cc6a9af10c8c167cc35">pow</a> (Src &amp;&amp;bases, typename std::remove_cvref_t&lt; Src &gt;::value_type exponent)</td></tr>
<tr class="memdesc:ga3b49d9d6f6070cc6a9af10c8c167cc35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression that raises the elements in bases to the power of the exponent value.  <br /></td></tr>
<tr class="separator:ga3b49d9d6f6070cc6a9af10c8c167cc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1a63f35218dca5e5e92802c49b2793"><td class="memTemplParams" colspan="2">template&lt;template&lt; size_t, class... &gt; class ExpressionType, class... RuntimeArgs&gt; <br />
requires (sizeof... (RuntimeArgs) &gt; 0)</td></tr>
<tr class="memitem:afc1a63f35218dca5e5e92802c49b2793"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevctr.html#afc1a63f35218dca5e5e92802c49b2793">makeExpressionChainBuilderWithRuntimeArgs</a> (RuntimeArgs... runtimeArgs)</td></tr>
<tr class="memdesc:afc1a63f35218dca5e5e92802c49b2793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to build factory functions for expressions that rely on runtime argument values.  <br /></td></tr>
<tr class="separator:afc1a63f35218dca5e5e92802c49b2793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340fb7574b2f7707e6f86ca65fd2ccbb"><td class="memTemplParams" colspan="2">template&lt;template&lt; size_t, class... &gt; class ExpressionType, class ExpressionTemplateArg , class... RuntimeArgs&gt; <br />
requires (sizeof... (RuntimeArgs) &gt; 0)</td></tr>
<tr class="memitem:a340fb7574b2f7707e6f86ca65fd2ccbb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevctr.html#a340fb7574b2f7707e6f86ca65fd2ccbb">makeTemplateExpressionChainBuilderWithRuntimeArgs</a> (RuntimeArgs... runtimeArgs)</td></tr>
<tr class="memdesc:a340fb7574b2f7707e6f86ca65fd2ccbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to build factory functions for expressions that rely on runtime argument values.  <br /></td></tr>
<tr class="separator:a340fb7574b2f7707e6f86ca65fd2ccbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaebe8e635121b4a8a143abb74bf9fc1"><td class="memTemplParams" colspan="2">template&lt;is::range RangeType&gt; </td></tr>
<tr class="memitem:gacaebe8e635121b4a8a143abb74bf9fc1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gacaebe8e635121b4a8a143abb74bf9fc1">map</a> (RangeType &amp;&amp;srcValueRange, RangeType &amp;&amp;dstValueRange)</td></tr>
<tr class="memdesc:gacaebe8e635121b4a8a143abb74bf9fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps all source element values from srcValueRange to values in dstValueRange.  <br /></td></tr>
<tr class="separator:gacaebe8e635121b4a8a143abb74bf9fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bb32794f6c515e3ea8043483bf1dcc9"><td class="memTemplParams" colspan="2">template&lt;is::realFloatNumber T&gt; </td></tr>
<tr class="memitem:ga1bb32794f6c515e3ea8043483bf1dcc9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga1bb32794f6c515e3ea8043483bf1dcc9">map</a> (T srcValueRangeStart, T srcValueRangeEnd, T dstValueRangeStart, T dstValueRangeEnd)</td></tr>
<tr class="memdesc:ga1bb32794f6c515e3ea8043483bf1dcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps all source element values from the range srcValueRangeStart to srcValueRangeEnd to values in [dstValueRangeStart, dstValueRangeEnd].  <br /></td></tr>
<tr class="separator:ga1bb32794f6c515e3ea8043483bf1dcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga243c68d6c931db606b95fd580f53faec"><td class="memTemplParams" colspan="2">template&lt;is::range RangeType&gt; </td></tr>
<tr class="memitem:ga243c68d6c931db606b95fd580f53faec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga243c68d6c931db606b95fd580f53faec">mapFrom0To1</a> (RangeType &amp;&amp;dstValueRange)</td></tr>
<tr class="memdesc:ga243c68d6c931db606b95fd580f53faec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps all source element values from the range [0.0 to 1.0] to values in dstValueRange.  <br /></td></tr>
<tr class="separator:ga243c68d6c931db606b95fd580f53faec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3ac5d8df8839be733d06d9272d7cd25"><td class="memTemplParams" colspan="2">template&lt;is::realFloatNumber T&gt; </td></tr>
<tr class="memitem:gab3ac5d8df8839be733d06d9272d7cd25"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gab3ac5d8df8839be733d06d9272d7cd25">mapFrom0To1</a> (T dstValueRangeStart, T dstValueRangeEnd)</td></tr>
<tr class="memdesc:gab3ac5d8df8839be733d06d9272d7cd25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps all source element values from the range [0.0 to 1.0] to values in the range from [dstValueRangeStart to dstValueRangeEnd].  <br /></td></tr>
<tr class="separator:gab3ac5d8df8839be733d06d9272d7cd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4384c06fb1d554d76f83643447159e5"><td class="memTemplParams" colspan="2">template&lt;is::range RangeType&gt; </td></tr>
<tr class="memitem:gab4384c06fb1d554d76f83643447159e5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gab4384c06fb1d554d76f83643447159e5">mapTo0To1</a> (RangeType &amp;&amp;srcValueRange)</td></tr>
<tr class="memdesc:gab4384c06fb1d554d76f83643447159e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps all source element values from srcValueRange to values in the range [0.0 to 1.0].  <br /></td></tr>
<tr class="separator:gab4384c06fb1d554d76f83643447159e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga039f6eeff0c66a878832646d69ee05c8"><td class="memTemplParams" colspan="2">template&lt;is::realFloatNumber T&gt; </td></tr>
<tr class="memitem:ga039f6eeff0c66a878832646d69ee05c8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga039f6eeff0c66a878832646d69ee05c8">mapTo0To1</a> (T srcValueRangeStart, T srcValueRangeEnd)</td></tr>
<tr class="memdesc:ga039f6eeff0c66a878832646d69ee05c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps all source element values from teh range [srcValueRangeStart to srcValueRangeEnd] to values in the range [0.0 to 1.0].  <br /></td></tr>
<tr class="separator:ga039f6eeff0c66a878832646d69ee05c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea7f8d380f1eadb6615c56b8246544d9"><td class="memTemplParams" colspan="2">template&lt;class Fn &gt; </td></tr>
<tr class="memitem:gaea7f8d380f1eadb6615c56b8246544d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gaea7f8d380f1eadb6615c56b8246544d9">transformedBy</a> (Fn &amp;&amp;fn)</td></tr>
<tr class="memdesc:gaea7f8d380f1eadb6615c56b8246544d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms all source elements by applying fn to them.  <br /></td></tr>
<tr class="separator:gaea7f8d380f1eadb6615c56b8246544d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f802c4dd64e90f68dd2d09991468ae"><td class="memTemplParams" colspan="2"><a id="ae5f802c4dd64e90f68dd2d09991468ae" name="ae5f802c4dd64e90f68dd2d09991468ae"></a>
template&lt;class ElementType , size_t alignmentInBytesLHS, size_t alignmentInBytesRHS&gt; </td></tr>
<tr class="memitem:ae5f802c4dd64e90f68dd2d09991468ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classvctr_1_1AlignedAllocator.html">AlignedAllocator</a>&lt; ElementType, alignmentInBytesLHS &gt; &amp;, const <a class="el" href="classvctr_1_1AlignedAllocator.html">AlignedAllocator</a>&lt; ElementType, alignmentInBytesRHS &gt; &amp;)</td></tr>
<tr class="separator:ae5f802c4dd64e90f68dd2d09991468ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9984ebcd310f07bbcc64d91a8b00e18"><td class="memItemLeft" align="right" valign="top"><a id="aa9984ebcd310f07bbcc64d91a8b00e18" name="aa9984ebcd310f07bbcc64d91a8b00e18"></a>
CPUInstructionSet&#160;</td><td class="memItemRight" valign="bottom"><b>getHighestSupportedCPUInstructionSet</b> ()</td></tr>
<tr class="separator:aa9984ebcd310f07bbcc64d91a8b00e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1653c21c7d273148258da4ce3ff4f376"><td class="memTemplParams" colspan="2"><a id="a1653c21c7d273148258da4ce3ff4f376" name="a1653c21c7d273148258da4ce3ff4f376"></a>
template&lt;is::anyVctrOrExpression V&gt; </td></tr>
<tr class="memitem:a1653c21c7d273148258da4ce3ff4f376"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;s, const V &amp;vec)</td></tr>
<tr class="separator:a1653c21c7d273148258da4ce3ff4f376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbd148207a93e819482375969ad3db9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevctr.html#aecbd148207a93e819482375969ad3db9">sizeToInt</a> (size_t size)</td></tr>
<tr class="memdesc:aecbd148207a93e819482375969ad3db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the size_t argument to an int.  <br /></td></tr>
<tr class="separator:aecbd148207a93e819482375969ad3db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b3b641de5cbcac59ad5c852df70929"><td class="memTemplParams" colspan="2">template&lt;class A , class B &gt; </td></tr>
<tr class="memitem:a50b3b641de5cbcac59ad5c852df70929"><td class="memTemplItemLeft" align="right" valign="top">consteval size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevctr.html#a50b3b641de5cbcac59ad5c852df70929">getCommonExtent</a> ()</td></tr>
<tr class="memdesc:a50b3b641de5cbcac59ad5c852df70929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns std::dynamic_extent in case both sources specify a dynamic extent.  <br /></td></tr>
<tr class="separator:a50b3b641de5cbcac59ad5c852df70929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530eaa0685b6027bcdd79a4ac9a47fda"><td class="memTemplParams" colspan="2">template&lt;class A , class B &gt; </td></tr>
<tr class="memitem:a530eaa0685b6027bcdd79a4ac9a47fda"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevctr.html#a530eaa0685b6027bcdd79a4ac9a47fda">assertCommonSize</a> (const A &amp;a, const B &amp;b)</td></tr>
<tr class="memdesc:a530eaa0685b6027bcdd79a4ac9a47fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that both sources have the same size.  <br /></td></tr>
<tr class="separator:a530eaa0685b6027bcdd79a4ac9a47fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c06d6ad88e0ec58063d553c7f15bca"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a49c06d6ad88e0ec58063d553c7f15bca"><td class="memTemplItemLeft" align="right" valign="top">consteval std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevctr.html#a49c06d6ad88e0ec58063d553c7f15bca">typeName</a> ()</td></tr>
<tr class="memdesc:a49c06d6ad88e0ec58063d553c7f15bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing the templates type name.  <br /></td></tr>
<tr class="separator:a49c06d6ad88e0ec58063d553c7f15bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8afd070abd349a5af042178b77f911c"><td class="memItemLeft" align="right" valign="top"><a id="aa8afd070abd349a5af042178b77f911c" name="aa8afd070abd349a5af042178b77f911c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa8afd070abd349a5af042178b77f911c"><td class="memTemplItemLeft" align="right" valign="top">consteval std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><b>typeName&lt; void &gt;</b> ()</td></tr>
<tr class="separator:aa8afd070abd349a5af042178b77f911c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9a31bf9e2d720cd04c9f74b55002d0"><td class="memItemLeft" align="right" valign="top"><a id="a3e9a31bf9e2d720cd04c9f74b55002d0" name="a3e9a31bf9e2d720cd04c9f74b55002d0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3e9a31bf9e2d720cd04c9f74b55002d0"><td class="memTemplItemLeft" align="right" valign="top">consteval std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><b>typeName&lt; int8_t &gt;</b> ()</td></tr>
<tr class="separator:a3e9a31bf9e2d720cd04c9f74b55002d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac00cbf0976ec04566c7361d20f164b"><td class="memItemLeft" align="right" valign="top"><a id="afac00cbf0976ec04566c7361d20f164b" name="afac00cbf0976ec04566c7361d20f164b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:afac00cbf0976ec04566c7361d20f164b"><td class="memTemplItemLeft" align="right" valign="top">consteval std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><b>typeName&lt; uint8_t &gt;</b> ()</td></tr>
<tr class="separator:afac00cbf0976ec04566c7361d20f164b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f17a753c3a3a56992ee58b0929715e"><td class="memItemLeft" align="right" valign="top"><a id="a65f17a753c3a3a56992ee58b0929715e" name="a65f17a753c3a3a56992ee58b0929715e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a65f17a753c3a3a56992ee58b0929715e"><td class="memTemplItemLeft" align="right" valign="top">consteval std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><b>typeName&lt; int16_t &gt;</b> ()</td></tr>
<tr class="separator:a65f17a753c3a3a56992ee58b0929715e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae3ababc5ce69b9112c930002dbe3a1"><td class="memItemLeft" align="right" valign="top"><a id="a4ae3ababc5ce69b9112c930002dbe3a1" name="a4ae3ababc5ce69b9112c930002dbe3a1"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4ae3ababc5ce69b9112c930002dbe3a1"><td class="memTemplItemLeft" align="right" valign="top">consteval std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><b>typeName&lt; uint16_t &gt;</b> ()</td></tr>
<tr class="separator:a4ae3ababc5ce69b9112c930002dbe3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437d438850df7eda17f45c3cef2b7cc9"><td class="memItemLeft" align="right" valign="top"><a id="a437d438850df7eda17f45c3cef2b7cc9" name="a437d438850df7eda17f45c3cef2b7cc9"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a437d438850df7eda17f45c3cef2b7cc9"><td class="memTemplItemLeft" align="right" valign="top">consteval std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><b>typeName&lt; int32_t &gt;</b> ()</td></tr>
<tr class="separator:a437d438850df7eda17f45c3cef2b7cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf14b417d0c5bf924ee6283fc6f4417"><td class="memItemLeft" align="right" valign="top"><a id="a5cf14b417d0c5bf924ee6283fc6f4417" name="a5cf14b417d0c5bf924ee6283fc6f4417"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5cf14b417d0c5bf924ee6283fc6f4417"><td class="memTemplItemLeft" align="right" valign="top">consteval std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><b>typeName&lt; uint32_t &gt;</b> ()</td></tr>
<tr class="separator:a5cf14b417d0c5bf924ee6283fc6f4417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405bb29b9a2161dea56c66b5f4b84c27"><td class="memItemLeft" align="right" valign="top"><a id="a405bb29b9a2161dea56c66b5f4b84c27" name="a405bb29b9a2161dea56c66b5f4b84c27"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a405bb29b9a2161dea56c66b5f4b84c27"><td class="memTemplItemLeft" align="right" valign="top">consteval std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><b>typeName&lt; int64_t &gt;</b> ()</td></tr>
<tr class="separator:a405bb29b9a2161dea56c66b5f4b84c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f775b151635ac93c03da0303e50c49"><td class="memItemLeft" align="right" valign="top"><a id="ad2f775b151635ac93c03da0303e50c49" name="ad2f775b151635ac93c03da0303e50c49"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad2f775b151635ac93c03da0303e50c49"><td class="memTemplItemLeft" align="right" valign="top">consteval std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><b>typeName&lt; uint64_t &gt;</b> ()</td></tr>
<tr class="separator:ad2f775b151635ac93c03da0303e50c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85b5f47f9864094af338637c98099e3"><td class="memTemplParams" colspan="2"><a id="aa85b5f47f9864094af338637c98099e3" name="aa85b5f47f9864094af338637c98099e3"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa85b5f47f9864094af338637c98099e3"><td class="memTemplItemLeft" align="right" valign="top">consteval std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><b>typeName</b> (const T &amp;)</td></tr>
<tr class="separator:aa85b5f47f9864094af338637c98099e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127327a069f9c9d92bb9c5325234f2fe"><td class="memTemplParams" colspan="2">template&lt;class R , class Arg , R(*)(Arg) fn&gt; </td></tr>
<tr class="memitem:a127327a069f9c9d92bb9c5325234f2fe"><td class="memTemplItemLeft" align="right" valign="top">consteval std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevctr.html#a127327a069f9c9d92bb9c5325234f2fe">functionName</a> ()</td></tr>
<tr class="memdesc:a127327a069f9c9d92bb9c5325234f2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name for a function with a single argument.  <br /></td></tr>
<tr class="separator:a127327a069f9c9d92bb9c5325234f2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3bde90036f67b89e469aea181516e8"><td class="memTemplParams" colspan="2">template&lt;class R , class ArgA , class ArgB , R(*)(ArgA, ArgB) fn&gt; </td></tr>
<tr class="memitem:acd3bde90036f67b89e469aea181516e8"><td class="memTemplItemLeft" align="right" valign="top">consteval std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevctr.html#acd3bde90036f67b89e469aea181516e8">functionName</a> ()</td></tr>
<tr class="memdesc:acd3bde90036f67b89e469aea181516e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name for a function with two arguments.  <br /></td></tr>
<tr class="separator:acd3bde90036f67b89e469aea181516e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gac4fac892235effd8638c99018b7ab32f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Abs.html">expressions::Abs</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gac4fac892235effd8638c99018b7ab32f">abs</a></td></tr>
<tr class="memdesc:gac4fac892235effd8638c99018b7ab32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of the source values.  <br /></td></tr>
<tr class="separator:gac4fac892235effd8638c99018b7ab32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9cbe3f19b460eac11e8814fb62731cd"><td class="memTemplParams" colspan="2">template&lt;auto lowerBound&gt; </td></tr>
<tr class="memitem:gab9cbe3f19b460eac11e8814fb62731cd"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1ClampByConstant.html">expressions::ClampByConstant</a>, <a class="el" href="structvctr_1_1Constant.html">Constant</a>&lt; lowerBound &gt;, <a class="el" href="structvctr_1_1DisabledConstant.html">DisabledConstant</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gab9cbe3f19b460eac11e8814fb62731cd">clampLowByConstant</a></td></tr>
<tr class="memdesc:gab9cbe3f19b460eac11e8814fb62731cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the elements are not lower than lowerBound.  <br /></td></tr>
<tr class="separator:gab9cbe3f19b460eac11e8814fb62731cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26405b01dc3bdcb3d46d9f0e5a42340f"><td class="memTemplParams" colspan="2">template&lt;auto upperBound&gt; </td></tr>
<tr class="memitem:ga26405b01dc3bdcb3d46d9f0e5a42340f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1ClampByConstant.html">expressions::ClampByConstant</a>, <a class="el" href="structvctr_1_1DisabledConstant.html">DisabledConstant</a>, <a class="el" href="structvctr_1_1Constant.html">Constant</a>&lt; upperBound &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga26405b01dc3bdcb3d46d9f0e5a42340f">clampHighByConstant</a></td></tr>
<tr class="memdesc:ga26405b01dc3bdcb3d46d9f0e5a42340f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the elements are not higher than upperBound.  <br /></td></tr>
<tr class="separator:ga26405b01dc3bdcb3d46d9f0e5a42340f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b6f78c2a5e03e76bf2591297c281c4a"><td class="memTemplParams" colspan="2">template&lt;auto lowerBound, auto upperBound&gt; </td></tr>
<tr class="memitem:ga9b6f78c2a5e03e76bf2591297c281c4a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1ClampByConstant.html">expressions::ClampByConstant</a>, <a class="el" href="structvctr_1_1Constant.html">Constant</a>&lt; lowerBound &gt;, <a class="el" href="structvctr_1_1Constant.html">Constant</a>&lt; upperBound &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga9b6f78c2a5e03e76bf2591297c281c4a">clampByConstant</a></td></tr>
<tr class="memdesc:ga9b6f78c2a5e03e76bf2591297c281c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the elements are not lower than lowerBound and not higher than upperBound.  <br /></td></tr>
<tr class="separator:ga9b6f78c2a5e03e76bf2591297c281c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e424bc5fa6e6b74c38135f20e10621"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Cube.html">expressions::Cube</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gad4e424bc5fa6e6b74c38135f20e10621">cube</a></td></tr>
<tr class="memdesc:gad4e424bc5fa6e6b74c38135f20e10621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises the source values to the power of three.  <br /></td></tr>
<tr class="separator:gad4e424bc5fa6e6b74c38135f20e10621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab29b54656df0ab50dad4271e1addf2c7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Max.html">expressions::Max</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gab29b54656df0ab50dad4271e1addf2c7">max</a></td></tr>
<tr class="memdesc:gab29b54656df0ab50dad4271e1addf2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum value of the source values.  <br /></td></tr>
<tr class="separator:gab29b54656df0ab50dad4271e1addf2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe2cbadc65ac692fa439cc4c5c18e967"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1MaxAbs.html">expressions::MaxAbs</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gafe2cbadc65ac692fa439cc4c5c18e967">maxAbs</a></td></tr>
<tr class="memdesc:gafe2cbadc65ac692fa439cc4c5c18e967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum value of the absolute value of the source values.  <br /></td></tr>
<tr class="separator:gafe2cbadc65ac692fa439cc4c5c18e967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b417f2a488836dd7358dc2b0cadfc10"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Mean.html">expressions::Mean</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga5b417f2a488836dd7358dc2b0cadfc10">mean</a></td></tr>
<tr class="memdesc:ga5b417f2a488836dd7358dc2b0cadfc10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean value of the source values.  <br /></td></tr>
<tr class="separator:ga5b417f2a488836dd7358dc2b0cadfc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2a023188f8f05991bf65d56d3127f0d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1MeanSquare.html">expressions::MeanSquare</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gaf2a023188f8f05991bf65d56d3127f0d">meanSquare</a></td></tr>
<tr class="memdesc:gaf2a023188f8f05991bf65d56d3127f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean value of the squared source values.  <br /></td></tr>
<tr class="separator:gaf2a023188f8f05991bf65d56d3127f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga461b990c1ec58299e9e7bb7ae367fd13"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1RootMeanSquare.html">expressions::RootMeanSquare</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga461b990c1ec58299e9e7bb7ae367fd13">rms</a></td></tr>
<tr class="memdesc:ga461b990c1ec58299e9e7bb7ae367fd13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the mean value of the squared source values.  <br /></td></tr>
<tr class="separator:ga461b990c1ec58299e9e7bb7ae367fd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae77e3e38e1fb46de60f48d2977edc8d5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Min.html">expressions::Min</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gae77e3e38e1fb46de60f48d2977edc8d5">min</a></td></tr>
<tr class="memdesc:gae77e3e38e1fb46de60f48d2977edc8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum value of the source values.  <br /></td></tr>
<tr class="separator:gae77e3e38e1fb46de60f48d2977edc8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b09e32571fd1b4968f6ba72509a71c7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1MinAbs.html">expressions::MinAbs</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga3b09e32571fd1b4968f6ba72509a71c7">minAbs</a></td></tr>
<tr class="memdesc:ga3b09e32571fd1b4968f6ba72509a71c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum value of the absolute value of the source values.  <br /></td></tr>
<tr class="separator:ga3b09e32571fd1b4968f6ba72509a71c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaca8458ca97c6a7da8e682cd6e5d84d"><td class="memTemplParams" colspan="2">template&lt;auto constantValue&gt; </td></tr>
<tr class="memitem:gacaca8458ca97c6a7da8e682cd6e5d84d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1MultiplyVecByConstant.html">expressions::MultiplyVecByConstant</a>, <a class="el" href="structvctr_1_1Constant.html">Constant</a>&lt; constantValue &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gacaca8458ca97c6a7da8e682cd6e5d84d">multiplyByConstant</a></td></tr>
<tr class="memdesc:gacaca8458ca97c6a7da8e682cd6e5d84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression that multiplies a vector or expression source with a compile time constant.  <br /></td></tr>
<tr class="separator:gacaca8458ca97c6a7da8e682cd6e5d84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cccddc76017b29befea7e34bf607010"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1NormalizeSum.html">expressions::NormalizeSum</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga7cccddc76017b29befea7e34bf607010">normalizeSum</a></td></tr>
<tr class="memdesc:ga7cccddc76017b29befea7e34bf607010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the source elements and divides all source elements by that sum.  <br /></td></tr>
<tr class="separator:ga7cccddc76017b29befea7e34bf607010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a6c2e6dc10d5648dd04d6412c376e76"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Sqrt.html">expressions::Sqrt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga9a6c2e6dc10d5648dd04d6412c376e76">sqrt</a></td></tr>
<tr class="memdesc:ga9a6c2e6dc10d5648dd04d6412c376e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the source values.  <br /></td></tr>
<tr class="separator:ga9a6c2e6dc10d5648dd04d6412c376e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace331be21cfd6aa9705f5bc0e283e3f9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Square.html">expressions::Square</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gace331be21cfd6aa9705f5bc0e283e3f9">square</a></td></tr>
<tr class="memdesc:gace331be21cfd6aa9705f5bc0e283e3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squares the source values.  <br /></td></tr>
<tr class="separator:gace331be21cfd6aa9705f5bc0e283e3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab068809892f9c3e4f3db4eb1b11abf19"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Sum.html">expressions::Sum</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gab068809892f9c3e4f3db4eb1b11abf19">sum</a></td></tr>
<tr class="memdesc:gab068809892f9c3e4f3db4eb1b11abf19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the source values.  <br /></td></tr>
<tr class="separator:gab068809892f9c3e4f3db4eb1b11abf19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdade010cccd89cb91921e3e38c28c55"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Angle.html">expressions::Angle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gacdade010cccd89cb91921e3e38c28c55">angle</a></td></tr>
<tr class="memdesc:gacdade010cccd89cb91921e3e38c28c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the phase angles of the complex source values.  <br /></td></tr>
<tr class="separator:gacdade010cccd89cb91921e3e38c28c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2cab54fe8d56b64f2cea0d1f2b44529"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Conjugate.html">expressions::Conjugate</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gaf2cab54fe8d56b64f2cea0d1f2b44529">conjugate</a></td></tr>
<tr class="memdesc:gaf2cab54fe8d56b64f2cea0d1f2b44529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the complex conjugate of the source values.  <br /></td></tr>
<tr class="separator:gaf2cab54fe8d56b64f2cea0d1f2b44529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d940e2110b6323e22d993d3b1e5a63d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Imag.html">expressions::Imag</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga4d940e2110b6323e22d993d3b1e5a63d">imag</a></td></tr>
<tr class="memdesc:ga4d940e2110b6323e22d993d3b1e5a63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the imaginary parts of the complex source values.  <br /></td></tr>
<tr class="separator:ga4d940e2110b6323e22d993d3b1e5a63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5ec582bc24648aa5087f73f8eaeb651"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1PowerSpectrum.html">expressions::PowerSpectrum</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gaf5ec582bc24648aa5087f73f8eaeb651">powerSpectrum</a></td></tr>
<tr class="memdesc:gaf5ec582bc24648aa5087f73f8eaeb651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the power spectrum of the complex source values.  <br /></td></tr>
<tr class="separator:gaf5ec582bc24648aa5087f73f8eaeb651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4fc0dae0a600f82c768b555dcf6ea69"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Real.html">expressions::Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gae4fc0dae0a600f82c768b555dcf6ea69">real</a></td></tr>
<tr class="memdesc:gae4fc0dae0a600f82c768b555dcf6ea69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the real parts of the complex source values.  <br /></td></tr>
<tr class="separator:gae4fc0dae0a600f82c768b555dcf6ea69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dca38713f1fa78037e38766151e7ce6"><td class="memTemplParams" colspan="2">template&lt;is::constant DecibelConstant, auto minDb = -100&gt; </td></tr>
<tr class="memitem:ga0dca38713f1fa78037e38766151e7ce6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structvctr_1_1ExpressionChainBuilderWithRuntimeArgs.html">ExpressionChainBuilderWithRuntimeArgs</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1ClampByConstant.html">expressions::MagToDb</a>, detail::RuntimeArgChain&lt; std::tuple&lt;&gt;, std::tuple&lt;&gt;, std::tuple&lt;&gt; &gt;, DecibelConstant, <a class="el" href="structvctr_1_1Constant.html">Constant</a>&lt; minDb &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga0dca38713f1fa78037e38766151e7ce6">magToDb</a></td></tr>
<tr class="memdesc:ga0dca38713f1fa78037e38766151e7ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the source magnitude into a decibel representation.  <br /></td></tr>
<tr class="separator:ga0dca38713f1fa78037e38766151e7ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fb8fcc155a35e271c9698c78fa0fea8"><td class="memTemplParams" colspan="2">template&lt;is::constant DecibelConstant&gt; </td></tr>
<tr class="memitem:ga0fb8fcc155a35e271c9698c78fa0fea8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structvctr_1_1ExpressionChainBuilderWithRuntimeArgs.html">ExpressionChainBuilderWithRuntimeArgs</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1PowConstantBase.html">expressions::DBToMag</a>, detail::RuntimeArgChain&lt; std::tuple&lt;&gt;, std::tuple&lt;&gt;, std::tuple&lt;&gt; &gt;, DecibelConstant &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga0fb8fcc155a35e271c9698c78fa0fea8">dbToMag</a></td></tr>
<tr class="memdesc:ga0fb8fcc155a35e271c9698c78fa0fea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the source decibel values into their magnitude representation.  <br /></td></tr>
<tr class="separator:ga0fb8fcc155a35e271c9698c78fa0fea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33d306c075bd8585ee89ab456de95557"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Exp.html">expressions::Exp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga33d306c075bd8585ee89ab456de95557">exp</a></td></tr>
<tr class="memdesc:ga33d306c075bd8585ee89ab456de95557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes e (Euler's number, 2.7182818...) raised to the source vector elements power.  <br /></td></tr>
<tr class="separator:ga33d306c075bd8585ee89ab456de95557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66fa77725b3684fd045c771c27b7dbac"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Ln.html">expressions::Ln</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga66fa77725b3684fd045c771c27b7dbac">ln</a></td></tr>
<tr class="memdesc:ga66fa77725b3684fd045c771c27b7dbac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the source values.  <br /></td></tr>
<tr class="separator:ga66fa77725b3684fd045c771c27b7dbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fd49babf82a9c443081e134f86ee1fc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Log10.html">expressions::Log10</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga0fd49babf82a9c443081e134f86ee1fc">log10</a></td></tr>
<tr class="memdesc:ga0fd49babf82a9c443081e134f86ee1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the logarithm to the base of ten of the source values.  <br /></td></tr>
<tr class="separator:ga0fd49babf82a9c443081e134f86ee1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace2b11ccc6857b79c0903d3152ea951e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Log2.html">expressions::Log2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gace2b11ccc6857b79c0903d3152ea951e">log2</a></td></tr>
<tr class="memdesc:gace2b11ccc6857b79c0903d3152ea951e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the logarithm to the base of two of the source values.  <br /></td></tr>
<tr class="separator:gace2b11ccc6857b79c0903d3152ea951e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b6d257bb352c945c76cae98c730a28b"><td class="memTemplParams" colspan="2">template&lt;auto base&gt; </td></tr>
<tr class="memitem:ga3b6d257bb352c945c76cae98c730a28b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1PowConstantBase.html">expressions::PowConstantBase</a>, <a class="el" href="structvctr_1_1Constant.html">Constant</a>&lt; base &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga3b6d257bb352c945c76cae98c730a28b">powConstantBase</a></td></tr>
<tr class="memdesc:ga3b6d257bb352c945c76cae98c730a28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates base raised to the power of the source elements.  <br /></td></tr>
<tr class="separator:ga3b6d257bb352c945c76cae98c730a28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc712a3c1ecf10913b0b0be0d2e4f905"><td class="memTemplParams" colspan="2">template&lt;auto exponent&gt; </td></tr>
<tr class="memitem:gadc712a3c1ecf10913b0b0be0d2e4f905"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1PowConstantExponent.html">expressions::PowConstantExponent</a>, <a class="el" href="structvctr_1_1Constant.html">Constant</a>&lt; exponent &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gadc712a3c1ecf10913b0b0be0d2e4f905">powConstantExponent</a></td></tr>
<tr class="memdesc:gadc712a3c1ecf10913b0b0be0d2e4f905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the source elements raised to the power of exponent.  <br /></td></tr>
<tr class="separator:gadc712a3c1ecf10913b0b0be0d2e4f905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4346d69140e0367d58e03e85c69f7310"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1NoAccelerationFilter.html">expressions::NoAccelerationFilter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga4346d69140e0367d58e03e85c69f7310">dontUseAcceleration</a></td></tr>
<tr class="memdesc:ga4346d69140e0367d58e03e85c69f7310"><td class="mdescLeft">&#160;</td><td class="mdescRight">This filter expression ensures that only basic operator[] based evaluation of the previous expression is possible.  <br /></td></tr>
<tr class="separator:ga4346d69140e0367d58e03e85c69f7310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf53b60ebe32f078c6fc19ff9c96a2ef"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1PlatformVectorOpsFilter.html">expressions::PlatformVectorOpsFilter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gacf53b60ebe32f078c6fc19ff9c96a2ef">usePlatformVectorOps</a></td></tr>
<tr class="memdesc:gacf53b60ebe32f078c6fc19ff9c96a2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter expression to force platform vector operation based accelerated evaluation.  <br /></td></tr>
<tr class="separator:gacf53b60ebe32f078c6fc19ff9c96a2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e62756910834e1cdc1f0ec4227253aa"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1SSEFilter.html">expressions::SSEFilter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga8e62756910834e1cdc1f0ec4227253aa">useSSE</a></td></tr>
<tr class="memdesc:ga8e62756910834e1cdc1f0ec4227253aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This filter expression ensures that only SSE based accelerated evaluation of the previous expression is possible.  <br /></td></tr>
<tr class="separator:ga8e62756910834e1cdc1f0ec4227253aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafbd0664a42572849269e06e66088f59"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1AVXFilter.html">expressions::AVXFilter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gaafbd0664a42572849269e06e66088f59">useAVX</a></td></tr>
<tr class="memdesc:gaafbd0664a42572849269e06e66088f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">This filter expression ensures that only AVX based accelerated evaluation of the previous expression is possible.  <br /></td></tr>
<tr class="separator:gaafbd0664a42572849269e06e66088f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac92083dfec0ef5aeb23135c4fb64fe0c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1NeonFilter.html">expressions::NeonFilter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gac92083dfec0ef5aeb23135c4fb64fe0c">useNeon</a></td></tr>
<tr class="memdesc:gac92083dfec0ef5aeb23135c4fb64fe0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This filter expression ensures that only Neon based accelerated evaluation of the previous expression is possible.  <br /></td></tr>
<tr class="separator:gac92083dfec0ef5aeb23135c4fb64fe0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34b106f6050ee0fb6e8570d6e61587e"><td class="memItemLeft" align="right" valign="top"><a id="ad34b106f6050ee0fb6e8570d6e61587e" name="ad34b106f6050ee0fb6e8570d6e61587e"></a>
constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1AVXFilter.html">expressions::AVXFilter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>useNeonOrAVX</b></td></tr>
<tr class="separator:ad34b106f6050ee0fb6e8570d6e61587e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5581977c5a203ffc70dcc208e39e67f9"><td class="memItemLeft" align="right" valign="top"><a id="a5581977c5a203ffc70dcc208e39e67f9" name="a5581977c5a203ffc70dcc208e39e67f9"></a>
constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1SSEFilter.html">expressions::SSEFilter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>useNeonOrSSE</b></td></tr>
<tr class="separator:a5581977c5a203ffc70dcc208e39e67f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4afc0df5c9d66209b0dec9f4db0515da"><td class="memTemplParams" colspan="2">template&lt;class DstType &gt; </td></tr>
<tr class="memitem:ga4afc0df5c9d66209b0dec9f4db0515da"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1TransformedByStaticCast.html">expressions::TransformedByStaticCast</a>, DstType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga4afc0df5c9d66209b0dec9f4db0515da">transformedByStaticCastTo</a></td></tr>
<tr class="memdesc:ga4afc0df5c9d66209b0dec9f4db0515da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms all source elements to DstValueType by applying a static_cast&lt;DstValueType&gt; to them.  <br /></td></tr>
<tr class="separator:ga4afc0df5c9d66209b0dec9f4db0515da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga778493aa5f46f4a688de257b299c8d92"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Acos.html">expressions::Acos</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga778493aa5f46f4a688de257b299c8d92">acos</a></td></tr>
<tr class="memdesc:ga778493aa5f46f4a688de257b299c8d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cosine of each source element.  <br /></td></tr>
<tr class="separator:ga778493aa5f46f4a688de257b299c8d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45af1bb62e14a9d6aa8380346c030c8e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Acosh.html">expressions::Acosh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga45af1bb62e14a9d6aa8380346c030c8e">acosh</a></td></tr>
<tr class="memdesc:ga45af1bb62e14a9d6aa8380346c030c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of each source element.  <br /></td></tr>
<tr class="separator:ga45af1bb62e14a9d6aa8380346c030c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga429a6b58b01f054a80d007bc2a6cb7a5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Asin.html">expressions::Asin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga429a6b58b01f054a80d007bc2a6cb7a5">asin</a></td></tr>
<tr class="memdesc:ga429a6b58b01f054a80d007bc2a6cb7a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse sine of each source element.  <br /></td></tr>
<tr class="separator:ga429a6b58b01f054a80d007bc2a6cb7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga321147aab676531cb4af96f4b4f64d32"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Asinh.html">expressions::Asinh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga321147aab676531cb4af96f4b4f64d32">asinh</a></td></tr>
<tr class="memdesc:ga321147aab676531cb4af96f4b4f64d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of each source element.  <br /></td></tr>
<tr class="separator:ga321147aab676531cb4af96f4b4f64d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga666c0848887d4feecc228569b1f7a678"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Atan.html">expressions::Atan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga666c0848887d4feecc228569b1f7a678">atan</a></td></tr>
<tr class="memdesc:ga666c0848887d4feecc228569b1f7a678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse tangent of each source element.  <br /></td></tr>
<tr class="separator:ga666c0848887d4feecc228569b1f7a678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bec0884896ef9a38043781f9a6f7179"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Atanh.html">expressions::Atanh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga9bec0884896ef9a38043781f9a6f7179">atanh</a></td></tr>
<tr class="memdesc:ga9bec0884896ef9a38043781f9a6f7179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of each source element.  <br /></td></tr>
<tr class="separator:ga9bec0884896ef9a38043781f9a6f7179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga896371d63c7f50b8cf87211c4b07749e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Cos.html">expressions::Cos</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga896371d63c7f50b8cf87211c4b07749e">cos</a></td></tr>
<tr class="memdesc:ga896371d63c7f50b8cf87211c4b07749e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of each source element.  <br /></td></tr>
<tr class="separator:ga896371d63c7f50b8cf87211c4b07749e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73474b549d4401d5ad5d746dd1b78d49"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Cosh.html">expressions::Cosh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga73474b549d4401d5ad5d746dd1b78d49">cosh</a></td></tr>
<tr class="memdesc:ga73474b549d4401d5ad5d746dd1b78d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of each source element.  <br /></td></tr>
<tr class="separator:ga73474b549d4401d5ad5d746dd1b78d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga179f04cf1507d218f7ed1dd4390af4a5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Sin.html">expressions::Sin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga179f04cf1507d218f7ed1dd4390af4a5">sin</a></td></tr>
<tr class="memdesc:ga179f04cf1507d218f7ed1dd4390af4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine of each source element.  <br /></td></tr>
<tr class="separator:ga179f04cf1507d218f7ed1dd4390af4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae41920cbcbb09b4745423d71133bd457"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Sinh.html">expressions::Sinh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gae41920cbcbb09b4745423d71133bd457">sinh</a></td></tr>
<tr class="memdesc:gae41920cbcbb09b4745423d71133bd457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of each source element.  <br /></td></tr>
<tr class="separator:gae41920cbcbb09b4745423d71133bd457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b82fa61931a8f399094c5f9d96305b7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Tan.html">expressions::Tan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#ga8b82fa61931a8f399094c5f9d96305b7">tan</a></td></tr>
<tr class="memdesc:ga8b82fa61931a8f399094c5f9d96305b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of each source element.  <br /></td></tr>
<tr class="separator:ga8b82fa61931a8f399094c5f9d96305b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe4e6979458e366c27117a7c163eef06"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">ExpressionChainBuilder</a>&lt; <a class="el" href="classvctr_1_1expressions_1_1Tanh.html">expressions::Tanh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Expressions.html#gafe4e6979458e366c27117a7c163eef06">tanh</a></td></tr>
<tr class="memdesc:gafe4e6979458e366c27117a7c163eef06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of each source element.  <br /></td></tr>
<tr class="separator:gafe4e6979458e366c27117a7c163eef06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2879d4e781cb85ff0ae8cf4f1deefd"><td class="memTemplParams" colspan="2">template&lt;has::size T&gt; </td></tr>
<tr class="memitem:a0e2879d4e781cb85ff0ae8cf4f1deefd"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevctr.html#a0e2879d4e781cb85ff0ae8cf4f1deefd">extentOf</a> = detail::Extent&lt;std::remove_cvref_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a0e2879d4e781cb85ff0ae8cf4f1deefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equals the extent of the container or expression type.  <br /></td></tr>
<tr class="separator:a0e2879d4e781cb85ff0ae8cf4f1deefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main namespace of the VCTR project. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ad3cbb6dc6bd6736802f5a7537b8dfb62" name="ad3cbb6dc6bd6736802f5a7537b8dfb62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3cbb6dc6bd6736802f5a7537b8dfb62">&#9670;&#160;</a></span>DataType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevctr.html#ad3cbb6dc6bd6736802f5a7537b8dfb62">vctr::DataType</a> = typedef typename detail::DataType&lt;std::remove_reference_t&lt;T&gt; &gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The const correct element type derived from a call to T::data. </p>

</div>
</div>
<a id="a40c9f56937ddfca3c1b85f5f52627deb" name="a40c9f56937ddfca3c1b85f5f52627deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c9f56937ddfca3c1b85f5f52627deb">&#9670;&#160;</a></span>ExpressionChainBuilder</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, class... &gt; class ExpressionType, class... AdditionalCompileTimeParameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevctr.html#a40c9f56937ddfca3c1b85f5f52627deb">vctr::ExpressionChainBuilder</a> = typedef <a class="el" href="structvctr_1_1ExpressionChainBuilderWithRuntimeArgs.html">ExpressionChainBuilderWithRuntimeArgs</a>&lt;ExpressionType, detail::RuntimeArgChain&lt;std::tuple&lt;&gt; &gt;, AdditionalCompileTimeParameters...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient typedef to create a simple expression chain builder instance for an expression template. </p>

</div>
</div>
<a id="aa10a74a826089c483c4eb7feb374f09f" name="aa10a74a826089c483c4eb7feb374f09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10a74a826089c483c4eb7feb374f09f">&#9670;&#160;</a></span>FloatType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;is::realNumber T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevctr.html#aa10a74a826089c483c4eb7feb374f09f">vctr::FloatType</a> = typedef typename detail::FloatType&lt;std::remove_cvref_t&lt;T&gt; &gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The best matching float type for the real number type T. </p>
<p>If T is an integer, the type will be float if T is &lt; 32 Bit and double otherwise. If T is a floating point type, the type will be T. </p>

</div>
</div>
<a id="abbf99aea4bbfba08d526a19614f28516" name="abbf99aea4bbfba08d526a19614f28516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf99aea4bbfba08d526a19614f28516">&#9670;&#160;</a></span>RealType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;is::number T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevctr.html#abbf99aea4bbfba08d526a19614f28516">vctr::RealType</a> = typedef typename detail::RealType&lt;std::remove_cvref_t&lt;T&gt; &gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If T is any instance of std::complex, this will be the real value_type, otherwise this will be T. </p>

</div>
</div>
<a id="a222cc9e4338c24b2f0751c132503ce3a" name="a222cc9e4338c24b2f0751c132503ce3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222cc9e4338c24b2f0751c132503ce3a">&#9670;&#160;</a></span>StorageInfoType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;has::sizeAndData T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevctr.html#a222cc9e4338c24b2f0751c132503ce3a">vctr::StorageInfoType</a> = typedef typename detail::StorageInfoType&lt;std::remove_cvref_t&lt;T&gt; &gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If t is a type derived from <a class="el" href="classvctr_1_1VctrBase.html" title="The base class to all one dimensional containers and views in the VCTR project.">VctrBase</a>, this will equal the return value of T::getStorageInfo, otherwise this will be StorageInfo&lt;T&gt;. </p>

</div>
</div>
<a id="a83a43fd917a646b18b60be7e88becc33" name="a83a43fd917a646b18b60be7e88becc33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a43fd917a646b18b60be7e88becc33">&#9670;&#160;</a></span>ValueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevctr.html#a83a43fd917a646b18b60be7e88becc33">vctr::ValueType</a> = typedef typename detail::ValueType&lt;std::remove_cvref_t&lt;T&gt; &gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If T is an expression template, it equals its return type, if it's a type that defines value_type as a public typedef, it equals value_type. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a530eaa0685b6027bcdd79a4ac9a47fda" name="a530eaa0685b6027bcdd79a4ac9a47fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530eaa0685b6027bcdd79a4ac9a47fda">&#9670;&#160;</a></span>assertCommonSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void vctr::assertCommonSize </td>
          <td>(</td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that both sources have the same size. </p>
<p>In case they both specify a non-dynamic extent, this will be a compile-time static_assert, otherwise it will perform a runtime assert comparing the sizes. </p>

</div>
</div>
<a id="a127327a069f9c9d92bb9c5325234f2fe" name="a127327a069f9c9d92bb9c5325234f2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127327a069f9c9d92bb9c5325234f2fe">&#9670;&#160;</a></span>functionName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Arg , R(*)(Arg) fn&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">consteval std::string_view vctr::functionName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name for a function with a single argument. </p>

</div>
</div>
<a id="acd3bde90036f67b89e469aea181516e8" name="acd3bde90036f67b89e469aea181516e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3bde90036f67b89e469aea181516e8">&#9670;&#160;</a></span>functionName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class ArgA , class ArgB , R(*)(ArgA, ArgB) fn&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">consteval std::string_view vctr::functionName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name for a function with two arguments. </p>

</div>
</div>
<a id="a50b3b641de5cbcac59ad5c852df70929" name="a50b3b641de5cbcac59ad5c852df70929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b3b641de5cbcac59ad5c852df70929">&#9670;&#160;</a></span>getCommonExtent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">consteval size_t vctr::getCommonExtent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns std::dynamic_extent in case both sources specify a dynamic extent. </p>
<p>Throws in case both sources specify a non-matching non-dynamic extent. Returns the non-dynamic extent found otherwise. </p>

</div>
</div>
<a id="afc1a63f35218dca5e5e92802c49b2793" name="afc1a63f35218dca5e5e92802c49b2793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1a63f35218dca5e5e92802c49b2793">&#9670;&#160;</a></span>makeExpressionChainBuilderWithRuntimeArgs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, class... &gt; class ExpressionType, class... RuntimeArgs&gt; <br />
requires (sizeof... (RuntimeArgs) &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto vctr::makeExpressionChainBuilderWithRuntimeArgs </td>
          <td>(</td>
          <td class="paramtype">RuntimeArgs...&#160;</td>
          <td class="paramname"><em>runtimeArgs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to build factory functions for expressions that rely on runtime argument values. </p>
<p>These kinds of expressions don't expose a constexpr instance of the expression chain builder but supply a factory function, which returns an expression chain builder instance which holds the desired value to apply. Example: Example: </p><div class="fragment"><div class="line"><span class="comment">// The factory function that takes the desired runtime argument s.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="group__Expressions.html#gadb6fc764c304eda32439875e7b50d485">clamp</a> (T lowerBound, T upperBound)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> makeExpressionChainBuilderWithRuntimeArgs&lt;Clamp&gt; (lowerBound, upperBound);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__Expressions_html_gadb6fc764c304eda32439875e7b50d485"><div class="ttname"><a href="group__Expressions.html#gadb6fc764c304eda32439875e7b50d485">vctr::clamp</a></div><div class="ttdeci">constexpr auto clamp(T lowerBound, T upperBound)</div><div class="ttdoc">Ensures that the elements are not lower than lowerBound and not higher than upperBound.</div><div class="ttdef"><b>Definition:</b> Clamp.h:225</div></div>
</div><!-- fragment --><p>The expression chain created like that will later pass the two arguments to the void applyRuntimeArgs member function of the expression in the same order as they were passed to makeExpressionChainBuilderWithRuntimeArgs – so in case you want to build an expression that takes runtime arguments, make sure to implement that function. </p>

</div>
</div>
<a id="a946767da5d097bc029825bba6c2a2595" name="a946767da5d097bc029825bba6c2a2595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946767da5d097bc029825bba6c2a2595">&#9670;&#160;</a></span>makeSimdAlignedSpan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t extent, class ElementType &gt; <br />
requires (extent != std::dynamic_extent)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto vctr::makeSimdAlignedSpan </td>
          <td>(</td>
          <td class="paramtype">ElementType *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a span with static extent pointing to a memory location that is expected to be SIMD aligned. </p>

</div>
</div>
<a id="a5e7c9ccef500aff1ca7881f2e1904408" name="a5e7c9ccef500aff1ca7881f2e1904408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e7c9ccef500aff1ca7881f2e1904408">&#9670;&#160;</a></span>makeSimdAlignedSpan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vctr::makeSimdAlignedSpan </td>
          <td>(</td>
          <td class="paramtype">ElementType *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a span with dynamic extent pointing to a memory location that is expected to be SIMD aligned. </p>

</div>
</div>
<a id="a340fb7574b2f7707e6f86ca65fd2ccbb" name="a340fb7574b2f7707e6f86ca65fd2ccbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340fb7574b2f7707e6f86ca65fd2ccbb">&#9670;&#160;</a></span>makeTemplateExpressionChainBuilderWithRuntimeArgs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, class... &gt; class ExpressionType, class ExpressionTemplateArg , class... RuntimeArgs&gt; <br />
requires (sizeof... (RuntimeArgs) &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto vctr::makeTemplateExpressionChainBuilderWithRuntimeArgs </td>
          <td>(</td>
          <td class="paramtype">RuntimeArgs...&#160;</td>
          <td class="paramname"><em>runtimeArgs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to build factory functions for expressions that rely on runtime argument values. </p>
<p>This function is just like makeExpressionChainBuilderWithRuntimeArgs except for allowing to pass one further template type argument to the ExpressionType. </p>

</div>
</div>
<a id="af90149542071c83fddeb04c75e9cfd3a" name="af90149542071c83fddeb04c75e9cfd3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90149542071c83fddeb04c75e9cfd3a">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;is::anyVctr Lhs, is::anyVctr Rhs&gt; <br />
requires std::same_as&lt;<a class="el" href="namespacevctr.html#a83a43fd917a646b18b60be7e88becc33">ValueType</a>&lt;Lhs&gt;, <a class="el" href="namespacevctr.html#a83a43fd917a646b18b60be7e88becc33">ValueType</a>&lt;Rhs&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool vctr::operator== </td>
          <td>(</td>
          <td class="paramtype">const Lhs &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Rhs &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs for equality. </p>
<p>They are considered equal if their size is the same and every element at a certain index in lhs compares equal to the corresponding element at the same index in rhs. </p>

</div>
</div>
<a id="abb0c57eb1dc57e153788f2a8631ed6a6" name="abb0c57eb1dc57e153788f2a8631ed6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0c57eb1dc57e153788f2a8631ed6a6">&#9670;&#160;</a></span>simdAlignedSpanStorageInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">consteval auto vctr::simdAlignedSpanStorageInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="structvctr_1_1StaticStorageInfo.html" title="A storage info type especially used to pass compile time constant traits when viewing externally owne...">StaticStorageInfo</a> instance suitable to be passed to a <a class="el" href="classvctr_1_1Span.html" title="The view type.">Span</a> constructor. </p>
<p>Declares the viewed data to be SIMD aligned. Required alignment is 32 byte on x64 and 16 byte on ARM. </p>

</div>
</div>
<a id="aecbd148207a93e819482375969ad3db9" name="aecbd148207a93e819482375969ad3db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecbd148207a93e819482375969ad3db9">&#9670;&#160;</a></span>sizeToInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vctr::sizeToInt </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the size_t argument to an int. </p>
<p>In a debug build, this checks for potential overflow issues </p>

</div>
</div>
<a id="a49c06d6ad88e0ec58063d553c7f15bca" name="a49c06d6ad88e0ec58063d553c7f15bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c06d6ad88e0ec58063d553c7f15bca">&#9670;&#160;</a></span>typeName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">consteval std::string_view vctr::typeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string containing the templates type name. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0e2879d4e781cb85ff0ae8cf4f1deefd" name="a0e2879d4e781cb85ff0ae8cf4f1deefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2879d4e781cb85ff0ae8cf4f1deefd">&#9670;&#160;</a></span>extentOf</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;has::size T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t vctr::extentOf = detail::Extent&lt;std::remove_cvref_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equals the extent of the container or expression type. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacevctr.html">vctr</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
