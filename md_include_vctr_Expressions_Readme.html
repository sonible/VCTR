<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VCTR: How Expression templates work</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="sonible_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">VCTR
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_include_vctr_Expressions_Readme.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">How Expression templates work </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>An expression template contains one or more possibilities to compute a certain (mathematical) expression. The most basic expression template implementation for a unary expression â€“ this means an expression which transforms exactly one source vector into one destination vector must look like that:</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">template &lt;size_t extent, class SrcType&gt;</div>
<div class="line">class MyExpression : ExpressionTemplateBase</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">    // value_type denotes the type of element values generated by this expression. In most cases, this is </div>
<div class="line">    // the source value type, but there are also expressions that transform a source type into a different</div>
<div class="line">    // destination type</div>
<div class="line">    using value_type = vctr::ValueType&lt;SrcType&gt;;</div>
<div class="line">    </div>
<div class="line">private:</div>
<div class="line">    // Will either be a reference to a source container, a chained source expression or in rare cases a container</div>
<div class="line">    // owned by this expression</div>
<div class="line">    SrcType src;</div>
<div class="line">    </div>
<div class="line">public:</div>
<div class="line">    </div>
<div class="line">    // A Constructor that forwards any kind of source</div>
<div class="line">    template &lt;class Src&gt;</div>
<div class="line">    constexpr ExpressionName (Src&amp;&amp; s) : src (std::forward&lt;Src&gt; (s)) {}</div>
<div class="line"> </div>
<div class="line">    // A size function to figure out the number of elements generated by this expression</div>
<div class="line">    constexpr size_t size() const { return src.size (); }</div>
<div class="line"> </div>
<div class="line">    // An operator to evaluate the result at index i. Should be constexpr if possible</div>
<div class="line">    VCTR_FORCEDINLINE constexpr value_type operator[] (size_t i) const</div>
<div class="line">    {</div>
<div class="line">        return someComputation (src[i]);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    // Some expression need runtime args. Even if this expression does not need them, it should try to forward them</div>
<div class="line">    template &lt;size_t i, class RuntimeArgs&gt;</div>
<div class="line">    constexpr void iterateOverRuntimeArgChain (const RuntimeArgs&amp; rtArgs)</div>
<div class="line">    {</div>
<div class="line">        tryApplyingRuntimeArgsToSrc&lt;i + 1&gt; (rtArgs, src); </div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>The only exception to the minimum requirements outlined above are reduction expressions which are discussed separately below.</p>
<p>Every kind of expression has to take at least two template arguments:</p>
<ul>
<li>The extent, which is denoted by the source of the expression</li>
<li>The source type(s). Unary expressions, this means expressions that have a single source, need to specify a single source type. Expressions with multiple sources have to specify multiple source types accordingly.</li>
</ul>
<p>Since all the member functions described above need to be implemented for every expression, there is a macro that replaces all the repetitive boilerplate code. With that the example above will look like this:</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">template &lt;size_t extent, class SrcType&gt;</div>
<div class="line">class MyExpression : ExpressionTemplateBase</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">    using value_type = vctr::ValueType&lt;SrcType&gt;;</div>
<div class="line">    </div>
<div class="line">    VCTR_COMMON_UNARY_EXPRESSION_MEMBERS (MyExpression, src)</div>
<div class="line"> </div>
<div class="line">    VCTR_FORCEDINLINE constexpr value_type operator[] (size_t i) const</div>
<div class="line">    {</div>
<div class="line">        return someComputation (src[i]);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>This should be the basic starting point for every expression template.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Creating an &lt;tt&gt;ExpressionChainBuilder&lt;/tt&gt; instance</h1>
<p>In order to use the <code>operator&lt;&lt;</code> chaining syntax, a unary expression has to be wrapped into an <code>ExpressionChainBuilder</code> instance. An expression chain builder holds all information about how to build a chain of expressions without actually building one right away. It supplies overloads for <code>operator&lt;&lt;</code> that return different objects, based on what they are called on.</p><ul>
<li>If the argument passed to it is another expression chain builder, it returns a new expression chain builder instance which now represents the chain of both expressions</li>
<li>If the argument passed to it is a source span or container and the last expression in the chain is no reduction expression, it returns the actual expression template instance which wraps the source passed in. This expression can then be assigned to another Vctr object in order to get evalutated.</li>
<li>If the argument passed to it is a source span or container and the last expression in the chain is a reduction expression, it evaluates the reduction and returns the reduction result.</li>
</ul>
<p>Pure <code>ExpressionChainBuilder</code> instances have no members and should be <code>constexpr</code>. Simply declare it like this at the end of your implementation:</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">constexpr inline ExpressionChainBuilder&lt;MyExpression&gt; myExpression;</div>
</div><!-- fragment --><p>Some expressions need runtime values to work, for an example the <code>clamp</code> expression which needs to know the limit values. Since the actual expression instance does not yet exist while using the expression chain builder to set up an expression chain the generalised <code>ExpressionChainBuilderWithRuntimeArgs</code> class allows storing one or more runtime arguments applied to each expression once the expression chain is set up. Expressions that need runtime arguments don't expose a <code>constexpr ExpressionChainBuilder</code> instance but a free function that takes the arguments and returns an expression chain builder instance that stores the arguments. This is done with the makeExpressionChainBuilderWithRuntimeArgs function: </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">template &lt;class T&gt;</div>
<div class="line">constexpr auto expressionWithArgs (T arg1, T arg2)</div>
<div class="line">{</div>
<div class="line">    return makeExpressionChainBuilderWithRuntimeArgs&lt;ExpressionWithArgs&gt; (arg1, arg2);</div>
<div class="line">}</div>
</div><!-- fragment --><p>When the expression instance is created, the chain builder has to apply the argument to the expression. Therefore, we need to add an <code>applyRuntimeArgs</code> member function to the expression template, which accepts the same number of arguments as passed to the expression chain builder instance and applies them to the actual expression: </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">constexpr void applyRuntimeArgs (value_type arg1, value_type arg2)</div>
<div class="line">{</div>
<div class="line">   // apply the args to some member variables, some sanity checks...</div>
<div class="line">}</div>
</div><!-- fragment --><p>the <code>VCTR_COMMON_UNARY_EXPRESSION_MEMBERS</code> macro automatically takes care of calling that function from within the automatically generated iterateOverRuntimeArgChain function in case it exists.</p>
<p>The values are passed by copy since one expression chain builder instance could create multiple expression instances, therefore the arguments should be cheap to copy if possible. Otherwise, there are no limits to the type and number of arguments.</p>
<p>An alternative approach to pass values to an expression are compile time constants. To do so, you can add further <code>std::integral_constant</code> like template arguments to the expression: </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">template &lt;size_t extent, class SrcType, class Const&gt;</div>
<div class="line">class MyExpressionWithConstant : ExpressionTemplateBase</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">    using value_type = ValueType&lt;SrcType&gt;;</div>
<div class="line">    </div>
<div class="line">    static constexpr constValue = value_type (Const::value);</div>
<div class="line">    </div>
<div class="line">    //...</div>
<div class="line">}</div>
</div><!-- fragment --><p>The corresponding expression chain builder is a variable template then: </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">template &lt;auto arg&gt;</div>
<div class="line">constexpr inline ExpressionChainBuilder&lt;MyExpressionWithConstant, Constant&lt;arg&gt;&gt; myExpressionWithConstant;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md2"></a>
Binary expressions</h1>
<p>The types of expressions described above are unary expressions, this means that they transform a single source vector or expression. Operations like e.g. additions and multiplications need multiple operands. They should take two source types as template argument and two constructor arguments accordingly. The <code>VCTR_COMMON_BINARY_VEC_VEC_EXPRESSION_MEMBERS</code> and <code>VCTR_COMMON_BINARY_SINGLE_VEC_EXPRESSION_MEMBERS</code> macros should be chosen to generate the boilerplate code in this case. Those expressions are exposed via free functions or operator overloads. This is how e.g. the vector addition implementation looks like:</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">template &lt;class SrcAType, class SrcBType&gt;</div>
<div class="line">requires (is::anyVctrOrExpression&lt;std::remove_cvref_t&lt;SrcAType&gt;&gt; &amp;&amp;</div>
<div class="line">          is::anyVctrOrExpression&lt;std::remove_cvref_t&lt;SrcBType&gt;&gt;)</div>
<div class="line">constexpr auto operator+ (SrcAType&amp;&amp; a, SrcBType&amp;&amp; b)</div>
<div class="line">{</div>
<div class="line">    assertCommonSize (a, b);</div>
<div class="line">    constexpr auto extent = getCommonExtent&lt;SrcAType, SrcBType&gt;();</div>
<div class="line"> </div>
<div class="line">    return AddVectors&lt;extent, SrcAType, SrcBType&gt; (std::forward&lt;SrcAType&gt; (a), std::forward&lt;SrcBType&gt; (b));</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that we have to take care that sizes match when combining multiple sources through an expression. This can be done by the <code>assertCommonSize</code> helper function, which performs a compile-time check in case both expressions have a runtime defined extent or a run-time check in case one of them or both have a dynamic extent.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Using alternative approaches to evaluate the expression</h1>
<p>Besides the per-element evaluation through <code>operator[]</code>, the expression can implement various other ways to evaluate the expression:</p>
<ul>
<li>AXV: Implement <code>AVXRegister&lt;value_type&gt; getAVX (size_t i) const</code> for suitable types. Make sure to require at least <code>archX64 &amp;&amp; has::getAVX&lt;SrcType&gt;</code></li>
<li>SSE: Implement <code>SSERegister&lt;value_type&gt; getSSE (size_t i) const</code> for suitable types. Make sure to require at least <code>archX64 &amp;&amp; has::getSSE&lt;SrcType&gt;</code></li>
<li>Neon: Implement <code>NeonRegister&lt;value_type&gt; getNeon (size_t i) const</code> for suitable types. Make sure to require at least <code>archARM &amp;&amp; has::getNeon&lt;SrcType&gt;</code></li>
<li>Platform specific vector operations (Intel IPP, Apple Accelerate, etc). See dedicated section below.</li>
</ul>
<p>Intel architecture specific implementations have to be prefixed with the <code>VCTR_TARGET (&lt;arch&gt;)</code> macro to instruct the compiler to deliberately generate instructions for that instruction set, no matter what compiler flags are set. The calling side will do a runtime check if the corresponding functions are available at runtime. Valid values for <code>&lt;arch&gt;</code> are <code>"avx"</code>, <code>"avx2&lt;/tt&gt;" and `"sse4.1"`.</code></p>
<p><code>In case implementations are only available or make sense for specific constraints, you can constrain them and possibly add multiple implementations for different types, e.g. like this</code></p>
<p><code></p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">VCTR_FORCEDINLINE VCTR_TARGET (&quot;sse4.1&quot;) SSERegister&lt;value_type&gt; getSSE (size_t i) const</div>
<div class="line">requires (archX64 &amp;&amp; has::getSSE&lt;SrcType&gt; &amp;&amp; is::realFloatNumber&lt;SrcElementType&gt;)</div>
<div class="line">{</div>
<div class="line">    static const auto sseSignBit = SSESrcType::broadcast (SrcElementType (-0.0));</div>
<div class="line"> </div>
<div class="line">    return SSERetType::andNot (sseSignBit, src.getSSE (i));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">VCTR_FORCEDINLINE VCTR_TARGET (&quot;sse4.1&quot;) SSERegister&lt;value_type&gt; getSSE (size_t i) const</div>
<div class="line">requires (archX64 &amp;&amp; has::getSSE&lt;SrcType&gt; &amp;&amp; std::same_as&lt;int32_t, value_type&gt;)</div>
<div class="line">{</div>
<div class="line">    return SSERetType::abs (src.getSSE (i));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">VCTR_FORCEDINLINE VCTR_TARGET (&quot;sse4.1&quot;) SSERegister&lt;value_type&gt; getSSE (size_t i) const</div>
<div class="line">requires (archX64 &amp;&amp; has::getSSE&lt;SrcType&gt; &amp;&amp; is::unsignedIntNumber&lt;value_type&gt;)</div>
<div class="line">{</div>
<div class="line">    return src.getSSE (i); // unsigned integers are always positive</div>
<div class="line">}</div>
</div><!-- fragment --><p></code></p>
<p><code>Here we see some explicit overloads for floating point values, int32 values and unsigned integers. For int64, there is no straightforward abs function in SSE 4.1 so we don't implement it. Calling abs on an int64 vector might fall back to the default <code>operator[]</code> implementation then. When assigning the expression, the implementation tries its best to choose the most promising strategy for the given architecture it runs on, so it's a good idea to implement multiple possibilities.</code></p>
<p><code>Some SIMD based evaluations can gain performance by storing constants to a SIMD register once before looping over the registers. These temporary registers are managed as private <code>mutable</code> member variables in the expression class. They are mutable since expressions are usually passed as const reference to the destination container that evaluates them, and they are used as temporary working buffer only. Since multithreaded expression evaluation is not supported, this is safe. To avoid the need of declaring individual variables per register type which will never be used simultaneously, we can use the <code>SIMDRegisterUnion</code> union template which contains a Neon, an AVX and an SSE register. To initialize the values in the register before the SIMD evaluation starts, the expression has to expose a <code>prepare&lt;arch&gt;Evaluation</code> function with <code>&lt;arch&gt;</code> being one of <code>Neon</code>, <code>AVX</code> and <code>SSE</code> for every evaluation function that it implements. Even if the expression does not make use of that feature, it has to forward those functions to the source expressions. To avoid a lot of boilerplate code, the <code>VCTR_FORWARD_PREPARE_SIMD_EVALUATION_UNARY_EXPRESSION_MEMBER_FUNCTIONS</code> and <code>VCTR_FORWARD_PREPARE_SIMD_EVALUATION_BINARY_EXPRESSION_MEMBER_FUNCTIONS</code> macros can be used. A manual implementation can look like this, taking an expression that sums a SIMD register with a scalar value: </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">public:</div>
<div class="line">    //...</div>
<div class="line">    </div>
<div class="line">    // AVX Implementation</div>
<div class="line">    VCTR_FORCEDINLINE VCTR_TARGET (&quot;avx&quot;) void prepareAVXEvaluation() const</div>
<div class="line">    requires has::prepareAVXEvaluation&lt;SrcType&gt; &amp;&amp; Expression::CommonElement::isRealFloat</div>
<div class="line">    {</div>
<div class="line">        src.prepareAVXEvaluation();</div>
<div class="line">        singleSIMD.avx = Expression::AVX::broadcast (single);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    VCTR_FORCEDINLINE VCTR_TARGET (&quot;avx2&quot;) void prepareAVXEvaluation() const</div>
<div class="line">    requires has::prepareAVXEvaluation&lt;SrcType&gt; &amp;&amp; Expression::CommonElement::isInt</div>
<div class="line">    {</div>
<div class="line">        src.prepareAVXEvaluation();</div>
<div class="line">        singleSIMD.avx = Expression::AVX::broadcast (single);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    VCTR_FORCEDINLINE VCTR_TARGET (&quot;avx&quot;) AVXRegister&lt;value_type&gt; getAVX (size_t i) const</div>
<div class="line">    requires (archX64 &amp;&amp; has::getAVX&lt;SrcType&gt; &amp;&amp; Expression::allElementTypesSame &amp;&amp; Expression::CommonElement::isRealFloat)</div>
<div class="line">    {</div>
<div class="line">        return Expression::AVX::add (singleSIMD.avx, src.getAVX (i));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    VCTR_FORCEDINLINE VCTR_TARGET (&quot;avx2&quot;) AVXRegister&lt;value_type&gt; getAVX (size_t i) const</div>
<div class="line">    requires (archX64 &amp;&amp; has::getAVX&lt;SrcType&gt; &amp;&amp; Expression::allElementTypesSame &amp;&amp; Expression::CommonElement::isInt)</div>
<div class="line">    {</div>
<div class="line">        return Expression::AVX::add (singleSIMD.avx, src.getAVX (i));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    // SSE Implementation</div>
<div class="line">    VCTR_FORCEDINLINE VCTR_TARGET (&quot;sse4.1&quot;) void prepareSSEEvaluation() const</div>
<div class="line">    requires has::prepareSSEEvaluation&lt;SrcType&gt;</div>
<div class="line">    {</div>
<div class="line">        src.prepareSSEEvaluation();</div>
<div class="line">        singleSIMD.sse = Expression::SSE::broadcast (single);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    VCTR_FORCEDINLINE VCTR_TARGET (&quot;sse4.1&quot;) SSERegister&lt;value_type&gt; getSSE (size_t i) const</div>
<div class="line">    requires (archX64 &amp;&amp; has::getSSE&lt;SrcType&gt; &amp;&amp; Expression::allElementTypesSame)</div>
<div class="line">    {</div>
<div class="line">        return Expression::SSE::add (singleSIMD.sse, src.getSSE (i));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">    mutable SIMDRegisterUnion&lt;Expression&gt; singleSIMD {};</div>
</div><!-- fragment --><p></code></p>
<p><code>Note: Don't forget the default initialization braces for your <code>SIMDRegisterUnion</code> member(s), otherwise the expression class won't work in a constexpr context.</code></p>
<p><code></code></p>
<h1><a class="anchor" id="autotoc_md4"></a>
Platform Specific Vector Operations</h1>
<p><code> In many cases, highly optimized vector operation libraries like Intel IPP or Apple Accelerate outperform our handwritten SIMD code. We can also use them to execute our expressions. To do so, we need to implement <code>evalNextVectorOpInExpressionChain</code>. Let's have a look of the <code>Abs</code> template again to see how it's used:</code></p>
<p><code></p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">VCTR_FORCEDINLINE const value_type* evalNextVectorOpInExpressionChain (value_type* dst) const</div>
<div class="line">requires (platformApple &amp;&amp; has::evalNextVectorOpInExpressionChain&lt;SrcType, value_type&gt; &amp;&amp; is::realFloatNumber&lt;value_type&gt;)</div>
<div class="line">{</div>
<div class="line">    AccelerateRetType::abs (src.evalNextVectorOpInExpressionChain (dst), dst, int (size()));</div>
<div class="line">    return dst;</div>
<div class="line">}</div>
</div><!-- fragment --><p></code></p>
<p><code><code>evalNextVectorOpInExpressionChain</code> takes a destination memory location as argument and returns a source memory location. The returned pointer is the memory that the next expression should read from. The argument is the memory that we write our expression result to. When we assign an expression to a Vector, it will pass the vectors' storage as argument to <code>evalNextVectorOpInExpressionChain</code>. This way we are able to write the expression result directly into the destination memory. A usual expression template should return the destination memory, making chained expression work in place on the destination memory. <code>VctrBase</code> is the only class that returns its <code>data</code> pointer from <code>evalNextVectorOpInExpressionChain</code>, so if the source is a vector, the first expression will perform an out-of-place operation from the source memory into the destination memory.</code></p>
<p><code>As we write to the destination memory directly, there can be cases where we need the destination vector as a source vector while evaluating the expression. Take this one for an example: ` a = a + <a class="el" href="group__Expressions.html#gac4fac892235effd8638c99018b7ab32f" title="Computes the absolute value of the source values.">vctr::abs</a> (b); <code> With the implementation strategy described above, the template would first call</code>evalNextVectorOpInExpressionChain<code>on the</code>abs (b)<code>expression, take the memory of</code>b<code>as source and write the result into the memory of</code>a<code>. Then it would perform the addition between the result of that computation and</code>a<code>. But wait, at that point, we already replaced the value of</code>a<code>with the result of</code>abs (b)<code>. We have an aliasing problem here. To overcome this problem, we need </code>isNotAliased<code>. It takes the destination memory as argument and returns false in case it detects a case of aliasing. As aliasing is only a problem of binary expressions, unary expressions should simply forward the</code>isNotAliased<code>call as a </code>constexpr` function. Binary expressions should do a check like this:</code></p>
<p><code></p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">constexpr bool isNotAliased (const void* dst) const</div>
<div class="line">{</div>
<div class="line">    if constexpr (is::expression&lt;SrcAType&gt; &amp;&amp; is::anyVctr&lt;SrcBType&gt;)</div>
<div class="line">    {</div>
<div class="line">        return dst != srcB.data();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    if constexpr (is::anyVctr&lt;SrcAType&gt; &amp;&amp; is::expression&lt;SrcBType&gt;)</div>
<div class="line">    {</div>
<div class="line">        return dst != srcA.data();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return true;</div>
<div class="line">}</div>
</div><!-- fragment --><p></code></p>
<p><code><code>isNotAliased</code> is also implemented in the <code>VCTR_COMMON_..._EXPRESSION_MEMBERS</code> macros, so you should not need to take care of that yourself.</code></p>
<p><code>As evaluating a binary expression with two expressions as sources can never work with our <code>evalNextVectorOpInExpressionChain</code> implementation strategy as it would need an intermediate buffer that we want to avoid at all costs, binary expressions should always be constrained by the <code>is::suitableForBinaryEvalVectorOp</code> concept.</code></p>
<p><code></code></p>
<h1><a class="anchor" id="autotoc_md5"></a>
Reduction expressions</h1>
<p><code> While the expressions discussed above are used to transform a source vector into a destination vector, reduction expressions reduce a source vector into a single reduction result value. Examples are e.g. a vector sum or finding the maximum value in a vector. They use the same class template signature and also define an <code>ExpressionChainBuilder</code> instance but their member functions look different. Futhermore, an expression chain terminated by a reduction expression is not evaluated lazily when assigned to a destination but are evaluated right away and returns the computed single value.</code></p>
<p><code>The most basic reduction expression template implementation must look like that:</code></p>
<p><code></p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">template &lt;size_t extent, class SrcType&gt;</div>
<div class="line">class MyExpression : ExpressionTemplateBase</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">    using value_type = ValueType&lt;SrcType&gt;;</div>
<div class="line">    </div>
<div class="line">    VCTR_COMMON_UNARY_EXPRESSION_MEMBERS (MyExpression, src)</div>
<div class="line"> </div>
<div class="line">    static constexpr value_type reductionResultInitValue = std::numeric_limits&lt;value_type&gt;::min();</div>
<div class="line"> </div>
<div class="line">    VCTR_FORCEDINLINE constexpr void reduceElementWise (value_type&amp; result, size_t i) const</div>
<div class="line">    {</div>
<div class="line">        result = someComputation (result, src[i]);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    template &lt;size_t n&gt;</div>
<div class="line">    VCTR_FORCEDINLINE static constexpr value_type finalizeReduction (const std::array&lt;value_type, n&gt;&amp; subResults)</div>
<div class="line">    {</div>
<div class="line">        return finalComputationOnSubResults (subResults);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p></code></p>
<p><code>The calling code will create a <code>std::array&lt;value_type, 1&gt;</code> variable which is initialised to <code>reductionResultInitValue</code>. The single array value is then passed to <code>reduceElementWise</code> which is called in a loop over all source elements. After all elements have been processed, the array is passed to <code>finalizeReduction</code> which is expected to perform final computations. While in this case the array will only hold a single element, it can hold multiple sub results in other scenarios discussed below.</code></p>
<p><code>When platform specific vector operations should be used, the required signature is </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">value_type reduceVectorOp() const</div>
</div><!-- fragment --><p></code></p>
<p><code>This usually requires, that the source type supplies direct access to the <code>data()</code> pointer and is likely not suitable when chained expressions are used, as there is no scratch buffer to write the previous expression results to. Better constrain your implementation according to that, using e.g. the <code><a class="el" href="conceptvctr_1_1has_1_1data.html" title="Constrains a type to have a member function data() const.">vctr::has::data</a></code> concept.</code></p>
<p><code>When SIMD operations should be used, the required signature is </p><div class="fragment"><div class="line">{c++}</div>
<div class="line">   VCTR_FORCEDINLINE void reduceNeonRegisterWise (NeonRegister&lt;value_type&gt;&amp; result, size_t i) const;</div>
<div class="line"> </div>
<div class="line">   VCTR_FORCEDINLINE VCTR_TARGET (&quot;avx&quot;) void reduceAVXRegisterWise (AVXRegister&lt;value_type&gt;&amp; result, size_t i) const;</div>
<div class="line"> </div>
<div class="line">   VCTR_FORCEDINLINE VCTR_TARGET (&quot;avx2&quot;) void reduceAVXRegisterWise (AVXRegister&lt;value_type&gt;&amp; result, size_t i) const;</div>
<div class="line"> </div>
<div class="line">   VCTR_FORCEDINLINE VCTR_TARGET (&quot;sse4.1&quot;) void reduceSSERegisterWise (SSERegister&lt;value_type&gt;&amp; result, size_t i) const;</div>
</div><!-- fragment --><p></code></p>
<p><code>They basically work the same as the element-wise implementations but they evaluate a whole SIMD register at a time. Possible residual elements are then evaluated using a scalar loop in the calling code. This leads to a SIMD register and a single scalar value as sub-results, which are passed to <code>finalizeReduction</code> for a last final reduction step. </code></p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
